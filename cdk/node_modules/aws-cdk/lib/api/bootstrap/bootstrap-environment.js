"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = void 0;
const console_1 = require("console");
const path = require("path");
const deploy_bootstrap_1 = require("./deploy-bootstrap");
const legacy_template_1 = require("./legacy-template");
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
const util_1 = require("../../util");
const mode_1 = require("../plugin/mode");
const toolkit_info_1 = require("../toolkit-info");
class Bootstrapper {
    constructor(source = { source: 'default' }, ioHelper) {
        this.source = source;
        this.ioHelper = ioHelper;
    }
    bootstrapEnvironment(environment, sdkProvider, options = {}) {
        switch (this.source.source) {
            case 'legacy':
                return this.legacyBootstrap(environment, sdkProvider, options);
            case 'default':
                return this.modernBootstrap(environment, sdkProvider, options);
            case 'custom':
                return this.customBootstrap(environment, sdkProvider, options);
        }
    }
    async showTemplate(json) {
        const template = await this.loadTemplate();
        process.stdout.write(`${(0, util_1.serializeStructure)(template, json)}\n`);
    }
    /**
     * Deploy legacy bootstrap stack
     *
     */
    async legacyBootstrap(environment, sdkProvider, options = {}) {
        var _a, _b, _c, _d, _e;
        const params = (_a = options.parameters) !== null && _a !== void 0 ? _a : {};
        if ((_b = params.trustedAccounts) === null || _b === void 0 ? void 0 : _b.length) {
            throw new error_1.ToolkitError('--trust can only be passed for the modern bootstrap experience.');
        }
        if ((_c = params.cloudFormationExecutionPolicies) === null || _c === void 0 ? void 0 : _c.length) {
            throw new error_1.ToolkitError('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');
        }
        if (params.createCustomerMasterKey !== undefined) {
            throw new error_1.ToolkitError('--bootstrap-customer-key can only be passed for the modern bootstrap experience.');
        }
        if (params.qualifier) {
            throw new error_1.ToolkitError('--qualifier can only be passed for the modern bootstrap experience.');
        }
        const toolkitStackName = (_d = options.toolkitStackName) !== null && _d !== void 0 ? _d : toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.ioHelper);
        return current.update(await this.loadTemplate(params), {}, {
            ...options,
            terminationProtection: (_e = options.terminationProtection) !== null && _e !== void 0 ? _e : current.terminationProtection,
        });
    }
    /**
     * Deploy CI/CD-ready bootstrap stack from template
     *
     */
    async modernBootstrap(environment, sdkProvider, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const params = (_a = options.parameters) !== null && _a !== void 0 ? _a : {};
        const bootstrapTemplate = await this.loadTemplate();
        const toolkitStackName = (_b = options.toolkitStackName) !== null && _b !== void 0 ? _b : toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.ioHelper);
        const partition = await current.partition();
        if (params.createCustomerMasterKey !== undefined && params.kmsKeyId) {
            throw new error_1.ToolkitError("You cannot pass '--bootstrap-kms-key-id' and '--bootstrap-customer-key' together. Specify one or the other");
        }
        // If people re-bootstrap, existing parameter values are reused so that people don't accidentally change the configuration
        // on their bootstrap stack (this happens automatically in deployStack). However, to do proper validation on the
        // combined arguments (such that if --trust has been given, --cloudformation-execution-policies is necessary as well)
        // we need to take this parameter reuse into account.
        //
        // Ideally we'd do this inside the template, but the `Rules` section of CFN
        // templates doesn't seem to be able to express the conditions that we need
        // (can't use Fn::Join or reference Conditions) so we do it here instead.
        const allTrusted = new Set([
            ...(_c = params.trustedAccounts) !== null && _c !== void 0 ? _c : [],
            ...(_d = params.trustedAccountsForLookup) !== null && _d !== void 0 ? _d : [],
        ]);
        const invalid = intersection(allTrusted, new Set(params.untrustedAccounts));
        if (invalid.size > 0) {
            throw new error_1.ToolkitError(`Accounts cannot be both trusted and untrusted. Found: ${[...invalid].join(',')}`);
        }
        const removeUntrusted = (accounts) => accounts.filter(acc => { var _a; return !((_a = params.untrustedAccounts) === null || _a === void 0 ? void 0 : _a.map(String).includes(String(acc))); });
        const trustedAccounts = removeUntrusted((_e = params.trustedAccounts) !== null && _e !== void 0 ? _e : splitCfnArray(current.parameters.TrustedAccounts));
        (0, console_1.info)(`Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(', ') : '(none)'}`);
        const trustedAccountsForLookup = removeUntrusted((_f = params.trustedAccountsForLookup) !== null && _f !== void 0 ? _f : splitCfnArray(current.parameters.TrustedAccountsForLookup));
        (0, console_1.info)(`Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(', ') : '(none)'}`);
        const cloudFormationExecutionPolicies = (_g = params.cloudFormationExecutionPolicies) !== null && _g !== void 0 ? _g : splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
        if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
            // For self-trust it's okay to default to AdministratorAccess, and it improves the usability of bootstrapping a lot.
            //
            // We don't actually make the implicitly policy a physical parameter. The template will infer it instead,
            // we simply do the UI advertising that behavior here.
            //
            // If we DID make it an explicit parameter, we wouldn't be able to tell the difference between whether
            // we inferred it or whether the user told us, and the sequence:
            //
            // $ cdk bootstrap
            // $ cdk bootstrap --trust 1234
            //
            // Would leave AdministratorAccess policies with a trust relationship, without the user explicitly
            // approving the trust policy.
            const implicitPolicy = `arn:${partition}:iam::aws:policy/AdministratorAccess`;
            await this.ioHelper.notify((0, messages_1.warn)(`Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`));
        }
        else if (cloudFormationExecutionPolicies.length === 0) {
            throw new error_1.ToolkitError(`Please pass \'--cloudformation-execution-policies\' when using \'--trust\' to specify deployment permissions. Try a managed policy of the form \'arn:${partition}:iam::aws:policy/<PolicyName>\'.`);
        }
        else {
            // Remind people what the current settings are
            (0, console_1.info)(`Execution policies: ${cloudFormationExecutionPolicies.join(', ')}`);
        }
        // * If an ARN is given, that ARN. Otherwise:
        //   * '-' if customerKey = false
        //   * '' if customerKey = true
        //   * if customerKey is also not given
        //     * undefined if we already had a value in place (reusing what we had)
        //     * '-' if this is the first time we're deploying this stack (or upgrading from old to new bootstrap)
        const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
        const kmsKeyId = (_h = params.kmsKeyId) !== null && _h !== void 0 ? _h : (params.createCustomerMasterKey === true
            ? CREATE_NEW_KEY
            : params.createCustomerMasterKey === false || currentKmsKeyId === undefined
                ? USE_AWS_MANAGED_KEY
                : undefined);
        /* A permissions boundary can be provided via:
         *    - the flag indicating the example one should be used
         *    - the name indicating the custom permissions boundary to be used
         * Re-bootstrapping will NOT be blocked by either tightening or relaxing the permissions' boundary.
         */
        // InputPermissionsBoundary is an `any` type and if it is not defined it
        // appears as an empty string ''. We need to force it to evaluate an empty string
        // as undefined
        const currentPermissionsBoundary = current.parameters.InputPermissionsBoundary || undefined;
        const inputPolicyName = params.examplePermissionsBoundary
            ? CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY
            : params.customPermissionsBoundary;
        let policyName;
        if (inputPolicyName) {
            // If the example policy is not already in place, it must be created.
            const sdk = (await sdkProvider.forEnvironment(environment, mode_1.Mode.ForWriting)).sdk;
            policyName = await this.getPolicyName(environment, sdk, inputPolicyName, partition, params);
        }
        if (currentPermissionsBoundary !== policyName) {
            if (!currentPermissionsBoundary) {
                await this.ioHelper.notify((0, messages_1.warn)(`Adding new permissions boundary ${policyName}`));
            }
            else if (!policyName) {
                await this.ioHelper.notify((0, messages_1.warn)(`Removing existing permissions boundary ${currentPermissionsBoundary}`));
            }
            else {
                await this.ioHelper.notify((0, messages_1.warn)(`Changing permissions boundary from ${currentPermissionsBoundary} to ${policyName}`));
            }
        }
        return current.update(bootstrapTemplate, {
            FileAssetsBucketName: params.bucketName,
            FileAssetsBucketKmsKeyId: kmsKeyId,
            // Empty array becomes empty string
            TrustedAccounts: trustedAccounts.join(','),
            TrustedAccountsForLookup: trustedAccountsForLookup.join(','),
            CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(','),
            Qualifier: params.qualifier,
            PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === undefined
                ? 'true'
                : 'false',
            InputPermissionsBoundary: policyName,
        }, {
            ...options,
            terminationProtection: (_j = options.terminationProtection) !== null && _j !== void 0 ? _j : current.terminationProtection,
        });
    }
    async getPolicyName(environment, sdk, permissionsBoundary, partition, params) {
        var _a;
        if (permissionsBoundary !== CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY) {
            this.validatePolicyName(permissionsBoundary);
            return Promise.resolve(permissionsBoundary);
        }
        // if no Qualifier is supplied, resort to the default one
        const arn = await this.getExamplePermissionsBoundary((_a = params.qualifier) !== null && _a !== void 0 ? _a : 'hnb659fds', partition, environment.account, sdk);
        const policyName = arn.split('/').pop();
        if (!policyName) {
            throw new error_1.ToolkitError('Could not retrieve the example permission boundary!');
        }
        return Promise.resolve(policyName);
    }
    async getExamplePermissionsBoundary(qualifier, partition, account, sdk) {
        var _a;
        const iam = sdk.iam();
        let policyName = `cdk-${qualifier}-permissions-boundary`;
        const arn = `arn:${partition}:iam::${account}:policy/${policyName}`;
        try {
            let getPolicyResp = await iam.getPolicy({ PolicyArn: arn });
            if (getPolicyResp.Policy) {
                return arn;
            }
        }
        catch (e) {
            // https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetPolicy.html#API_GetPolicy_Errors
            if (e.name === 'NoSuchEntity') {
                // noop, proceed with creating the policy
            }
            else {
                throw e;
            }
        }
        const policyDoc = {
            Version: '2012-10-17',
            Statement: [
                {
                    Action: ['*'],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'ExplicitAllowAll',
                },
                {
                    Condition: {
                        StringEquals: {
                            'iam:PermissionsBoundary': `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                        },
                    },
                    Action: [
                        'iam:CreateUser',
                        'iam:CreateRole',
                        'iam:PutRolePermissionsBoundary',
                        'iam:PutUserPermissionsBoundary',
                    ],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'DenyAccessIfRequiredPermBoundaryIsNotBeingApplied',
                },
                {
                    Action: [
                        'iam:CreatePolicyVersion',
                        'iam:DeletePolicy',
                        'iam:DeletePolicyVersion',
                        'iam:SetDefaultPolicyVersion',
                    ],
                    Resource: `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                    Effect: 'Deny',
                    Sid: 'DenyPermBoundaryIAMPolicyAlteration',
                },
                {
                    Action: ['iam:DeleteUserPermissionsBoundary', 'iam:DeleteRolePermissionsBoundary'],
                    Resource: '*',
                    Effect: 'Deny',
                    Sid: 'DenyRemovalOfPermBoundaryFromAnyUserOrRole',
                },
            ],
        };
        const request = {
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDoc),
        };
        const createPolicyResponse = await iam.createPolicy(request);
        if ((_a = createPolicyResponse.Policy) === null || _a === void 0 ? void 0 : _a.Arn) {
            return createPolicyResponse.Policy.Arn;
        }
        else {
            throw new error_1.ToolkitError(`Could not retrieve the example permission boundary ${arn}!`);
        }
    }
    validatePolicyName(permissionsBoundary) {
        // https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html
        // Added support for policy names with a path
        // See https://github.com/aws/aws-cdk/issues/26320
        const regexp = /[\w+\/=,.@-]+/;
        const matches = regexp.exec(permissionsBoundary);
        if (!(matches && matches.length === 1 && matches[0] === permissionsBoundary)) {
            throw new error_1.ToolkitError(`The permissions boundary name ${permissionsBoundary} does not match the IAM conventions.`);
        }
    }
    async customBootstrap(environment, sdkProvider, options = {}) {
        // Look at the template, decide whether it's most likely a legacy or modern bootstrap
        // template, and use the right bootstrapper for that.
        const version = (0, deploy_bootstrap_1.bootstrapVersionFromTemplate)(await this.loadTemplate());
        if (version === 0) {
            return this.legacyBootstrap(environment, sdkProvider, options);
        }
        else {
            return this.modernBootstrap(environment, sdkProvider, options);
        }
    }
    async loadTemplate(params = {}) {
        switch (this.source.source) {
            case 'custom':
                return (0, util_1.loadStructuredFile)(this.source.templateFile);
            case 'default':
                return (0, util_1.loadStructuredFile)(path.join((0, util_1.bundledPackageRootDir)(__dirname), 'lib', 'api', 'bootstrap', 'bootstrap-template.yaml'));
            case 'legacy':
                return (0, legacy_template_1.legacyBootstrapTemplate)(params);
        }
    }
}
exports.Bootstrapper = Bootstrapper;
/**
 * Magic parameter value that will cause the bootstrap-template.yml to NOT create a CMK but use the default key
 */
const USE_AWS_MANAGED_KEY = 'AWS_MANAGED_KEY';
/**
 * Magic parameter value that will cause the bootstrap-template.yml to create a CMK
 */
const CREATE_NEW_KEY = '';
/**
 * Parameter value indicating the use of the default, CDK provided permissions boundary for bootstrap-template.yml
 */
const CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY = 'CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY';
/**
 * Split an array-like CloudFormation parameter on ,
 *
 * An empty string is the empty array (instead of `['']`).
 */
function splitCfnArray(xs) {
    if (xs === '' || xs === undefined) {
        return [];
    }
    return xs.split(',');
}
function intersection(xs, ys) {
    return new Set(Array.from(xs).filter(x => ys.has(x)));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLWVudmlyb25tZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwLWVudmlyb25tZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUErQjtBQUMvQiw2QkFBNkI7QUFHN0IseURBQWtGO0FBQ2xGLHVEQUE0RDtBQUU1RCxpREFBMEM7QUFDMUMsK0NBQW1EO0FBQ25ELHFDQUEyRjtBQUczRix5Q0FBc0M7QUFDdEMsa0RBQTZEO0FBSTdELE1BQWEsWUFBWTtJQUd2QixZQUNtQixTQUEwQixFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFDaEUsUUFBa0I7UUFERCxXQUFNLEdBQU4sTUFBTSxDQUF5QztRQUdoRSxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRU0sb0JBQW9CLENBQ3pCLFdBQThCLEVBQzlCLFdBQXdCLEVBQ3hCLFVBQXVDLEVBQUU7UUFFekMsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQzNCLEtBQUssUUFBUTtnQkFDWCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNqRSxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDakUsS0FBSyxRQUFRO2dCQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ25FLENBQUM7SUFDSCxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFhO1FBQ3JDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzNDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBQSx5QkFBa0IsRUFBQyxRQUFRLEVB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bnQiOlsiaW1wb3J0IHsgaW5mbyB9IGZyb20gJ2NvbnNvbGUnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB0eXBlIHsgQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zLCBCb290c3RyYXBwaW5nUGFyYW1ldGVycyB9IGZyb20gJy4vYm9vdHN0cmFwLXByb3BzJztcbmltcG9ydCB7IEJvb3RzdHJhcFN0YWNrLCBib290c3RyYXBWZXJzaW9uRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi9kZXBsb3ktYm9vdHN0cmFwJztcbmltcG9ydCB7IGxlZ2FjeUJvb3RzdHJhcFRlbXBsYXRlIH0gZnJvbSAnLi9sZWdhY3ktdGVtcGxhdGUnO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uLy4uLy4uLy4uL0Bhd3MtY2RrL3RtcC10b29sa2l0LWhlbHBlcnMvc3JjL2FwaS9pby9wcml2YXRlJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi9jbGkvbWVzc2FnZXMnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgeyBidW5kbGVkUGFja2FnZVJvb3REaXIsIGxvYWRTdHJ1Y3R1cmVkRmlsZSwgc2VyaWFsaXplU3RydWN0dXJlIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IFNESywgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgdHlwZSB7IFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL2RlcGxveW1lbnRzJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuLi9wbHVnaW4vbW9kZSc7XG5pbXBvcnQgeyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRSB9IGZyb20gJy4uL3Rvb2xraXQtaW5mbyc7XG5cbmV4cG9ydCB0eXBlIEJvb3RzdHJhcFNvdXJjZSA9IHsgc291cmNlOiAnbGVnYWN5JyB9IHwgeyBzb3VyY2U6ICdkZWZhdWx0JyB9IHwgeyBzb3VyY2U6ICdjdXN0b20nOyB0ZW1wbGF0ZUZpbGU6IHN0cmluZyB9O1xuXG5leHBvcnQgY2xhc3MgQm9vdHN0cmFwcGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzb3VyY2U6IEJvb3RzdHJhcFNvdXJjZSA9IHsgc291cmNlOiAnZGVmYXVsdCcgfSxcbiAgICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gICkge1xuICAgIHRoaXMuaW9IZWxwZXIgPSBpb0hlbHBlcjtcbiAgfVxuXG4gIHB1YmxpYyBib290c3RyYXBFbnZpcm9ubWVudChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9LFxuICApOiBQcm9taXNlPFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIHN3aXRjaCAodGhpcy5zb3VyY2Uuc291cmNlKSB7XG4gICAgICBjYXNlICdsZWdhY3knOlxuICAgICAgICByZXR1cm4gdGhpcy5sZWdhY3lCb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gdGhpcy5tb2Rlcm5Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzaG93VGVtcGxhdGUoanNvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtzZXJpYWxpemVTdHJ1Y3R1cmUodGVtcGxhdGUsIGpzb24pfVxcbmApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBsZWdhY3kgYm9vdHN0cmFwIHN0YWNrXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGxlZ2FjeUJvb3RzdHJhcChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9LFxuICApOiBQcm9taXNlPFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1ldGVycyA/PyB7fTtcblxuICAgIGlmIChwYXJhbXMudHJ1c3RlZEFjY291bnRzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJy0tdHJ1c3QgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXM/Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXMgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJy0tYm9vdHN0cmFwLWN1c3RvbWVyLWtleSBjYW4gb25seSBiZSBwYXNzZWQgZm9yIHRoZSBtb2Rlcm4gYm9vdHN0cmFwIGV4cGVyaWVuY2UuJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMucXVhbGlmaWVyKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCctLXF1YWxpZmllciBjYW4gb25seSBiZSBwYXNzZWQgZm9yIHRoZSBtb2Rlcm4gYm9vdHN0cmFwIGV4cGVyaWVuY2UuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9vbGtpdFN0YWNrTmFtZSA9IG9wdGlvbnMudG9vbGtpdFN0YWNrTmFtZSA/PyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRTtcbiAgICBjb25zdCBjdXJyZW50ID0gYXdhaXQgQm9vdHN0cmFwU3RhY2subG9va3VwKHNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudCwgdG9vbGtpdFN0YWNrTmFtZSwgdGhpcy5pb0hlbHBlcik7XG4gICAgcmV0dXJuIGN1cnJlbnQudXBkYXRlKFxuICAgICAgYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUocGFyYW1zKSxcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0ZXJtaW5hdGlvblByb3RlY3Rpb246IG9wdGlvbnMudGVybWluYXRpb25Qcm90ZWN0aW9uID8/IGN1cnJlbnQudGVybWluYXRpb25Qcm90ZWN0aW9uLFxuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBDSS9DRC1yZWFkeSBib290c3RyYXAgc3RhY2sgZnJvbSB0ZW1wbGF0ZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtb2Rlcm5Cb290c3RyYXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLnBhcmFtZXRlcnMgPz8ge307XG5cbiAgICBjb25zdCBib290c3RyYXBUZW1wbGF0ZSA9IGF3YWl0IHRoaXMubG9hZFRlbXBsYXRlKCk7XG5cbiAgICBjb25zdCB0b29sa2l0U3RhY2tOYW1lID0gb3B0aW9ucy50b29sa2l0U3RhY2tOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBCb290c3RyYXBTdGFjay5sb29rdXAoc2RrUHJvdmlkZXIsIGVudmlyb25tZW50LCB0b29sa2l0U3RhY2tOYW1lLCB0aGlzLmlvSGVscGVyKTtcbiAgICBjb25zdCBwYXJ0aXRpb24gPSBhd2FpdCBjdXJyZW50LnBhcnRpdGlvbigpO1xuXG4gICAgaWYgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5rbXNLZXlJZCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHBhc3MgJy0tYm9vdHN0cmFwLWttcy1rZXktaWQnIGFuZCAnLS1ib290c3RyYXAtY3VzdG9tZXIta2V5JyB0b2dldGhlci4gU3BlY2lmeSBvbmUgb3IgdGhlIG90aGVyXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHBlb3BsZSByZS1ib290c3RyYXAsIGV4aXN0aW5nIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHJldXNlZCBzbyB0aGF0IHBlb3BsZSBkb24ndCBhY2NpZGVudGFsbHkgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb24gdGhlaXIgYm9vdHN0cmFwIHN0YWNrICh0aGlzIGhhcHBlbnMgYXV0b21hdGljYWxseSBpbiBkZXBsb3lTdGFjaykuIEhvd2V2ZXIsIHRvIGRvIHByb3BlciB2YWxpZGF0aW9uIG9uIHRoZVxuICAgIC8vIGNvbWJpbmVkIGFyZ3VtZW50cyAoc3VjaCB0aGF0IGlmIC0tdHJ1c3QgaGFzIGJlZW4gZ2l2ZW4sIC0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGlzIG5lY2Vzc2FyeSBhcyB3ZWxsKVxuICAgIC8vIHdlIG5lZWQgdG8gdGFrZSB0aGlzIHBhcmFtZXRlciByZXVzZSBpbnRvIGFjY291bnQuXG4gICAgLy9cbiAgICAvLyBJZGVhbGx5IHdlJ2QgZG8gdGhpcyBpbnNpZGUgdGhlIHRlbXBsYXRlLCBidXQgdGhlIGBSdWxlc2Agc2VjdGlvbiBvZiBDRk5cbiAgICAvLyB0ZW1wbGF0ZXMgZG9lc24ndCBzZWVtIHRvIGJlIGFibGUgdG8gZXhwcmVzcyB0aGUgY29uZGl0aW9ucyB0aGF0IHdlIG5lZWRcbiAgICAvLyAoY2FuJ3QgdXNlIEZuOjpKb2luIG9yIHJlZmVyZW5jZSBDb25kaXRpb25zKSBzbyB3ZSBkbyBpdCBoZXJlIGluc3RlYWQuXG4gICAgY29uc3QgYWxsVHJ1c3RlZCA9IG5ldyBTZXQoW1xuICAgICAgLi4ucGFyYW1zLnRydXN0ZWRBY2NvdW50cyA/PyBbXSxcbiAgICAgIC4uLnBhcmFtcy50cnVzdGVkQWNjb3VudHNGb3JMb29rdXAgPz8gW10sXG4gICAgXSk7XG4gICAgY29uc3QgaW52YWxpZCA9IGludGVyc2VjdGlvbihhbGxUcnVzdGVkLCBuZXcgU2V0KHBhcmFtcy51bnRydXN0ZWRBY2NvdW50cykpO1xuICAgIGlmIChpbnZhbGlkLnNpemUgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBBY2NvdW50cyBjYW5ub3QgYmUgYm90aCB0cnVzdGVkIGFuZCB1bnRydXN0ZWQuIEZvdW5kOiAke1suLi5pbnZhbGlkXS5qb2luKCcsJyl9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVtb3ZlVW50cnVzdGVkID0gKGFjY291bnRzOiBzdHJpbmdbXSkgPT5cbiAgICAgIGFjY291bnRzLmZpbHRlcihhY2MgPT4gIXBhcmFtcy51bnRydXN0ZWRBY2NvdW50cz8ubWFwKFN0cmluZykuaW5jbHVkZXMoU3RyaW5nKGFjYykpKTtcblxuICAgIGNvbnN0IHRydXN0ZWRBY2NvdW50cyA9IHJlbW92ZVVudHJ1c3RlZChwYXJhbXMudHJ1c3RlZEFjY291bnRzID8/IHNwbGl0Q2ZuQXJyYXkoY3VycmVudC5wYXJhbWV0ZXJzLlRydXN0ZWRBY2NvdW50cykpO1xuICAgIGluZm8oYFRydXN0ZWQgYWNjb3VudHMgZm9yIGRlcGxveW1lbnQ6ICR7dHJ1c3RlZEFjY291bnRzLmxlbmd0aCA+IDAgPyB0cnVzdGVkQWNjb3VudHMuam9pbignLCAnKSA6ICcobm9uZSknfWApO1xuXG4gICAgY29uc3QgdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwID0gcmVtb3ZlVW50cnVzdGVkKFxuICAgICAgcGFyYW1zLnRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cCA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHNGb3JMb29rdXApLFxuICAgICk7XG4gICAgaW5mbyhcbiAgICAgIGBUcnVzdGVkIGFjY291bnRzIGZvciBsb29rdXA6ICR7dHJ1c3RlZEFjY291bnRzRm9yTG9va3VwLmxlbmd0aCA+IDAgPyB0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAuam9pbignLCAnKSA6ICcobm9uZSknfWAsXG4gICAgKTtcblxuICAgIGNvbnN0IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMgPVxuICAgICAgcGFyYW1zLmNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMgPz8gc3BsaXRDZm5BcnJheShjdXJyZW50LnBhcmFtZXRlcnMuQ2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyk7XG4gICAgaWYgKHRydXN0ZWRBY2NvdW50cy5sZW5ndGggPT09IDAgJiYgY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEZvciBzZWxmLXRydXN0IGl0J3Mgb2theSB0byBkZWZhdWx0IHRvIEFkbWluaXN0cmF0b3JBY2Nlc3MsIGFuZCBpdCBpbXByb3ZlcyB0aGUgdXNhYmlsaXR5IG9mIGJvb3RzdHJhcHBpbmcgYSBsb3QuXG4gICAgICAvL1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgbWFrZSB0aGUgaW1wbGljaXRseSBwb2xpY3kgYSBwaHlzaWNhbCBwYXJhbWV0ZXIuIFRoZSB0ZW1wbGF0ZSB3aWxsIGluZmVyIGl0IGluc3RlYWQsXG4gICAgICAvLyB3ZSBzaW1wbHkgZG8gdGhlIFVJIGFkdmVydGlzaW5nIHRoYXQgYmVoYXZpb3IgaGVyZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBESUQgbWFrZSBpdCBhbiBleHBsaWNpdCBwYXJhbWV0ZXIsIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHdoZXRoZXJcbiAgICAgIC8vIHdlIGluZmVycmVkIGl0IG9yIHdoZXRoZXIgdGhlIHVzZXIgdG9sZCB1cywgYW5kIHRoZSBzZXF1ZW5jZTpcbiAgICAgIC8vXG4gICAgICAvLyAkIGNkayBib290c3RyYXBcbiAgICAgIC8vICQgY2RrIGJvb3RzdHJhcCAtLXRydXN0IDEyMzRcbiAgICAgIC8vXG4gICAgICAvLyBXb3VsZCBsZWF2ZSBBZG1pbmlzdHJhdG9yQWNjZXNzIHBvbGljaWVzIHdpdGggYSB0cnVzdCByZWxhdGlvbnNoaXAsIHdpdGhvdXQgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgICAgLy8gYXBwcm92aW5nIHRoZSB0cnVzdCBwb2xpY3kuXG4gICAgICBjb25zdCBpbXBsaWNpdFBvbGljeSA9IGBhcm46JHtwYXJ0aXRpb259OmlhbTo6YXdzOnBvbGljeS9BZG1pbmlzdHJhdG9yQWNjZXNzYDtcbiAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KHdhcm4oXG4gICAgICAgIGBVc2luZyBkZWZhdWx0IGV4ZWN1dGlvbiBwb2xpY3kgb2YgJyR7aW1wbGljaXRQb2xpY3l9Jy4gUGFzcyAnLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXMnIHRvIGN1c3RvbWl6ZS5gLFxuICAgICAgKSk7XG4gICAgfSBlbHNlIGlmIChjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgYFBsZWFzZSBwYXNzIFxcJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzXFwnIHdoZW4gdXNpbmcgXFwnLS10cnVzdFxcJyB0byBzcGVjaWZ5IGRlcGxveW1lbnQgcGVybWlzc2lvbnMuIFRyeSBhIG1hbmFnZWQgcG9saWN5IG9mIHRoZSBmb3JtIFxcJ2Fybjoke3BhcnRpdGlvbn06aWFtOjphd3M6cG9saWN5LzxQb2xpY3lOYW1lPlxcJy5gLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtaW5kIHBlb3BsZSB3aGF0IHRoZSBjdXJyZW50IHNldHRpbmdzIGFyZVxuICAgICAgaW5mbyhgRXhlY3V0aW9uIHBvbGljaWVzOiAke2Nsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMuam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICAvLyAqIElmIGFuIEFSTiBpcyBnaXZlbiwgdGhhdCBBUk4uIE90aGVyd2lzZTpcbiAgICAvLyAgICogJy0nIGlmIGN1c3RvbWVyS2V5ID0gZmFsc2VcbiAgICAvLyAgICogJycgaWYgY3VzdG9tZXJLZXkgPSB0cnVlXG4gICAgLy8gICAqIGlmIGN1c3RvbWVyS2V5IGlzIGFsc28gbm90IGdpdmVuXG4gICAgLy8gICAgICogdW5kZWZpbmVkIGlmIHdlIGFscmVhZHkgaGFkIGEgdmFsdWUgaW4gcGxhY2UgKHJldXNpbmcgd2hhdCB3ZSBoYWQpXG4gICAgLy8gICAgICogJy0nIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UncmUgZGVwbG95aW5nIHRoaXMgc3RhY2sgKG9yIHVwZ3JhZGluZyBmcm9tIG9sZCB0byBuZXcgYm9vdHN0cmFwKVxuICAgIGNvbnN0IGN1cnJlbnRLbXNLZXlJZCA9IGN1cnJlbnQucGFyYW1ldGVycy5GaWxlQXNzZXRzQnVja2V0S21zS2V5SWQ7XG4gICAgY29uc3Qga21zS2V5SWQgPVxuICAgICAgcGFyYW1zLmttc0tleUlkID8/XG4gICAgICAocGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ID09PSB0cnVlXG4gICAgICAgID8gQ1JFQVRFX05FV19LRVlcbiAgICAgICAgOiBwYXJhbXMuY3JlYXRlQ3VzdG9tZXJNYXN0ZXJLZXkgPT09IGZhbHNlIHx8IGN1cnJlbnRLbXNLZXlJZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBVU0VfQVdTX01BTkFHRURfS0VZXG4gICAgICAgICAgOiB1bmRlZmluZWQpO1xuXG4gICAgLyogQSBwZXJtaXNzaW9ucyBib3VuZGFyeSBjYW4gYmUgcHJvdmlkZWQgdmlhOlxuICAgICAqICAgIC0gdGhlIGZsYWcgaW5kaWNhdGluZyB0aGUgZXhhbXBsZSBvbmUgc2hvdWxkIGJlIHVzZWRcbiAgICAgKiAgICAtIHRoZSBuYW1lIGluZGljYXRpbmcgdGhlIGN1c3RvbSBwZXJtaXNzaW9ucyBib3VuZGFyeSB0byBiZSB1c2VkXG4gICAgICogUmUtYm9vdHN0cmFwcGluZyB3aWxsIE5PVCBiZSBibG9ja2VkIGJ5IGVpdGhlciB0aWdodGVuaW5nIG9yIHJlbGF4aW5nIHRoZSBwZXJtaXNzaW9ucycgYm91bmRhcnkuXG4gICAgICovXG5cbiAgICAvLyBJbnB1dFBlcm1pc3Npb25zQm91bmRhcnkgaXMgYW4gYGFueWAgdHlwZSBhbmQgaWYgaXQgaXMgbm90IGRlZmluZWQgaXRcbiAgICAvLyBhcHBlYXJzIGFzIGFuIGVtcHR5IHN0cmluZyAnJy4gV2UgbmVlZCB0byBmb3JjZSBpdCB0byBldmFsdWF0ZSBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBhcyB1bmRlZmluZWRcbiAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvbnNCb3VuZGFyeTogc3RyaW5nIHwgdW5kZWZpbmVkID0gY3VycmVudC5wYXJhbWV0ZXJzLklucHV0UGVybWlzc2lvbnNCb3VuZGFyeSB8fCB1bmRlZmluZWQ7XG4gICAgY29uc3QgaW5wdXRQb2xpY3lOYW1lID0gcGFyYW1zLmV4YW1wbGVQZXJtaXNzaW9uc0JvdW5kYXJ5XG4gICAgICA/IENES19CT09UU1RSQVBfUEVSTUlTU0lPTlNfQk9VTkRBUllcbiAgICAgIDogcGFyYW1zLmN1c3RvbVBlcm1pc3Npb25zQm91bmRhcnk7XG4gICAgbGV0IHBvbGljeU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5wdXRQb2xpY3lOYW1lKSB7XG4gICAgICAvLyBJZiB0aGUgZXhhbXBsZSBwb2xpY3kgaXMgbm90IGFscmVhZHkgaW4gcGxhY2UsIGl0IG11c3QgYmUgY3JlYXRlZC5cbiAgICAgIGNvbnN0IHNkayA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnZpcm9ubWVudCwgTW9kZS5Gb3JXcml0aW5nKSkuc2RrO1xuICAgICAgcG9saWN5TmFtZSA9IGF3YWl0IHRoaXMuZ2V0UG9saWN5TmFtZShlbnZpcm9ubWVudCwgc2RrLCBpbnB1dFBvbGljeU5hbWUsIHBhcnRpdGlvbiwgcGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5ICE9PSBwb2xpY3lOYW1lKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KHdhcm4oXG4gICAgICAgICAgYEFkZGluZyBuZXcgcGVybWlzc2lvbnMgYm91bmRhcnkgJHtwb2xpY3lOYW1lfWAsXG4gICAgICAgICkpO1xuICAgICAgfSBlbHNlIGlmICghcG9saWN5TmFtZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeSh3YXJuKFxuICAgICAgICAgIGBSZW1vdmluZyBleGlzdGluZyBwZXJtaXNzaW9ucyBib3VuZGFyeSAke2N1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5fWAsXG4gICAgICAgICkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkod2FybihcbiAgICAgICAgICBgQ2hhbmdpbmcgcGVybWlzc2lvbnMgYm91bmRhcnkgZnJvbSAke2N1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5fSB0byAke3BvbGljeU5hbWV9YCxcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQudXBkYXRlKFxuICAgICAgYm9vdHN0cmFwVGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIEZpbGVBc3NldHNCdWNrZXROYW1lOiBwYXJhbXMuYnVja2V0TmFtZSxcbiAgICAgICAgRmlsZUFzc2V0c0J1Y2tldEttc0tleUlkOiBrbXNLZXlJZCxcbiAgICAgICAgLy8gRW1wdHkgYXJyYXkgYmVjb21lcyBlbXB0eSBzdHJpbmdcbiAgICAgICAgVHJ1c3RlZEFjY291bnRzOiB0cnVzdGVkQWNjb3VudHMuam9pbignLCcpLFxuICAgICAgICBUcnVzdGVkQWNjb3VudHNGb3JMb29rdXA6IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5qb2luKCcsJyksXG4gICAgICAgIENsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXM6IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMuam9pbignLCcpLFxuICAgICAgICBRdWFsaWZpZXI6IHBhcmFtcy5xdWFsaWZpZXIsXG4gICAgICAgIFB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbjpcbiAgICAgICAgICBwYXJhbXMucHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uIHx8IHBhcmFtcy5wdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICAgIDogJ2ZhbHNlJyxcbiAgICAgICAgSW5wdXRQZXJtaXNzaW9uc0JvdW5kYXJ5OiBwb2xpY3lOYW1lLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdGVybWluYXRpb25Qcm90ZWN0aW9uOiBvcHRpb25zLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBjdXJyZW50LnRlcm1pbmF0aW9uUHJvdGVjdGlvbixcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0UG9saWN5TmFtZShcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrOiBTREssXG4gICAgcGVybWlzc2lvbnNCb3VuZGFyeTogc3RyaW5nLFxuICAgIHBhcnRpdGlvbjogc3RyaW5nLFxuICAgIHBhcmFtczogQm9vdHN0cmFwcGluZ1BhcmFtZXRlcnMsXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKHBlcm1pc3Npb25zQm91bmRhcnkgIT09IENES19CT09UU1RSQVBfUEVSTUlTU0lPTlNfQk9VTkRBUlkpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVQb2xpY3lOYW1lKHBlcm1pc3Npb25zQm91bmRhcnkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICB9XG4gICAgLy8gaWYgbm8gUXVhbGlmaWVyIGlzIHN1cHBsaWVkLCByZXNvcnQgdG8gdGhlIGRlZmF1bHQgb25lXG4gICAgY29uc3QgYXJuID0gYXdhaXQgdGhpcy5nZXRFeGFtcGxlUGVybWlzc2lvbnNCb3VuZGFyeShcbiAgICAgIHBhcmFtcy5xdWFsaWZpZXIgPz8gJ2huYjY1OWZkcycsXG4gICAgICBwYXJ0aXRpb24sXG4gICAgICBlbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgc2RrLFxuICAgICk7XG4gICAgY29uc3QgcG9saWN5TmFtZSA9IGFybi5zcGxpdCgnLycpLnBvcCgpO1xuICAgIGlmICghcG9saWN5TmFtZSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQ291bGQgbm90IHJldHJpZXZlIHRoZSBleGFtcGxlIHBlcm1pc3Npb24gYm91bmRhcnkhJyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocG9saWN5TmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldEV4YW1wbGVQZXJtaXNzaW9uc0JvdW5kYXJ5KFxuICAgIHF1YWxpZmllcjogc3RyaW5nLFxuICAgIHBhcnRpdGlvbjogc3RyaW5nLFxuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICBzZGs6IFNESyxcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBpYW0gPSBzZGsuaWFtKCk7XG5cbiAgICBsZXQgcG9saWN5TmFtZSA9IGBjZGstJHtxdWFsaWZpZXJ9LXBlcm1pc3Npb25zLWJvdW5kYXJ5YDtcbiAgICBjb25zdCBhcm4gPSBgYXJuOiR7cGFydGl0aW9ufTppYW06OiR7YWNjb3VudH06cG9saWN5LyR7cG9saWN5TmFtZX1gO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBnZXRQb2xpY3lSZXNwID0gYXdhaXQgaWFtLmdldFBvbGljeSh7IFBvbGljeUFybjogYXJuIH0pO1xuICAgICAgaWYgKGdldFBvbGljeVJlc3AuUG9saWN5KSB7XG4gICAgICAgIHJldHVybiBhcm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vSUFNL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0dldFBvbGljeS5odG1sI0FQSV9HZXRQb2xpY3lfRXJyb3JzXG4gICAgICBpZiAoZS5uYW1lID09PSAnTm9TdWNoRW50aXR5Jykge1xuICAgICAgICAvLyBub29wLCBwcm9jZWVkIHdpdGggY3JlYXRpbmcgdGhlIHBvbGljeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwb2xpY3lEb2MgPSB7XG4gICAgICBWZXJzaW9uOiAnMjAxMi0xMC0xNycsXG4gICAgICBTdGF0ZW1lbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIEFjdGlvbjogWycqJ10sXG4gICAgICAgICAgUmVzb3VyY2U6ICcqJyxcbiAgICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICAgICAgU2lkOiAnRXhwbGljaXRBbGxvd0FsbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBDb25kaXRpb246IHtcbiAgICAgICAgICAgIFN0cmluZ0VxdWFsczoge1xuICAgICAgICAgICAgICAnaWFtOlBlcm1pc3Npb25zQm91bmRhcnknOiBgYXJuOiR7cGFydGl0aW9ufTppYW06OiR7YWNjb3VudH06cG9saWN5L2Nkay0ke3F1YWxpZmllcn0tcGVybWlzc2lvbnMtYm91bmRhcnlgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEFjdGlvbjogW1xuICAgICAgICAgICAgJ2lhbTpDcmVhdGVVc2VyJyxcbiAgICAgICAgICAgICdpYW06Q3JlYXRlUm9sZScsXG4gICAgICAgICAgICAnaWFtOlB1dFJvbGVQZXJtaXNzaW9uc0JvdW5kYXJ5JyxcbiAgICAgICAgICAgICdpYW06UHV0VXNlclBlcm1pc3Npb25zQm91bmRhcnknLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgUmVzb3VyY2U6ICcqJyxcbiAgICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICAgICAgU2lkOiAnRGVueUFjY2Vzc0lmUmVxdWlyZWRQZXJtQm91bmRhcnlJc05vdEJlaW5nQXBwbGllZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBBY3Rpb246IFtcbiAgICAgICAgICAgICdpYW06Q3JlYXRlUG9saWN5VmVyc2lvbicsXG4gICAgICAgICAgICAnaWFtOkRlbGV0ZVBvbGljeScsXG4gICAgICAgICAgICAnaWFtOkRlbGV0ZVBvbGljeVZlcnNpb24nLFxuICAgICAgICAgICAgJ2lhbTpTZXREZWZhdWx0UG9saWN5VmVyc2lvbicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBSZXNvdXJjZTogYGFybjoke3BhcnRpdGlvbn06aWFtOjoke2FjY291bnR9OnBvbGljeS9jZGstJHtxdWFsaWZpZXJ9LXBlcm1pc3Npb25zLWJvdW5kYXJ5YCxcbiAgICAgICAgICBFZmZlY3Q6ICdEZW55JyxcbiAgICAgICAgICBTaWQ6ICdEZW55UGVybUJvdW5kYXJ5SUFNUG9saWN5QWx0ZXJhdGlvbicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBBY3Rpb246IFsnaWFtOkRlbGV0ZVVzZXJQZXJtaXNzaW9uc0JvdW5kYXJ5JywgJ2lhbTpEZWxldGVSb2xlUGVybWlzc2lvbnNCb3VuZGFyeSddLFxuICAgICAgICAgIFJlc291cmNlOiAnKicsXG4gICAgICAgICAgRWZmZWN0OiAnRGVueScsXG4gICAgICAgICAgU2lkOiAnRGVueVJlbW92YWxPZlBlcm1Cb3VuZGFyeUZyb21BbnlVc2VyT3JSb2xlJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgUG9saWN5TmFtZTogcG9saWN5TmFtZSxcbiAgICAgIFBvbGljeURvY3VtZW50OiBKU09OLnN0cmluZ2lmeShwb2xpY3lEb2MpLFxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlUG9saWN5UmVzcG9uc2UgPSBhd2FpdCBpYW0uY3JlYXRlUG9saWN5KHJlcXVlc3QpO1xuICAgIGlmIChjcmVhdGVQb2xpY3lSZXNwb25zZS5Qb2xpY3k/LkFybikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvbGljeVJlc3BvbnNlLlBvbGljeS5Bcm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSB0aGUgZXhhbXBsZSBwZXJtaXNzaW9uIGJvdW5kYXJ5ICR7YXJufSFgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlUG9saWN5TmFtZShwZXJtaXNzaW9uc0JvdW5kYXJ5OiBzdHJpbmcpIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vSUFNL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0NyZWF0ZVBvbGljeS5odG1sXG4gICAgLy8gQWRkZWQgc3VwcG9ydCBmb3IgcG9saWN5IG5hbWVzIHdpdGggYSBwYXRoXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvMjYzMjBcbiAgICBjb25zdCByZWdleHA6IFJlZ0V4cCA9IC9bXFx3K1xcLz0sLkAtXSsvO1xuICAgIGNvbnN0IG1hdGNoZXMgPSByZWdleHAuZXhlYyhwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICBpZiAoIShtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSAxICYmIG1hdGNoZXNbMF0gPT09IHBlcm1pc3Npb25zQm91bmRhcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGUgcGVybWlzc2lvbnMgYm91bmRhcnkgbmFtZSAke3Blcm1pc3Npb25zQm91bmRhcnl9IGRvZXMgbm90IG1hdGNoIHRoZSBJQU0gY29udmVudGlvbnMuYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjdXN0b21Cb290c3RyYXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICAvLyBMb29rIGF0IHRoZSB0ZW1wbGF0ZSwgZGVjaWRlIHdoZXRoZXIgaXQncyBtb3N0IGxpa2VseSBhIGxlZ2FjeSBvciBtb2Rlcm4gYm9vdHN0cmFwXG4gICAgLy8gdGVtcGxhdGUsIGFuZCB1c2UgdGhlIHJpZ2h0IGJvb3RzdHJhcHBlciBmb3IgdGhhdC5cbiAgICBjb25zdCB2ZXJzaW9uID0gYm9vdHN0cmFwVmVyc2lvbkZyb21UZW1wbGF0ZShhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZSgpKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVnYWN5Qm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVybkJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFRlbXBsYXRlKHBhcmFtczogQm9vdHN0cmFwcGluZ1BhcmFtZXRlcnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgc3dpdGNoICh0aGlzLnNvdXJjZS5zb3VyY2UpIHtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiBsb2FkU3RydWN0dXJlZEZpbGUodGhpcy5zb3VyY2UudGVtcGxhdGVGaWxlKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gbG9hZFN0cnVjdHVyZWRGaWxlKHBhdGguam9pbihidW5kbGVkUGFja2FnZVJvb3REaXIoX19kaXJuYW1lKSwgJ2xpYicsICdhcGknLCAnYm9vdHN0cmFwJywgJ2Jvb3RzdHJhcC10ZW1wbGF0ZS55YW1sJykpO1xuICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUJvb3RzdHJhcFRlbXBsYXRlKHBhcmFtcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFnaWMgcGFyYW1ldGVyIHZhbHVlIHRoYXQgd2lsbCBjYXVzZSB0aGUgYm9vdHN0cmFwLXRlbXBsYXRlLnltbCB0byBOT1QgY3JlYXRlIGEgQ01LIGJ1dCB1c2UgdGhlIGRlZmF1bHQga2V5XG4gKi9cbmNvbnN0IFVTRV9BV1NfTUFOQUdFRF9LRVkgPSAnQVdTX01BTkFHRURfS0VZJztcblxuLyoqXG4gKiBNYWdpYyBwYXJhbWV0ZXIgdmFsdWUgdGhhdCB3aWxsIGNhdXNlIHRoZSBib290c3RyYXAtdGVtcGxhdGUueW1sIHRvIGNyZWF0ZSBhIENNS1xuICovXG5jb25zdCBDUkVBVEVfTkVXX0tFWSA9ICcnO1xuLyoqXG4gKiBQYXJhbWV0ZXIgdmFsdWUgaW5kaWNhdGluZyB0aGUgdXNlIG9mIHRoZSBkZWZhdWx0LCBDREsgcHJvdmlkZWQgcGVybWlzc2lvbnMgYm91bmRhcnkgZm9yIGJvb3RzdHJhcC10ZW1wbGF0ZS55bWxcbiAqL1xuY29uc3QgQ0RLX0JPT1RTVFJBUF9QRVJNSVNTSU9OU19CT1VOREFSWSA9ICdDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZJztcblxuLyoqXG4gKiBTcGxpdCBhbiBhcnJheS1saWtlIENsb3VkRm9ybWF0aW9uIHBhcmFtZXRlciBvbiAsXG4gKlxuICogQW4gZW1wdHkgc3RyaW5nIGlzIHRoZSBlbXB0eSBhcnJheSAoaW5zdGVhZCBvZiBgWycnXWApLlxuICovXG5mdW5jdGlvbiBzcGxpdENmbkFycmF5KHhzOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmdbXSB7XG4gIGlmICh4cyA9PT0gJycgfHwgeHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4geHMuc3BsaXQoJywnKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uPEE+KHhzOiBTZXQ8QT4sIHlzOiBTZXQ8QT4pOiBTZXQ8QT4ge1xuICByZXR1cm4gbmV3IFNldDxBPihBcnJheS5mcm9tKHhzKS5maWx0ZXIoeCA9PiB5cy5oYXMoeCkpKTtcbn1cbiJdfQ==