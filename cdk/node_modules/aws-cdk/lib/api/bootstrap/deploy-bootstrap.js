"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BootstrapStack = void 0;
exports.bootstrapVersionFromTemplate = bootstrapVersionFromTemplate;
exports.bootstrapVariantFromTemplate = bootstrapVariantFromTemplate;
const os = require("os");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const cx_api_1 = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const bootstrap_props_1 = require("./bootstrap-props");
const messages_1 = require("../../cli/messages");
const deployments_1 = require("../deployments");
const deploy_stack_1 = require("../deployments/deploy-stack");
const environment_1 = require("../environment");
const mode_1 = require("../plugin/mode");
const toolkit_info_1 = require("../toolkit-info");
/**
 * A class to hold state around stack bootstrapping
 *
 * This class exists so we can break bootstrapping into 2 phases:
 *
 * ```ts
 * const current = BootstrapStack.lookup(...);
 * // ...
 * current.update(newTemplate, ...);
 * ```
 *
 * And do something in between the two phases (such as look at the
 * current bootstrap stack and doing something intelligent).
 */
class BootstrapStack {
    static async lookup(sdkProvider, environment, toolkitStackName, ioHelper) {
        toolkitStackName = toolkitStackName !== null && toolkitStackName !== void 0 ? toolkitStackName : toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const resolvedEnvironment = await sdkProvider.resolveEnvironment(environment);
        const sdk = (await sdkProvider.forEnvironment(resolvedEnvironment, mode_1.Mode.ForWriting)).sdk;
        const currentToolkitInfo = await toolkit_info_1.ToolkitInfo.lookup(resolvedEnvironment, sdk, ioHelper, toolkitStackName);
        return new BootstrapStack(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo, ioHelper);
    }
    constructor(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo, ioHelper) {
        this.sdkProvider = sdkProvider;
        this.sdk = sdk;
        this.resolvedEnvironment = resolvedEnvironment;
        this.toolkitStackName = toolkitStackName;
        this.currentToolkitInfo = currentToolkitInfo;
        this.ioHelper = ioHelper;
    }
    get parameters() {
        return this.currentToolkitInfo.found ? this.currentToolkitInfo.bootstrapStack.parameters : {};
    }
    get terminationProtection() {
        return this.currentToolkitInfo.found ? this.currentToolkitInfo.bootstrapStack.terminationProtection : undefined;
    }
    async partition() {
        return (await this.sdk.currentAccount()).partition;
    }
    /**
     * Perform the actual deployment of a bootstrap stack, given a template and some parameters
     */
    async update(template, parameters, options) {
        var _a, _b;
        if (this.currentToolkitInfo.found && !options.force) {
            // Safety checks
            const abortResponse = {
                type: 'did-deploy-stack',
                noOp: true,
                outputs: {},
                stackArn: this.currentToolkitInfo.bootstrapStack.stackId,
            };
            // Validate that the bootstrap stack we're trying to replace is from the same variant as the one we're trying to deploy
            const currentVariant = this.currentToolkitInfo.variant;
            const newVariant = bootstrapVariantFromTemplate(template);
            if (currentVariant !== newVariant) {
                await this.ioHelper.notify((0, messages_1.warn)(`Bootstrap stack already exists, containing '${currentVariant}'. Not overwriting it with a template containing '${newVariant}' (use --force if you intend to overwrite)`));
                return abortResponse;
            }
            // Validate that we're not downgrading the bootstrap stack
            const newVersion = bootstrapVersionFromTemplate(template);
            const currentVersion = this.currentToolkitInfo.version;
            if (newVersion < currentVersion) {
                await this.ioHelper.notify((0, messages_1.warn)(`Bootstrap stack already at version ${currentVersion}. Not downgrading it to version ${newVersion} (use --force if you intend to downgrade)`));
                if (newVersion === 0) {
                    // A downgrade with 0 as target version means we probably have a new-style bootstrap in the account,
                    // and an old-style bootstrap as current target, which means the user probably forgot to put this flag in.
                    await this.ioHelper.notify((0, messages_1.warn)("(Did you set the '@aws-cdk/core:newStyleStackSynthesis' feature flag in cdk.json?)"));
                }
                return abortResponse;
            }
        }
        const outdir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk-bootstrap'));
        const builder = new cx_api_1.CloudAssemblyBuilder(outdir);
        const templateFile = `${this.toolkitStackName}.template.json`;
        await fs.writeJson(path.join(builder.outdir, templateFile), template, {
            spaces: 2,
        });
        builder.addArtifact(this.toolkitStackName, {
            type: cloud_assembly_schema_1.ArtifactType.AWS_CLOUDFORMATION_STACK,
            environment: cx_api_1.EnvironmentUtils.format(this.resolvedEnvironment.account, this.resolvedEnvironment.region),
            properties: {
                templateFile,
                terminationProtection: (_a = options.terminationProtection) !== null && _a !== void 0 ? _a : false,
            },
        });
        const assembly = builder.buildAssembly();
        const ret = await (0, deploy_stack_1.deployStack)({
            stack: assembly.getStackByName(this.toolkitStackName),
            resolvedEnvironment: this.resolvedEnvironment,
            sdk: this.sdk,
            sdkProvider: this.sdkProvider,
            force: options.force,
            roleArn: options.roleArn,
            tags: options.tags,
            deploymentMethod: { method: 'change-set', execute: options.execute },
            parameters,
            usePreviousParameters: (_b = options.usePreviousParameters) !== null && _b !== void 0 ? _b : true,
            // Obviously we can't need a bootstrap stack to deploy a bootstrap stack
            envResources: new environment_1.NoBootstrapStackEnvironmentResources(this.resolvedEnvironment, this.sdk, this.ioHelper),
        }, this.ioHelper);
        (0, deployments_1.assertIsSuccessfulDeployStackResult)(ret);
        return ret;
    }
}
exports.BootstrapStack = BootstrapStack;
function bootstrapVersionFromTemplate(template) {
    var _a, _b, _c, _d, _e;
    const versionSources = [
        (_b = (_a = template.Outputs) === null || _a === void 0 ? void 0 : _a[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT]) === null || _b === void 0 ? void 0 : _b.Value,
        (_e = (_d = (_c = template.Resources) === null || _c === void 0 ? void 0 : _c[bootstrap_props_1.BOOTSTRAP_VERSION_RESOURCE]) === null || _d === void 0 ? void 0 : _d.Properties) === null || _e === void 0 ? void 0 : _e.Value,
    ];
    for (const vs of versionSources) {
        if (typeof vs === 'number') {
            return vs;
        }
        if (typeof vs === 'string' && !isNaN(parseInt(vs, 10))) {
            return parseInt(vs, 10);
        }
    }
    return 0;
}
function bootstrapVariantFromTemplate(template) {
    var _a, _b, _c;
    return (_c = (_b = (_a = template.Parameters) === null || _a === void 0 ? void 0 : _a[bootstrap_props_1.BOOTSTRAP_VARIANT_PARAMETER]) === null || _b === void 0 ? void 0 : _b.Default) !== null && _c !== void 0 ? _c : bootstrap_props_1.DEFAULT_BOOTSTRAP_VARIANT;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95LWJvb3RzdHJhcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlcGxveS1ib290c3RyYXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBMkpBLG9FQWVDO0FBRUQsb0VBRUM7QUE5S0QseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwwRUFBOEQ7QUFFOUQsNENBQXlFO0FBQ3pFLCtCQUErQjtBQUUvQix1REFLMkI7QUFFM0IsaURBQTBDO0FBRzFDLGdEQUFxRTtBQUNyRSw4REFBMEQ7QUFDMUQsZ0RBQXNFO0FBQ3RFLHlDQUFzQztBQUN0QyxrREFBMEU7QUFFMUU7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNILE1BQWEsY0FBYztJQUNsQixNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUF3QixFQUFFLFdBQXdCLEVBQUUsZ0JBQXdCLEVBQUUsUUFBa0I7UUFDekgsZ0JBQWdCLEdBQUcsZ0JBQWdCLGFBQWhCLGdCQUFnQixjQUFoQixnQkFBZ0IsR0FBSSx5Q0FBMEIsQ0FBQztRQUVsRSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sV0FBVyxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlFLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxXQUFXLENBQUMsY0FBYyxDQUFDLG1CQUFtQixFQUFFLFdBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUV6RixNQUFNLGtCQUFrQixHQUFHLE1BQU0sMEJBQVcsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTFHLE9BQU8sSUFBSSxjQUFjLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBRSxtQkFBbUIsRUFBRSxnQkFBZ0IsRUFBRSxrQkFBa0IsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNuSCxDQUFDO0lBRUQsWUFDbUIsV0FBd0IsRUFDeEIsR0FBUSxFQUNSLG1CQUFnQyxFQUNoQyxn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QUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IEFydGlmYWN0VHlwZSB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgdHlwZSB7IEVudmlyb25tZW50IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkQXNzZW1ibHlCdWlsZGVyLCBFbnZpcm9ubWVudFV0aWxzIH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB0eXBlIHsgQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zIH0gZnJvbSAnLi9ib290c3RyYXAtcHJvcHMnO1xuaW1wb3J0IHtcbiAgQk9PVFNUUkFQX1ZBUklBTlRfUEFSQU1FVEVSLFxuICBCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVQsXG4gIEJPT1RTVFJBUF9WRVJTSU9OX1JFU09VUkNFLFxuICBERUZBVUxUX0JPT1RTVFJBUF9WQVJJQU5ULFxufSBmcm9tICcuL2Jvb3RzdHJhcC1wcm9wcyc7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uL2NsaS9tZXNzYWdlcyc7XG5pbXBvcnQgdHlwZSB7IFNESywgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgdHlwZSB7IFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL2RlcGxveW1lbnRzJztcbmltcG9ydCB7IGFzc2VydElzU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi4vZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgZGVwbG95U3RhY2sgfSBmcm9tICcuLi9kZXBsb3ltZW50cy9kZXBsb3ktc3RhY2snO1xuaW1wb3J0IHsgTm9Cb290c3RyYXBTdGFja0Vudmlyb25tZW50UmVzb3VyY2VzIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4uL3BsdWdpbi9tb2RlJztcbmltcG9ydCB7IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FLCBUb29sa2l0SW5mbyB9IGZyb20gJy4uL3Rvb2xraXQtaW5mbyc7XG5cbi8qKlxuICogQSBjbGFzcyB0byBob2xkIHN0YXRlIGFyb3VuZCBzdGFjayBib290c3RyYXBwaW5nXG4gKlxuICogVGhpcyBjbGFzcyBleGlzdHMgc28gd2UgY2FuIGJyZWFrIGJvb3RzdHJhcHBpbmcgaW50byAyIHBoYXNlczpcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgY3VycmVudCA9IEJvb3RzdHJhcFN0YWNrLmxvb2t1cCguLi4pO1xuICogLy8gLi4uXG4gKiBjdXJyZW50LnVwZGF0ZShuZXdUZW1wbGF0ZSwgLi4uKTtcbiAqIGBgYFxuICpcbiAqIEFuZCBkbyBzb21ldGhpbmcgaW4gYmV0d2VlbiB0aGUgdHdvIHBoYXNlcyAoc3VjaCBhcyBsb29rIGF0IHRoZVxuICogY3VycmVudCBib290c3RyYXAgc3RhY2sgYW5kIGRvaW5nIHNvbWV0aGluZyBpbnRlbGxpZ2VudCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBTdGFjayB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50LCB0b29sa2l0U3RhY2tOYW1lOiBzdHJpbmcsIGlvSGVscGVyOiBJb0hlbHBlcikge1xuICAgIHRvb2xraXRTdGFja05hbWUgPSB0b29sa2l0U3RhY2tOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuXG4gICAgY29uc3QgcmVzb2x2ZWRFbnZpcm9ubWVudCA9IGF3YWl0IHNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChlbnZpcm9ubWVudCk7XG4gICAgY29uc3Qgc2RrID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KHJlc29sdmVkRW52aXJvbm1lbnQsIE1vZGUuRm9yV3JpdGluZykpLnNkaztcblxuICAgIGNvbnN0IGN1cnJlbnRUb29sa2l0SW5mbyA9IGF3YWl0IFRvb2xraXRJbmZvLmxvb2t1cChyZXNvbHZlZEVudmlyb25tZW50LCBzZGssIGlvSGVscGVyLCB0b29sa2l0U3RhY2tOYW1lKTtcblxuICAgIHJldHVybiBuZXcgQm9vdHN0cmFwU3RhY2soc2RrUHJvdmlkZXIsIHNkaywgcmVzb2x2ZWRFbnZpcm9ubWVudCwgdG9vbGtpdFN0YWNrTmFtZSwgY3VycmVudFRvb2xraXRJbmZvLCBpb0hlbHBlcik7XG4gIH1cblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZGs6IFNESyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlc29sdmVkRW52aXJvbm1lbnQ6IEVudmlyb25tZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VycmVudFRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlvSGVscGVyOiBJb0hlbHBlcixcbiAgKSB7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRvb2xraXRJbmZvLmZvdW5kID8gdGhpcy5jdXJyZW50VG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2sucGFyYW1ldGVycyA6IHt9O1xuICB9XG5cbiAgcHVibGljIGdldCB0ZXJtaW5hdGlvblByb3RlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRvb2xraXRJbmZvLmZvdW5kID8gdGhpcy5jdXJyZW50VG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHBhcnRpdGlvbigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5zZGsuY3VycmVudEFjY291bnQoKSkucGFydGl0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBkZXBsb3ltZW50IG9mIGEgYm9vdHN0cmFwIHN0YWNrLCBnaXZlbiBhIHRlbXBsYXRlIGFuZCBzb21lIHBhcmFtZXRlcnNcbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGRhdGUoXG4gICAgdGVtcGxhdGU6IGFueSxcbiAgICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+LFxuICAgIG9wdGlvbnM6IE9taXQ8Qm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zLCAncGFyYW1ldGVycyc+LFxuICApOiBQcm9taXNlPFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUb29sa2l0SW5mby5mb3VuZCAmJiAhb3B0aW9ucy5mb3JjZSkge1xuICAgICAgLy8gU2FmZXR5IGNoZWNrc1xuICAgICAgY29uc3QgYWJvcnRSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogJ2RpZC1kZXBsb3ktc3RhY2snLFxuICAgICAgICBub09wOiB0cnVlLFxuICAgICAgICBvdXRwdXRzOiB7fSxcbiAgICAgICAgc3RhY2tBcm46IHRoaXMuY3VycmVudFRvb2xraXRJbmZvLmJvb3RzdHJhcFN0YWNrLnN0YWNrSWQsXG4gICAgICB9IHNhdGlzZmllcyBTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ7XG5cbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIGJvb3RzdHJhcCBzdGFjayB3ZSdyZSB0cnlpbmcgdG8gcmVwbGFjZSBpcyBmcm9tIHRoZSBzYW1lIHZhcmlhbnQgYXMgdGhlIG9uZSB3ZSdyZSB0cnlpbmcgdG8gZGVwbG95XG4gICAgICBjb25zdCBjdXJyZW50VmFyaWFudCA9IHRoaXMuY3VycmVudFRvb2xraXRJbmZvLnZhcmlhbnQ7XG4gICAgICBjb25zdCBuZXdWYXJpYW50ID0gYm9vdHN0cmFwVmFyaWFudEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBpZiAoY3VycmVudFZhcmlhbnQgIT09IG5ld1ZhcmlhbnQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkod2FybihcbiAgICAgICAgICBgQm9vdHN0cmFwIHN0YWNrIGFscmVhZHkgZXhpc3RzLCBjb250YWluaW5nICcke2N1cnJlbnRWYXJpYW50fScuIE5vdCBvdmVyd3JpdGluZyBpdCB3aXRoIGEgdGVtcGxhdGUgY29udGFpbmluZyAnJHtuZXdWYXJpYW50fScgKHVzZSAtLWZvcmNlIGlmIHlvdSBpbnRlbmQgdG8gb3ZlcndyaXRlKWAsXG4gICAgICAgICkpO1xuICAgICAgICByZXR1cm4gYWJvcnRSZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB3ZSdyZSBub3QgZG93bmdyYWRpbmcgdGhlIGJvb3RzdHJhcCBzdGFja1xuICAgICAgY29uc3QgbmV3VmVyc2lvbiA9IGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSB0aGlzLmN1cnJlbnRUb29sa2l0SW5mby52ZXJzaW9uO1xuICAgICAgaWYgKG5ld1ZlcnNpb24gPCBjdXJyZW50VmVyc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeSh3YXJuKFxuICAgICAgICAgIGBCb290c3RyYXAgc3RhY2sgYWxyZWFkeSBhdCB2ZXJzaW9uICR7Y3VycmVudFZlcnNpb259LiBOb3QgZG93bmdyYWRpbmcgaXQgdG8gdmVyc2lvbiAke25ld1ZlcnNpb259ICh1c2UgLS1mb3JjZSBpZiB5b3UgaW50ZW5kIHRvIGRvd25ncmFkZSlgLFxuICAgICAgICApKTtcbiAgICAgICAgaWYgKG5ld1ZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAvLyBBIGRvd25ncmFkZSB3aXRoIDAgYXMgdGFyZ2V0IHZlcnNpb24gbWVhbnMgd2UgcHJvYmFibHkgaGF2ZSBhIG5ldy1zdHlsZSBib290c3RyYXAgaW4gdGhlIGFjY291bnQsXG4gICAgICAgICAgLy8gYW5kIGFuIG9sZC1zdHlsZSBib290c3RyYXAgYXMgY3VycmVudCB0YXJnZXQsIHdoaWNoIG1lYW5zIHRoZSB1c2VyIHByb2JhYmx5IGZvcmdvdCB0byBwdXQgdGhpcyBmbGFnIGluLlxuICAgICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KHdhcm4oXG4gICAgICAgICAgICBcIihEaWQgeW91IHNldCB0aGUgJ0Bhd3MtY2RrL2NvcmU6bmV3U3R5bGVTdGFja1N5bnRoZXNpcycgZmVhdHVyZSBmbGFnIGluIGNkay5qc29uPylcIixcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWJvcnRSZXNwb25zZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvdXRkaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1ib290c3RyYXAnKSk7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBDbG91ZEFzc2VtYmx5QnVpbGRlcihvdXRkaXIpO1xuICAgIGNvbnN0IHRlbXBsYXRlRmlsZSA9IGAke3RoaXMudG9vbGtpdFN0YWNrTmFtZX0udGVtcGxhdGUuanNvbmA7XG4gICAgYXdhaXQgZnMud3JpdGVKc29uKHBhdGguam9pbihidWlsZGVyLm91dGRpciwgdGVtcGxhdGVGaWxlKSwgdGVtcGxhdGUsIHtcbiAgICAgIHNwYWNlczogMixcbiAgICB9KTtcblxuICAgIGJ1aWxkZXIuYWRkQXJ0aWZhY3QodGhpcy50b29sa2l0U3RhY2tOYW1lLCB7XG4gICAgICB0eXBlOiBBcnRpZmFjdFR5cGUuQVdTX0NMT1VERk9STUFUSU9OX1NUQUNLLFxuICAgICAgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50VXRpbHMuZm9ybWF0KHRoaXMucmVzb2x2ZWRFbnZpcm9ubWVudC5hY2NvdW50LCB0aGlzLnJlc29sdmVkRW52aXJvbm1lbnQucmVnaW9uKSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdGVtcGxhdGVGaWxlLFxuICAgICAgICB0ZXJtaW5hdGlvblByb3RlY3Rpb246IG9wdGlvbnMudGVybWluYXRpb25Qcm90ZWN0aW9uID8/IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGFzc2VtYmx5ID0gYnVpbGRlci5idWlsZEFzc2VtYmx5KCk7XG5cbiAgICBjb25zdCByZXQgPSBhd2FpdCBkZXBsb3lTdGFjayh7XG4gICAgICBzdGFjazogYXNzZW1ibHkuZ2V0U3RhY2tCeU5hbWUodGhpcy50b29sa2l0U3RhY2tOYW1lKSxcbiAgICAgIHJlc29sdmVkRW52aXJvbm1lbnQ6IHRoaXMucmVzb2x2ZWRFbnZpcm9ubWVudCxcbiAgICAgIHNkazogdGhpcy5zZGssXG4gICAgICBzZGtQcm92aWRlcjogdGhpcy5zZGtQcm92aWRlcixcbiAgICAgIGZvcmNlOiBvcHRpb25zLmZvcmNlLFxuICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgdGFnczogb3B0aW9ucy50YWdzLFxuICAgICAgZGVwbG95bWVudE1ldGhvZDogeyBtZXRob2Q6ICdjaGFuZ2Utc2V0JywgZXhlY3V0ZTogb3B0aW9ucy5leGVjdXRlIH0sXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBvcHRpb25zLnVzZVByZXZpb3VzUGFyYW1ldGVycyA/PyB0cnVlLFxuICAgICAgLy8gT2J2aW91c2x5IHdlIGNhbid0IG5lZWQgYSBib290c3RyYXAgc3RhY2sgdG8gZGVwbG95IGEgYm9vdHN0cmFwIHN0YWNrXG4gICAgICBlbnZSZXNvdXJjZXM6IG5ldyBOb0Jvb3RzdHJhcFN0YWNrRW52aXJvbm1lbnRSZXNvdXJjZXModGhpcy5yZXNvbHZlZEVudmlyb25tZW50LCB0aGlzLnNkaywgdGhpcy5pb0hlbHBlciksXG4gICAgfSwgdGhpcy5pb0hlbHBlcik7XG5cbiAgICBhc3NlcnRJc1N1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdChyZXQpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vdHN0cmFwVmVyc2lvbkZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogYW55KTogbnVtYmVyIHtcbiAgY29uc3QgdmVyc2lvblNvdXJjZXMgPSBbXG4gICAgdGVtcGxhdGUuT3V0cHV0cz8uW0JPT1RTVFJBUF9WRVJTSU9OX09VVFBVVF0/LlZhbHVlLFxuICAgIHRlbXBsYXRlLlJlc291cmNlcz8uW0JPT1RTVFJBUF9WRVJTSU9OX1JFU09VUkNFXT8uUHJvcGVydGllcz8uVmFsdWUsXG4gIF07XG5cbiAgZm9yIChjb25zdCB2cyBvZiB2ZXJzaW9uU291cmNlcykge1xuICAgIGlmICh0eXBlb2YgdnMgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdnM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdnMgPT09ICdzdHJpbmcnICYmICFpc05hTihwYXJzZUludCh2cywgMTApKSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZzLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vdHN0cmFwVmFyaWFudEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIHRlbXBsYXRlLlBhcmFtZXRlcnM/LltCT09UU1RSQVBfVkFSSUFOVF9QQVJBTUVURVJdPy5EZWZhdWx0ID8/IERFRkFVTFRfQk9PVFNUUkFQX1ZBUklBTlQ7XG59XG4iXX0=