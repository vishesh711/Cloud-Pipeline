import type { PropertyDifference } from '@aws-cdk/cloudformation-diff';
import type { CloudFormationStackArtifact } from '@aws-cdk/cx-api';
import type { HotswappableChange, ResourceChange } from '../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/payloads/hotswap';
import type { SDK } from '../aws-auth';
export declare const ICON = "\u2728";
/**
 * The result of an attempted hotswap deployment
 */
export interface HotswapResult {
    /**
     * The stack that was hotswapped
     */
    readonly stack: CloudFormationStackArtifact;
    /**
     * Whether hotswapping happened or not.
     *
     * `false` indicates that the deployment could not be hotswapped and full deployment may be attempted as fallback.
     */
    readonly hotswapped: boolean;
    /**
     * The changes that were deemed hotswappable
     */
    readonly hotswappableChanges: any[];
    /**
     * The changes that were deemed not hotswappable
     */
    readonly nonHotswappableChanges: any[];
}
export interface HotswapOperation {
    /**
     * Marks the operation as hotswappable
     */
    readonly hotswappable: true;
    /**
     * The name of the service being hotswapped.
     * Used to set a custom User-Agent for SDK calls.
     */
    readonly service: string;
    /**
     * Description of the change that is applied as part of the operation
     */
    readonly change: HotswappableChange;
    /**
     * The names of the resources being hotswapped.
     */
    readonly resourceNames: string[];
    /**
     * Applies the hotswap operation
     */
    readonly apply: (sdk: SDK) => Promise<void>;
}
export interface NonHotswappableChange {
    readonly hotswappable: false;
    readonly resourceType: string;
    readonly rejectedChanges: Array<string>;
    readonly logicalId: string;
    /**
     * Tells the user exactly why this change was deemed non-hotswappable and what its logical ID is.
     * If not specified, `reason` will be autofilled to state that the properties listed in `rejectedChanges` are not hotswappable.
     */
    readonly reason?: string;
    /**
     * Whether or not to show this change when listing non-hotswappable changes in HOTSWAP_ONLY mode. Does not affect
     * listing in FALL_BACK mode.
     *
     * @default true
     */
    readonly hotswapOnlyVisible?: boolean;
}
export type ChangeHotswapResult = Array<HotswapOperation | NonHotswappableChange>;
export interface ClassifiedResourceChanges {
    hotswappableChanges: HotswapOperation[];
    nonHotswappableChanges: NonHotswappableChange[];
}
export declare enum HotswapMode {
    /**
     * Will fall back to CloudFormation when a non-hotswappable change is detected
     */
    FALL_BACK = "fall-back",
    /**
     * Will not fall back to CloudFormation when a non-hotswappable change is detected
     */
    HOTSWAP_ONLY = "hotswap-only",
    /**
     * Will not attempt to hotswap anything and instead go straight to CloudFormation
     */
    FULL_DEPLOYMENT = "full-deployment"
}
type Exclude = {
    [key: string]: Exclude | true;
};
/**
 * Represents configuration property overrides for hotswap deployments
 */
export declare class HotswapPropertyOverrides {
    ecsHotswapProperties?: EcsHotswapProperties;
    constructor(ecsHotswapProperties?: EcsHotswapProperties);
}
/**
 * Represents configuration properties for ECS hotswap deployments
 */
export declare class EcsHotswapProperties {
    readonly minimumHealthyPercent?: number;
    readonly maximumHealthyPercent?: number;
    constructor(minimumHealthyPercent?: number, maximumHealthyPercent?: number);
    /**
     * Check if any hotswap properties are defined
     * @returns true if all properties are undefined, false otherwise
     */
    isEmpty(): boolean;
}
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
export declare function transformObjectKeys(val: any, transform: (str: string) => string, exclude?: Exclude): any;
/**
 * This function lower cases the first character of the string provided.
 */
export declare function lowerCaseFirstCharacter(str: string): string;
type PropDiffs = Record<string, PropertyDifference<any>>;
export declare class ClassifiedChanges {
    readonly change: ResourceChange;
    readonly hotswappableProps: PropDiffs;
    readonly nonHotswappableProps: PropDiffs;
    constructor(change: ResourceChange, hotswappableProps: PropDiffs, nonHotswappableProps: PropDiffs);
    reportNonHotswappablePropertyChanges(ret: ChangeHotswapResult): void;
    get namesOfHotswappableProps(): string[];
}
export declare function classifyChanges(xs: ResourceChange, hotswappablePropNames: string[]): ClassifiedChanges;
export declare function reportNonHotswappableChange(ret: ChangeHotswapResult, change: ResourceChange, nonHotswappableProps?: PropDiffs, reason?: string, hotswapOnlyVisible?: boolean): void;
export declare function reportNonHotswappableResource(change: ResourceChange, reason?: string): ChangeHotswapResult;
export {};
