"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
const common_1 = require("./common");
const ECS_SERVICE_RESOURCE_TYPE = 'AWS::ECS::Service';
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate, hotswapPropertyOverrides) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['ContainerDefinitions']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter((r) => r.Type === ECS_SERVICE_RESOURCE_TYPE);
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        // if there are no resources referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'No ECS services reference the changed task definition', false);
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter((r) => r.Type !== ECS_SERVICE_RESOURCE_TYPE);
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`);
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const taskDefinitionResource = await prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change);
        ret.push({
            change: {
                cause: change,
            },
            hotswappable: true,
            service: 'ecs-service',
            resourceNames: [
                `ECS Task Definition '${await taskDefinitionResource.Family}'`,
                ...ecsServicesReferencingTaskDef.map((ecsService) => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`),
            ],
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                var _a;
                // The SDK requires more properties here than its worth doing explicit typing for
                // instead, just use all the old values in the diff to fill them in implicitly
                const lowercasedTaskDef = (0, common_1.transformObjectKeys)(taskDefinitionResource, common_1.lowerCaseFirstCharacter, {
                    // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
                    // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                });
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef);
                const taskDefRevArn = (_a = registerTaskDefResponse.taskDefinition) === null || _a === void 0 ? void 0 : _a.taskDefinitionArn;
                let ecsHotswapProperties = hotswapPropertyOverrides.ecsHotswapProperties;
                let minimumHealthyPercent = ecsHotswapProperties === null || ecsHotswapProperties === void 0 ? void 0 : ecsHotswapProperties.minimumHealthyPercent;
                let maximumHealthyPercent = ecsHotswapProperties === null || ecsHotswapProperties === void 0 ? void 0 : ecsHotswapProperties.maximumHealthyPercent;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(ecsServicesReferencingTaskDef.map(async (service) => {
                    var _a;
                    const cluster = service.serviceArn.split('/')[1];
                    const update = await sdk.ecs().updateService({
                        service: service.serviceArn,
                        taskDefinition: taskDefRevArn,
                        cluster,
                        forceNewDeployment: true,
                        deploymentConfiguration: {
                            minimumHealthyPercent: minimumHealthyPercent !== undefined ? minimumHealthyPercent : 0,
                            maximumPercent: maximumHealthyPercent !== undefined ? maximumHealthyPercent : undefined,
                        },
                    });
                    await sdk.ecs().waitUntilServicesStable({
                        cluster: (_a = update.service) === null || _a === void 0 ? void 0 : _a.clusterArn,
                        services: [service.serviceArn],
                    });
                }));
            },
        });
    }
    return ret;
}
async function prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change) {
    var _a;
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource === null || taskDefinitionResource === void 0 ? void 0 : taskDefinitionResource.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        ? // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
            // so, take the 6th element, at index 5, and split it on '/'
            familyNameOrArnParts[5].split('/')[1]
        : // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
            familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return {
        ...(await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource !== null && taskDefinitionResource !== void 0 ? taskDefinitionResource : {}),
            Family: undefined,
        })),
        Family: family,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBZUEsd0VBNkhDO0FBeElELHFDQUlrQjtBQUtsQixNQUFNLHlCQUF5QixHQUFHLG1CQUFtQixDQUFDO0FBRS9DLEtBQUssVUFBVSw4QkFBOEIsQ0FDbEQsU0FBaUIsRUFDakIsTUFBc0IsRUFDdEIsbUJBQW1ELEVBQ25ELHdCQUFrRDtJQUVsRCx5RUFBeUU7SUFDekUsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSywwQkFBMEIsRUFBRSxDQUFDO1FBQ3hELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELE1BQU0sR0FBRyxHQUF3QixFQUFFLENBQUM7SUFFcEMscUZBQXFGO0lBQ3JGLHFGQUFxRjtJQUNyRix1REFBdUQ7SUFDdkQsTUFBTSxpQkFBaUIsR0FBRyxJQUFBLHdCQUFlLEVBQUMsTUFBTSxFQUFFLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDO0lBQzVFLGlCQUFpQixDQUFDLG9DQUFvQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTVELHVFQUF1RTtJQUN2RSxNQUFNLDJCQUEyQixHQUFHLG1CQUFtQixDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0scUNBQXFDLEdBQUcsMkJBQTJCLENBQUMsTUFBTSxDQUM5RSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyx5QkFBeUIsQ0FDNUMsQ0FBQztJQUNGLE1BQU0sNkJBQTZCLEdBQUcsSUFBSSxLQUFLLEVBQWMsQ0FBQztJQUM5RCxLQUFLLE1BQU0sa0JBQWtCLElBQUkscUNBQXFDLEVBQUUsQ0FBQztRQUN2RSxNQUFNLFVBQVUsR0FBRyxNQUFNLG1CQUFtQixDQUFDLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQy9GLElBQUksVUFBVSxF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Q0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuICBDaGFuZ2VIb3Rzd2FwUmVzdWx0LFxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge1xuICBjbGFzc2lmeUNoYW5nZXMsIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyLFxuICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UsXG4gIHRyYW5zZm9ybU9iamVjdEtleXMsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB0eXBlIHsgUmVzb3VyY2VDaGFuZ2UgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcGF5bG9hZHMvaG90c3dhcCc7XG5pbXBvcnQgdHlwZSB7IFNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB0eXBlIHsgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIH0gZnJvbSAnLi4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuXG5jb25zdCBFQ1NfU0VSVklDRV9SRVNPVVJDRV9UWVBFID0gJ0FXUzo6RUNTOjpTZXJ2aWNlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsXG4gIGNoYW5nZTogUmVzb3VyY2VDaGFuZ2UsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzOiBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgLy8gdGhlIG9ubHkgcmVzb3VyY2UgY2hhbmdlIHdlIGNhbiBldmFsdWF0ZSBoZXJlIGlzIGFuIEVDUyBUYXNrRGVmaW5pdGlvblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdBV1M6OkVDUzo6VGFza0RlZmluaXRpb24nKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcmV0OiBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gW107XG5cbiAgLy8gV2Ugb25seSBhbGxvdyBhIGNoYW5nZSBpbiB0aGUgQ29udGFpbmVyRGVmaW5pdGlvbnMgb2YgdGhlIFRhc2tEZWZpbml0aW9uIGZvciBub3cgLVxuICAvLyBpdCBjb250YWlucyB0aGUgaW1hZ2UgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcywgc28gc2VlbXMgbGlrZSBhIHNhZmUgYmV0IGZvciBub3cuXG4gIC8vIFdlIG1pZ2h0IHJldmlzaXQgdGhpcyBkZWNpc2lvbiBpbiB0aGUgZnV0dXJlIHRob3VnaCFcbiAgY29uc3QgY2xhc3NpZmllZENoYW5nZXMgPSBjbGFzc2lmeUNoYW5nZXMoY2hhbmdlLCBbJ0NvbnRhaW5lckRlZmluaXRpb25zJ10pO1xuICBjbGFzc2lmaWVkQ2hhbmdlcy5yZXBvcnROb25Ib3Rzd2FwcGFibGVQcm9wZXJ0eUNoYW5nZXMocmV0KTtcblxuICAvLyBmaW5kIGFsbCBFQ1MgU2VydmljZXMgdGhhdCByZWZlcmVuY2UgdGhlIFRhc2tEZWZpbml0aW9uIHRoYXQgY2hhbmdlZFxuICBjb25zdCByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkKTtcbiAgY29uc3QgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5maWx0ZXIoXG4gICAgKHIpID0+IHIuVHlwZSA9PT0gRUNTX1NFUlZJQ0VfUkVTT1VSQ0VfVFlQRSxcbiAgKTtcbiAgY29uc3QgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBuZXcgQXJyYXk8RWNzU2VydmljZT4oKTtcbiAgZm9yIChjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2Ugb2YgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgIGNvbnN0IHNlcnZpY2VBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRQaHlzaWNhbE5hbWVGb3IoZWNzU2VydmljZVJlc291cmNlLkxvZ2ljYWxJZCk7XG4gICAgaWYgKHNlcnZpY2VBcm4pIHtcbiAgICAgIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLnB1c2goeyBzZXJ2aWNlQXJuIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHJlc291cmNlcyByZWZlcmVuY2luZyB0aGUgVGFza0RlZmluaXRpb24sXG4gICAgLy8gaG90c3dhcCBpcyBub3QgcG9zc2libGUgaW4gRkFMTF9CQUNLIG1vZGVcbiAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UocmV0LCBjaGFuZ2UsIHVuZGVmaW5lZCwgJ05vIEVDUyBzZXJ2aWNlcyByZWZlcmVuY2UgdGhlIGNoYW5nZWQgdGFzayBkZWZpbml0aW9uJywgZmFsc2UpO1xuICB9XG4gIGlmIChyZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID4gZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoKSB7XG4gICAgLy8gaWYgc29tZXRoaW5nIGJlc2lkZXMgYW4gRUNTIFNlcnZpY2UgaXMgcmVmZXJlbmNpbmcgdGhlIFRhc2tEZWZpbml0aW9uLFxuICAgIC8vIGhvdHN3YXAgaXMgbm90IHBvc3NpYmxlIGluIEZBTExfQkFDSyBtb2RlXG4gICAgY29uc3Qgbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcigocikgPT4gci5UeXBlICE9PSBFQ1NfU0VSVklDRV9SRVNPVVJDRV9UWVBFKTtcbiAgICBmb3IgKGNvbnN0IHRhc2tSZWYgb2Ygbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzKSB7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UoXG4gICAgICAgIHJldCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGBBIHJlc291cmNlICcke3Rhc2tSZWYuTG9naWNhbElkfScgd2l0aCBUeXBlICcke3Rhc2tSZWYuVHlwZX0nIHRoYXQgaXMgbm90IGFuIEVDUyBTZXJ2aWNlIHdhcyBmb3VuZCByZWZlcmVuY2luZyB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiAnJHtsb2dpY2FsSWR9J2AsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzID0gT2JqZWN0LmtleXMoY2xhc3NpZmllZENoYW5nZXMuaG90c3dhcHBhYmxlUHJvcHMpO1xuICBpZiAobmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2UgPSBhd2FpdCBwcmVwYXJlVGFza0RlZmluaXRpb25DaGFuZ2UoZXZhbHVhdGVDZm5UZW1wbGF0ZSwgbG9naWNhbElkLCBjaGFuZ2UpO1xuICAgIHJldC5wdXNoKHtcbiAgICAgIGNoYW5nZToge1xuICAgICAgICBjYXVzZTogY2hhbmdlLFxuICAgICAgfSxcbiAgICAgIGhvdHN3YXBwYWJsZTogdHJ1ZSxcbiAgICAgIHNlcnZpY2U6ICdlY3Mtc2VydmljZScsXG4gICAgICByZXNvdXJjZU5hbWVzOiBbXG4gICAgICAgIGBFQ1MgVGFzayBEZWZpbml0aW9uICcke2F3YWl0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2UuRmFtaWx5fSdgLFxuICAgICAgICAuLi5lY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5tYXAoKGVjc1NlcnZpY2UpID0+IGBFQ1MgU2VydmljZSAnJHtlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsyXX0nYCksXG4gICAgICBdLFxuICAgICAgYXBwbHk6IGFzeW5jIChzZGs6IFNESykgPT4ge1xuICAgICAgICAvLyBTdGVwIDEgLSB1cGRhdGUgdGhlIGNoYW5nZWQgVGFza0RlZmluaXRpb24sIGNyZWF0aW5nIGEgbmV3IFRhc2tEZWZpbml0aW9uIFJldmlzaW9uXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gbG93ZXJjYXNlIHRoZSBldmFsdWF0ZWQgVGFza0RlZiBmcm9tIENsb3VkRm9ybWF0aW9uLFxuICAgICAgICAvLyBhcyB0aGUgQVdTIFNESyB1c2VzIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyBmb3IgdGhlc2VcblxuICAgICAgICAvLyBUaGUgU0RLIHJlcXVpcmVzIG1vcmUgcHJvcGVydGllcyBoZXJlIHRoYW4gaXRzIHdvcnRoIGRvaW5nIGV4cGxpY2l0IHR5cGluZyBmb3JcbiAgICAgICAgLy8gaW5zdGVhZCwganVzdCB1c2UgYWxsIHRoZSBvbGQgdmFsdWVzIGluIHRoZSBkaWZmIHRvIGZpbGwgdGhlbSBpbiBpbXBsaWNpdGx5XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZWRUYXNrRGVmID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh0YXNrRGVmaW5pdGlvblJlc291cmNlLCBsb3dlckNhc2VGaXJzdENoYXJhY3Rlciwge1xuICAgICAgICAgIC8vIEFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHRha2UgYXJiaXRyYXJ5IHN0cmluZyBhcyBrZXlzIGkuZS4geyBcInN0cmluZ1wiIDogXCJzdHJpbmdcIiB9XG4gICAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkVDUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9SZWdpc3RlclRhc2tEZWZpbml0aW9uLmh0bWwjQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb25fUmVxdWVzdFN5bnRheFxuICAgICAgICAgIENvbnRhaW5lckRlZmluaXRpb25zOiB7XG4gICAgICAgICAgICBEb2NrZXJMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICBGaXJlbGVuc0NvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBMb2dDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIE9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVm9sdW1lczoge1xuICAgICAgICAgICAgRG9ja2VyVm9sdW1lQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBEcml2ZXJPcHRzOiB0cnVlLFxuICAgICAgICAgICAgICBMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWdpc3RlclRhc2tEZWZSZXNwb25zZSA9IGF3YWl0IHNkay5lY3MoKS5yZWdpc3RlclRhc2tEZWZpbml0aW9uKGxvd2VyY2FzZWRUYXNrRGVmKTtcbiAgICAgICAgY29uc3QgdGFza0RlZlJldkFybiA9IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlLnRhc2tEZWZpbml0aW9uPy50YXNrRGVmaW5pdGlvbkFybjtcblxuICAgICAgICBsZXQgZWNzSG90c3dhcFByb3BlcnRpZXMgPSBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMuZWNzSG90c3dhcFByb3BlcnRpZXM7XG4gICAgICAgIGxldCBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgPSBlY3NIb3Rzd2FwUHJvcGVydGllcz8ubWluaW11bUhlYWx0aHlQZXJjZW50O1xuICAgICAgICBsZXQgbWF4aW11bUhlYWx0aHlQZXJjZW50ID0gZWNzSG90c3dhcFByb3BlcnRpZXM/Lm1heGltdW1IZWFsdGh5UGVyY2VudDtcblxuICAgICAgICAvLyBTdGVwIDIgLSB1cGRhdGUgdGhlIHNlcnZpY2VzIHVzaW5nIHRoYXQgVGFza0RlZmluaXRpb24gdG8gcG9pbnQgdG8gdGhlIG5ldyBUYXNrRGVmaW5pdGlvbiBSZXZpc2lvblxuICAgICAgICAvLyBGb3JjaW5nIE5ldyBEZXBsb3ltZW50IGFuZCBzZXR0aW5nIE1pbmltdW0gSGVhbHRoeSBQZXJjZW50IHRvIDAuXG4gICAgICAgIC8vIEFzIENESyBIb3RTd2FwIGlzIGRldmVsb3BtZW50IG9ubHksIHRoaXMgc2VlbXMgdGhlIG1vc3QgZWZmaWNpZW50IHdheSB0byBlbnN1cmUgYWxsIHRhc2tzIGFyZSByZXBsYWNlZCBpbW1lZGlhdGVseSwgcmVnYXJkbGVzcyBvZiBvcmlnaW5hbCBhbW91bnRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLm1hcChhc3luYyAoc2VydmljZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2x1c3RlciA9IHNlcnZpY2Uuc2VydmljZUFybi5zcGxpdCgnLycpWzFdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gYXdhaXQgc2RrLmVjcygpLnVwZGF0ZVNlcnZpY2Uoe1xuICAgICAgICAgICAgICBzZXJ2aWNlOiBzZXJ2aWNlLnNlcnZpY2VBcm4sXG4gICAgICAgICAgICAgIHRhc2tEZWZpbml0aW9uOiB0YXNrRGVmUmV2QXJuLFxuICAgICAgICAgICAgICBjbHVzdGVyLFxuICAgICAgICAgICAgICBmb3JjZU5ld0RlcGxveW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgIGRlcGxveW1lbnRDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgbWluaW11bUhlYWx0aHlQZXJjZW50OiBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgIT09IHVuZGVmaW5lZCA/IG1pbmltdW1IZWFsdGh5UGVyY2VudCA6IDAsXG4gICAgICAgICAgICAgICAgbWF4aW11bVBlcmNlbnQ6IG1heGltdW1IZWFsdGh5UGVyY2VudCAhPT0gdW5kZWZpbmVkID8gbWF4aW11bUhlYWx0aHlQZXJjZW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IHNkay5lY3MoKS53YWl0VW50aWxTZXJ2aWNlc1N0YWJsZSh7XG4gICAgICAgICAgICAgIGNsdXN0ZXI6IHVwZGF0ZS5zZXJ2aWNlPy5jbHVzdGVyQXJuLFxuICAgICAgICAgICAgICBzZXJ2aWNlczogW3NlcnZpY2Uuc2VydmljZUFybl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5pbnRlcmZhY2UgRWNzU2VydmljZSB7XG4gIHJlYWRvbmx5IHNlcnZpY2VBcm46IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZVRhc2tEZWZpbml0aW9uQ2hhbmdlKFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IFJlc291cmNlQ2hhbmdlLFxuKSB7XG4gIGNvbnN0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2U6IHsgW25hbWU6IHN0cmluZ106IGFueSB9ID0ge1xuICAgIC4uLmNoYW5nZS5vbGRWYWx1ZS5Qcm9wZXJ0aWVzLFxuICAgIENvbnRhaW5lckRlZmluaXRpb25zOiBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uQ29udGFpbmVyRGVmaW5pdGlvbnMsXG4gIH07XG4gIC8vIGZpcnN0LCBsZXQncyBnZXQgdGhlIG5hbWUgb2YgdGhlIGZhbWlseVxuICBjb25zdCBmYW1pbHlOYW1lT3JBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lKFxuICAgIGxvZ2ljYWxJZCxcbiAgICB0YXNrRGVmaW5pdGlvblJlc291cmNlPy5GYW1pbHksXG4gICk7XG4gIGlmICghZmFtaWx5TmFtZU9yQXJuKSB7XG4gICAgLy8gaWYgdGhlIEZhbWlseSBwcm9wZXJ0eSBoYXMgbm90IGJlZW4gcHJvdmlkZWQsIGFuZCB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBjdXJyZW50IFN0YWNrLFxuICAgIC8vIHRoaXMgbWVhbnMgaG90c3dhcHBpbmcgaXMgbm90IHBvc3NpYmxlXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHRoZSBwaHlzaWNhbCBuYW1lIG9mIHRoZSBUYXNrIERlZmluaXRpb24gaW4gQ2xvdWRGb3JtYXRpb24gaW5jbHVkZXMgaXRzIGN1cnJlbnQgcmV2aXNpb24gbnVtYmVyIGF0IHRoZSBlbmQsXG4gIC8vIHJlbW92ZSBpdCBpZiBuZWVkZWRcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuUGFydHMgPSBmYW1pbHlOYW1lT3JBcm4uc3BsaXQoJzonKTtcbiAgY29uc3QgZmFtaWx5ID1cbiAgICBmYW1pbHlOYW1lT3JBcm5QYXJ0cy5sZW5ndGggPiAxXG4gICAgICA/IC8vIGZhbWlseU5hbWVPckFybiBpcyBhY3R1YWxseSBhbiBBUk4sIG9mIHRoZSBmb3JtYXQgJ2Fybjphd3M6ZWNzOnJlZ2lvbjphY2NvdW50OnRhc2stZGVmaW5pdGlvbi88ZmFtaWx5LW5hbWU+OjxyZXZpc2lvbi1ucj4nXG4gICAgLy8gc28sIHRha2UgdGhlIDZ0aCBlbGVtZW50LCBhdCBpbmRleCA1LCBhbmQgc3BsaXQgaXQgb24gJy8nXG4gICAgICBmYW1pbHlOYW1lT3JBcm5QYXJ0c1s1XS5zcGxpdCgnLycpWzFdXG4gICAgICA6IC8vIG90aGVyd2lzZSwgZmFtaWx5TmFtZU9yQXJuIGlzIGp1c3QgdGhlIHNpbXBsZSBuYW1lIGV2YWx1YXRlZCBmcm9tIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZVxuICAgICAgZmFtaWx5TmFtZU9yQXJuO1xuICAvLyB0aGVuLCBsZXQncyBldmFsdWF0ZSB0aGUgYm9keSBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBUYXNrRGVmICh3aXRob3V0IHRoZSBGYW1pbHkgcHJvcGVydHkpXG4gIHJldHVybiB7XG4gICAgLi4uKGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHtcbiAgICAgIC4uLih0YXNrRGVmaW5pdGlvblJlc291cmNlID8/IHt9KSxcbiAgICAgIEZhbWlseTogdW5kZWZpbmVkLFxuICAgIH0pKSxcbiAgICBGYW1pbHk6IGZhbWlseSxcbiAgfTtcbn1cbiJdfQ==