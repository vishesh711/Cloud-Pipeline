"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassifiedChanges = exports.EcsHotswapProperties = exports.HotswapPropertyOverrides = exports.HotswapMode = exports.ICON = void 0;
exports.transformObjectKeys = transformObjectKeys;
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
exports.classifyChanges = classifyChanges;
exports.reportNonHotswappableChange = reportNonHotswappableChange;
exports.reportNonHotswappableResource = reportNonHotswappableResource;
const error_1 = require("../../toolkit/error");
exports.ICON = 'âœ¨';
var HotswapMode;
(function (HotswapMode) {
    /**
     * Will fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["FALL_BACK"] = "fall-back";
    /**
     * Will not fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["HOTSWAP_ONLY"] = "hotswap-only";
    /**
     * Will not attempt to hotswap anything and instead go straight to CloudFormation
     */
    HotswapMode["FULL_DEPLOYMENT"] = "full-deployment";
})(HotswapMode || (exports.HotswapMode = HotswapMode = {}));
/**
 * Represents configuration property overrides for hotswap deployments
 */
class HotswapPropertyOverrides {
    constructor(ecsHotswapProperties) {
        this.ecsHotswapProperties = ecsHotswapProperties;
    }
}
exports.HotswapPropertyOverrides = HotswapPropertyOverrides;
/**
 * Represents configuration properties for ECS hotswap deployments
 */
class EcsHotswapProperties {
    constructor(minimumHealthyPercent, maximumHealthyPercent) {
        if (minimumHealthyPercent !== undefined && minimumHealthyPercent < 0) {
            throw new error_1.ToolkitError('hotswap-ecs-minimum-healthy-percent can\'t be a negative number');
        }
        if (maximumHealthyPercent !== undefined && maximumHealthyPercent < 0) {
            throw new error_1.ToolkitError('hotswap-ecs-maximum-healthy-percent can\'t be a negative number');
        }
        // In order to preserve the current behaviour, when minimumHealthyPercent is not defined, it will be set to the currently default value of 0
        if (minimumHealthyPercent == undefined) {
            this.minimumHealthyPercent = 0;
        }
        else {
            this.minimumHealthyPercent = minimumHealthyPercent;
        }
        this.maximumHealthyPercent = maximumHealthyPercent;
    }
    /**
     * Check if any hotswap properties are defined
     * @returns true if all properties are undefined, false otherwise
     */
    isEmpty() {
        return this.minimumHealthyPercent === 0 && this.maximumHealthyPercent === undefined;
    }
}
exports.EcsHotswapProperties = EcsHotswapProperties;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}
class ClassifiedChanges {
    constructor(change, hotswappableProps, nonHotswappableProps) {
        this.change = change;
        this.hotswappableProps = hotswappableProps;
        this.nonHotswappableProps = nonHotswappableProps;
    }
    reportNonHotswappablePropertyChanges(ret) {
        const nonHotswappablePropNames = Object.keys(this.nonHotswappableProps);
        if (nonHotswappablePropNames.length > 0) {
            const tagOnlyChange = nonHotswappablePropNames.length === 1 && nonHotswappablePropNames[0] === 'Tags';
            reportNonHotswappableChange(ret, this.change, this.nonHotswappableProps, tagOnlyChange
                ? 'Tags are not hotswappable'
                : `resource properties '${nonHotswappablePropNames}' are not hotswappable on this resource type`);
        }
    }
    get namesOfHotswappableProps() {
        return Object.keys(this.hotswappableProps);
    }
}
exports.ClassifiedChanges = ClassifiedChanges;
function classifyChanges(xs, hotswappablePropNames) {
    const hotswappableProps = {};
    const nonHotswappableProps = {};
    for (const [name, propDiff] of Object.entries(xs.propertyUpdates)) {
        if (hotswappablePropNames.includes(name)) {
            hotswappableProps[name] = propDiff;
        }
        else {
            nonHotswappableProps[name] = propDiff;
        }
    }
    return new ClassifiedChanges(xs, hotswappableProps, nonHotswappableProps);
}
function reportNonHotswappableChange(ret, change, nonHotswappableProps, reason, hotswapOnlyVisible) {
    let hotswapOnlyVisibility = true;
    if (hotswapOnlyVisible === false) {
        hotswapOnlyVisibility = false;
    }
    ret.push({
        hotswappable: false,
        rejectedChanges: Object.keys(nonHotswappableProps !== null && nonHotswappableProps !== void 0 ? nonHotswappableProps : change.propertyUpdates),
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        reason,
        hotswapOnlyVisible: hotswapOnlyVisibility,
    });
}
function reportNonHotswappableResource(change, reason) {
    return [
        {
            hotswappable: false,
            rejectedChanges: Object.keys(change.propertyUpdates),
            logicalId: change.logicalId,
            resourceType: change.newValue.Type,
            reason,
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQStKQSxrREFvQkM7QUFLRCwwREFFQztBQWdDRCwwQ0FhQztBQUVELGtFQW1CQztBQUVELHNFQWFDO0FBeFFELCtDQUFtRDtBQUd0QyxRQUFBLElBQUksR0FBRyxHQUFHLENBQUM7QUFnRnhCLElBQVksV0FlWDtBQWZELFdBQVksV0FBVztJQUNyQjs7T0FFRztJQUNILHNDQUF1QixDQUFBO0lBRXZCOztPQUVHO0lBQ0gsNENBQTZCLENBQUE7SUFFN0I7O09BRUc7SUFDSCxrREFBbUMsQ0FBQTtBQUNyQyxDQUFDLEVBZlcsV0FBVywyQkFBWCxXQUFXLFFBZXRCO0FBSUQ7O0dBRUc7QUFDSCxNQUFhLHdCQUF3QjtJQUluQyxZQUFvQixvQkFBMkM7UUFDN0QsSUFBSSxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDO0lBQ25ELENBQUM7Q0FDRjtBQVBELDREQU9DO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLG9CQUFvQjtJQU0vQixZQUFvQixxQkFBOEIsRUFBRSxxQkFBOEI7UUFDaEYsSUFBSSxxQkFBcUIsS0FBSyxTQUFTLElBQUkscUJBQXFCLEdBQUcsQ0FBQyxFQUFHLENBQUM7WUFDdEUsTUFBTSxJQUFJLG9CQUFZLENBQUMsaUVBQWlFLENBQUMsQ0FBQztRQUM1RixDQUFDO1FBQ0QsSUFBSSxxQkFBcUIsS0FBSyxTQUFTLElBQUkscUJBQXFCLEdBQUcsQ0FBQyxFQUFHLENBQUM7WUFDdEUsTUFBTSxJQUFJLG9CQUFZLENBQUMsaUVBQWlFLENBQUMsQ0FBQztRQUM1RixDQUFDO1FBQ0QsNElBQTRJO1FBQzVJLElBQUkscUJBQXFCLElBQUksU0FBUyxFQUFFLENBQUM7WUFDdkMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLENBQUMsQ0FBQztRQUNqQyxDQUFDO2FBQU0sQ0FBQztZQUNOLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxxQkFBcUIsQ0FBQztRQUNyRCxDQUFDO1FBQ0QsSUFBSSxDQUFDLHFCQUFxQixHQUFHLHFCQUFxQixDQUFDO0lBQ3JELENBQUM7SUFFRDs7O09BR0c7SUFDSSxPQUFPO1FBQ1osT0FBTyxJQUFJLENBQUMscUJBQXFCLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsS0FBSyxTQUFTLENBQUM7SUFDdEYsQ0FBQztDQUNGO0FBN0JELG9EQTZCQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FBQyxHQUFRLEVBQUUsU0FBa0MsRUFBRSxVQUFtQixFQUFFO0lBQ3JHLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUMzQyxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFDRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUN2QiwyREFBMkQ7UUFDM0Qsc0ZBQXNGO1FBQ3RGLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ2pGLENBQUM7SUFDRCxNQUFNLEdBQUcsR0FBeUIsRUFBRSxDQUFDO0lBQ3JDLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLElBQUksWUFBWSxLQUFLLElBQUksRUFBRSxDQUFDO1lBQzFCLG9FQUFvRTtZQUNwRSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLENBQUM7YUFBTSxDQUFDO1lBQ04sR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLG1CQUFtQixDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDdEUsQ0FBQztJQUNILENBQUM7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHVCQUF1QixDQUFDLEdBQVc7SUFDakQsT0FBTyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDekUsQ0FBQztBQUlELE1BQWEsaUJBQWlCO0lBQzVCLFlBQ2tCLE1BQXNCLEVBQ3RCLGlCQUE0QixFQUM1QixvQkFBK0I7UUFGL0IsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7UUFDdEIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFXO1FBQzVCLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBVztJQUVqRCxDQUFDO0lBRU0sb0NBQW9DLENBQUMsR0FBd0I7UUFDbEUsTUFBTSx3QkFBd0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3hFLElBQUksd0JBQXdCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3hDLE1BQU0sYUFBYSxHQUFHLHdCQUF3QixDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksd0JBQXdCLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDO1lBQ3RHLDJCQUEyQixDQUN6QixHQUFHLEVBQ0gsSUFBSSxDQUFDLE1BQU0sRUFDWCxJQUFJLENBQUMsb0JBQW9CLEVBQ3pCLGFBQWE7Z0JBQ1gsQ0FBQyxDQUFDLDJCQUEyQjtnQkFDN0IsQ0FBQyxDQUFDLHdCQUF3Qix3QkFBd0IsOENBQThDLENBQ25HLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVELElBQVcsd0JBQXdCO1FBQ2pDLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0NBQ0Y7QUExQkQsOENBMEJDO0FBRUQsU0FBZ0IsZUFBZSxDQUFDLEVBQWtCLEVBQUUscUJBQStCO0lBQ2pGLE1BQU0saUJBQWlCLEdBQWMsRUFBRSxDQUFDO0lBQ3hDLE1BQU0sb0JBQW9CLEdBQWMsRUFBRSxDQUFDO0lBRTNDLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDO1FBQ2xFLElBQUkscUJBQXFCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDekMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDO1FBQ3JDLENBQUM7YUFBTSxDQUFDO1lBQ04sb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDO1FBQ3hDLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxJQUFJLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxpQkFBaUIsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0FBQzVFLENBQUM7QUFFRCxTQUFnQiwyQkFBMkIsQ0FDekMsR0FBd0IsRUFDeEIsTUFBc0IsRUFDdEIsb0JBQWdDLEVBQ2hDLE1BQWUsRUFDZixrQkFBNEI7SUFFNUIsSUFBSSxxQkFBcUIsR0FBRyxJQUFJLENBQUM7SUFDakMsSUFBSSxrQkFBa0IsS0FBSyxLQUFLLEVBQUUsQ0FBQztRQUNqQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7SUFDaEMsQ0FBQztJQUNELEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDUCxZQUFZLEVBQUUsS0FBSztRQUNuQixlQUFlLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsYUFBcEIsb0JBQW9CLGNBQXBCLG9CQUFvQixHQUFJLE1BQU0sQ0FBQyxlQUFlLENBQUM7UUFDNUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO1FBQzNCLFlBQVksRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUk7UUFDbEMsTUFBTTtRQUNOLGtCQUFrQixFQUFFLHFCQUFxQjtLQUMxQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsU0FBZ0IsNkJBQTZCLENBQzNDLE1BQXNCLEVBQ3RCLE1BQWU7SUFFZixPQUFPO1FBQ0w7WUFDRSxZQUFZLEVBQUUsS0FBSztZQUNuQixlQUFlLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDO1lBQ3BELFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztZQUMzQixZQUFZLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJO1lBQ2xDLE1BQU07U0FDUDtLQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBQcm9wZXJ0eURpZmZlcmVuY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB0eXBlIHsgQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB0eXBlIHsgSG90c3dhcHBhYmxlQ2hhbmdlLCBSZXNvdXJjZUNoYW5nZSB9IGZyb20gJy4uLy4uLy4uLy4uL0Bhd3MtY2RrL3RtcC10b29sa2l0LWhlbHBlcnMvc3JjL2FwaS9pby9wYXlsb2Fkcy9ob3Rzd2FwJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbmV4cG9ydCBjb25zdCBJQ09OID0gJ+KcqCc7XG5cbi8qKlxuICogVGhlIHJlc3VsdCBvZiBhbiBhdHRlbXB0ZWQgaG90c3dhcCBkZXBsb3ltZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG90c3dhcFJlc3VsdCB7XG4gIC8qKlxuICAgKiBUaGUgc3RhY2sgdGhhdCB3YXMgaG90c3dhcHBlZFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbiAgLyoqXG4gICAqIFdoZXRoZXIgaG90c3dhcHBpbmcgaGFwcGVuZWQgb3Igbm90LlxuICAgKlxuICAgKiBgZmFsc2VgIGluZGljYXRlcyB0aGF0IHRoZSBkZXBsb3ltZW50IGNvdWxkIG5vdCBiZSBob3Rzd2FwcGVkIGFuZCBmdWxsIGRlcGxveW1lbnQgbWF5IGJlIGF0dGVtcHRlZCBhcyBmYWxsYmFjay5cbiAgICovXG4gIHJlYWRvbmx5IGhvdHN3YXBwZWQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgY2hhbmdlcyB0aGF0IHdlcmUgZGVlbWVkIGhvdHN3YXBwYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgaG90c3dhcHBhYmxlQ2hhbmdlczogYW55W107XG4gIC8qKlxuICAgKiBUaGUgY2hhbmdlcyB0aGF0IHdlcmUgZGVlbWVkIG5vdCBob3Rzd2FwcGFibGVcbiAgICovXG4gIHJlYWRvbmx5IG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IGFueVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhvdHN3YXBPcGVyYXRpb24ge1xuICAvKipcbiAgICogTWFya3MgdGhlIG9wZXJhdGlvbiBhcyBob3Rzd2FwcGFibGVcbiAgICovXG4gIHJlYWRvbmx5IGhvdHN3YXBwYWJsZTogdHJ1ZTtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgYmVpbmcgaG90c3dhcHBlZC5cbiAgICogVXNlZCB0byBzZXQgYSBjdXN0b20gVXNlci1BZ2VudCBmb3IgU0RLIGNhbGxzLlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXNjcmlwdGlvbiBvZiB0aGUgY2hhbmdlIHRoYXQgaXMgYXBwbGllZCBhcyBwYXJ0IG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgb2YgdGhlIHJlc291cmNlcyBiZWluZyBob3Rzd2FwcGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGhvdHN3YXAgb3BlcmF0aW9uXG4gICAqL1xuICByZWFkb25seSBhcHBseTogKHNkazogU0RLKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vbkhvdHN3YXBwYWJsZUNoYW5nZSB7XG4gIHJlYWRvbmx5IGhvdHN3YXBwYWJsZTogZmFsc2U7XG4gIHJlYWRvbmx5IHJlc291cmNlVHlwZTogc3RyaW5nO1xuICByZWFkb25seSByZWplY3RlZENoYW5nZXM6IEFycmF5PHN0cmluZz47XG4gIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuICAvKipcbiAgICogVGVsbHMgdGhlIHVzZXIgZXhhY3RseSB3aHkgdGhpcyBjaGFuZ2Ugd2FzIGRlZW1lZCBub24taG90c3dhcHBhYmxlIGFuZCB3aGF0IGl0cyBsb2dpY2FsIElEIGlzLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBgcmVhc29uYCB3aWxsIGJlIGF1dG9maWxsZWQgdG8gc3RhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBsaXN0ZWQgaW4gYHJlamVjdGVkQ2hhbmdlc2AgYXJlIG5vdCBob3Rzd2FwcGFibGUuXG4gICAqL1xuICByZWFkb25seSByZWFzb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0byBzaG93IHRoaXMgY2hhbmdlIHdoZW4gbGlzdGluZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgaW4gSE9UU1dBUF9PTkxZIG1vZGUuIERvZXMgbm90IGFmZmVjdFxuICAgKiBsaXN0aW5nIGluIEZBTExfQkFDSyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBob3Rzd2FwT25seVZpc2libGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gQXJyYXk8SG90c3dhcE9wZXJhdGlvbiB8IE5vbkhvdHN3YXBwYWJsZUNoYW5nZT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcyB7XG4gIGhvdHN3YXBwYWJsZUNoYW5nZXM6IEhvdHN3YXBPcGVyYXRpb25bXTtcbiAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlczogTm9uSG90c3dhcHBhYmxlQ2hhbmdlW107XG59XG5cbmV4cG9ydCBlbnVtIEhvdHN3YXBNb2RlIHtcbiAgLyoqXG4gICAqIFdpbGwgZmFsbCBiYWNrIHRvIENsb3VkRm9ybWF0aW9uIHdoZW4gYSBub24taG90c3dhcHBhYmxlIGNoYW5nZSBpcyBkZXRlY3RlZFxuICAgKi9cbiAgRkFMTF9CQUNLID0gJ2ZhbGwtYmFjaycsXG5cbiAgLyoqXG4gICAqIFdpbGwgbm90IGZhbGwgYmFjayB0byBDbG91ZEZvcm1hdGlvbiB3aGVuIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UgaXMgZGV0ZWN0ZWRcbiAgICovXG4gIEhPVFNXQVBfT05MWSA9ICdob3Rzd2FwLW9ubHknLFxuXG4gIC8qKlxuICAgKiBXaWxsIG5vdCBhdHRlbXB0IHRvIGhvdHN3YXAgYW55dGhpbmcgYW5kIGluc3RlYWQgZ28gc3RyYWlnaHQgdG8gQ2xvdWRGb3JtYXRpb25cbiAgICovXG4gIEZVTExfREVQTE9ZTUVOVCA9ICdmdWxsLWRlcGxveW1lbnQnLFxufVxuXG50eXBlIEV4Y2x1ZGUgPSB7IFtrZXk6IHN0cmluZ106IEV4Y2x1ZGUgfCB0cnVlIH07XG5cbi8qKlxuICogUmVwcmVzZW50cyBjb25maWd1cmF0aW9uIHByb3BlcnR5IG92ZXJyaWRlcyBmb3IgaG90c3dhcCBkZXBsb3ltZW50c1xuICovXG5leHBvcnQgY2xhc3MgSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzIHtcbiAgLy8gRWFjaCBzdXBwb3J0ZWQgcmVzb3VyY2UgdHlwZSB3aWxsIGhhdmUgaXRzIG93biBwcm9wZXJ0aWVzLiBDdXJyZW50bHkgdGhpcyBpcyBFQ1NcbiAgZWNzSG90c3dhcFByb3BlcnRpZXM/OiBFY3NIb3Rzd2FwUHJvcGVydGllcztcblxuICBwdWJsaWMgY29uc3RydWN0b3IgKGVjc0hvdHN3YXBQcm9wZXJ0aWVzPzogRWNzSG90c3dhcFByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmVjc0hvdHN3YXBQcm9wZXJ0aWVzID0gZWNzSG90c3dhcFByb3BlcnRpZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgRUNTIGhvdHN3YXAgZGVwbG95bWVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIEVjc0hvdHN3YXBQcm9wZXJ0aWVzIHtcbiAgLy8gVGhlIGxvd2VyIGxpbWl0IG9uIHRoZSBudW1iZXIgb2YgeW91ciBzZXJ2aWNlJ3MgdGFza3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgUlVOTklORyBzdGF0ZSBkdXJpbmcgYSBkZXBsb3ltZW50LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGRlc2lyZWRDb3VudFxuICByZWFkb25seSBtaW5pbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXI7XG4gIC8vIFRoZSB1cHBlciBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIHlvdXIgc2VydmljZSdzIHRhc2tzIHRoYXQgYXJlIGFsbG93ZWQgaW4gdGhlIFJVTk5JTkcgb3IgUEVORElORyBzdGF0ZSBkdXJpbmcgYSBkZXBsb3ltZW50LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGRlc2lyZWRDb3VudFxuICByZWFkb25seSBtYXhpbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yIChtaW5pbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXIsIG1heGltdW1IZWFsdGh5UGVyY2VudD86IG51bWJlcikge1xuICAgIGlmIChtaW5pbXVtSGVhbHRoeVBlcmNlbnQgIT09IHVuZGVmaW5lZCAmJiBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgPCAwICkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignaG90c3dhcC1lY3MtbWluaW11bS1oZWFsdGh5LXBlcmNlbnQgY2FuXFwndCBiZSBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAobWF4aW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgJiYgbWF4aW11bUhlYWx0aHlQZXJjZW50IDwgMCApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ2hvdHN3YXAtZWNzLW1heGltdW0taGVhbHRoeS1wZXJjZW50IGNhblxcJ3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGN1cnJlbnQgYmVoYXZpb3VyLCB3aGVuIG1pbmltdW1IZWFsdGh5UGVyY2VudCBpcyBub3QgZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnRseSBkZWZhdWx0IHZhbHVlIG9mIDBcbiAgICBpZiAobWluaW11bUhlYWx0aHlQZXJjZW50ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5taW5pbXVtSGVhbHRoeVBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pbmltdW1IZWFsdGh5UGVyY2VudCA9IG1pbmltdW1IZWFsdGh5UGVyY2VudDtcbiAgICB9XG4gICAgdGhpcy5tYXhpbXVtSGVhbHRoeVBlcmNlbnQgPSBtYXhpbXVtSGVhbHRoeVBlcmNlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW55IGhvdHN3YXAgcHJvcGVydGllcyBhcmUgZGVmaW5lZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFsbCBwcm9wZXJ0aWVzIGFyZSB1bmRlZmluZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgcHVibGljIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubWluaW11bUhlYWx0aHlQZXJjZW50ID09PSAwICYmIHRoaXMubWF4aW11bUhlYWx0aHlQZXJjZW50ID09PSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyYW5zZm9ybXMgYWxsIGtleXMgKHJlY3Vyc2l2ZWx5KSBpbiB0aGUgcHJvdmlkZWQgYHZhbGAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWwgVGhlIG9iamVjdCB3aG9zZSBrZXlzIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0gdHJhbnNmb3JtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBlYWNoIGtleS5cbiAqIEBwYXJhbSBleGNsdWRlIFRoZSBrZXlzIHRoYXQgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWQgYW5kIGNvcGllZCB0byBvdXRwdXQgZGlyZWN0bHlcbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyBgdmFsYCwgYnV0IHdpdGggYWxsIGtleXMgdHJhbnNmb3JtZWQgYWNjb3JkaW5nIHRvIGB0cmFuc2Zvcm1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtT2JqZWN0S2V5cyh2YWw6IGFueSwgdHJhbnNmb3JtOiAoc3RyOiBzdHJpbmcpID0+IHN0cmluZywgZXhjbHVkZTogRXhjbHVkZSA9IHt9KTogYW55IHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gRm9yIGFycmF5cyB3ZSBqdXN0IHBhc3MgcGFyZW50J3MgZXhjbHVkZSBvYmplY3QgZGlyZWN0bHlcbiAgICAvLyBzaW5jZSBpdCBtYWtlcyBubyBzZW5zZSB0byBzcGVjaWZ5IGRpZmZlcmVudCBleGNsdWRlIG9wdGlvbnMgZm9yIGVhY2ggYXJyYXkgZWxlbWVudFxuICAgIHJldHVybiB2YWwubWFwKChpbnB1dDogYW55KSA9PiB0cmFuc2Zvcm1PYmplY3RLZXlzKGlucHV0LCB0cmFuc2Zvcm0sIGV4Y2x1ZGUpKTtcbiAgfVxuICBjb25zdCByZXQ6IHsgW2s6IHN0cmluZ106IGFueSB9ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpIHtcbiAgICBjb25zdCBjaGlsZEV4Y2x1ZGUgPSBleGNsdWRlW2tdO1xuICAgIGlmIChjaGlsZEV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgIC8vIHdlIGRvbid0IHRyYW5zZm9ybSB0aGlzIG9iamVjdCBpZiB0aGUga2V5IGlzIHNwZWNpZmllZCBpbiBleGNsdWRlXG4gICAgICByZXRbdHJhbnNmb3JtKGspXSA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFt0cmFuc2Zvcm0oayldID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh2LCB0cmFuc2Zvcm0sIGNoaWxkRXhjbHVkZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsb3dlciBjYXNlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdENoYXJhY3RlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IGAke3N0clswXS50b0xvd2VyQ2FzZSgpfSR7c3RyLnNsaWNlKDEpfWAgOiBzdHI7XG59XG5cbnR5cGUgUHJvcERpZmZzID0gUmVjb3JkPHN0cmluZywgUHJvcGVydHlEaWZmZXJlbmNlPGFueT4+O1xuXG5leHBvcnQgY2xhc3MgQ2xhc3NpZmllZENoYW5nZXMge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGNoYW5nZTogUmVzb3VyY2VDaGFuZ2UsXG4gICAgcHVibGljIHJlYWRvbmx5IGhvdHN3YXBwYWJsZVByb3BzOiBQcm9wRGlmZnMsXG4gICAgcHVibGljIHJlYWRvbmx5IG5vbkhvdHN3YXBwYWJsZVByb3BzOiBQcm9wRGlmZnMsXG4gICkge1xuICB9XG5cbiAgcHVibGljIHJlcG9ydE5vbkhvdHN3YXBwYWJsZVByb3BlcnR5Q2hhbmdlcyhyZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQpOiB2b2lkIHtcbiAgICBjb25zdCBub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm5vbkhvdHN3YXBwYWJsZVByb3BzKTtcbiAgICBpZiAobm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRhZ09ubHlDaGFuZ2UgPSBub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXMubGVuZ3RoID09PSAxICYmIG5vbkhvdHN3YXBwYWJsZVByb3BOYW1lc1swXSA9PT0gJ1RhZ3MnO1xuICAgICAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKFxuICAgICAgICByZXQsXG4gICAgICAgIHRoaXMuY2hhbmdlLFxuICAgICAgICB0aGlzLm5vbkhvdHN3YXBwYWJsZVByb3BzLFxuICAgICAgICB0YWdPbmx5Q2hhbmdlXG4gICAgICAgICAgPyAnVGFncyBhcmUgbm90IGhvdHN3YXBwYWJsZSdcbiAgICAgICAgICA6IGByZXNvdXJjZSBwcm9wZXJ0aWVzICcke25vbkhvdHN3YXBwYWJsZVByb3BOYW1lc30nIGFyZSBub3QgaG90c3dhcHBhYmxlIG9uIHRoaXMgcmVzb3VyY2UgdHlwZWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZXNPZkhvdHN3YXBwYWJsZVByb3BzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5Q2hhbmdlcyh4czogUmVzb3VyY2VDaGFuZ2UsIGhvdHN3YXBwYWJsZVByb3BOYW1lczogc3RyaW5nW10pOiBDbGFzc2lmaWVkQ2hhbmdlcyB7XG4gIGNvbnN0IGhvdHN3YXBwYWJsZVByb3BzOiBQcm9wRGlmZnMgPSB7fTtcbiAgY29uc3Qgbm9uSG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyA9IHt9O1xuXG4gIGZvciAoY29uc3QgW25hbWUsIHByb3BEaWZmXSBvZiBPYmplY3QuZW50cmllcyh4cy5wcm9wZXJ0eVVwZGF0ZXMpKSB7XG4gICAgaWYgKGhvdHN3YXBwYWJsZVByb3BOYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgaG90c3dhcHBhYmxlUHJvcHNbbmFtZV0gPSBwcm9wRGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9uSG90c3dhcHBhYmxlUHJvcHNbbmFtZV0gPSBwcm9wRGlmZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IENsYXNzaWZpZWRDaGFuZ2VzKHhzLCBob3Rzd2FwcGFibGVQcm9wcywgbm9uSG90c3dhcHBhYmxlUHJvcHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKFxuICByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQsXG4gIGNoYW5nZTogUmVzb3VyY2VDaGFuZ2UsXG4gIG5vbkhvdHN3YXBwYWJsZVByb3BzPzogUHJvcERpZmZzLFxuICByZWFzb24/OiBzdHJpbmcsXG4gIGhvdHN3YXBPbmx5VmlzaWJsZT86IGJvb2xlYW4sXG4pOiB2b2lkIHtcbiAgbGV0IGhvdHN3YXBPbmx5VmlzaWJpbGl0eSA9IHRydWU7XG4gIGlmIChob3Rzd2FwT25seVZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgaG90c3dhcE9ubHlWaXNpYmlsaXR5ID0gZmFsc2U7XG4gIH1cbiAgcmV0LnB1c2goe1xuICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgcmVqZWN0ZWRDaGFuZ2VzOiBPYmplY3Qua2V5cyhub25Ib3Rzd2FwcGFibGVQcm9wcyA/PyBjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSxcbiAgICBsb2dpY2FsSWQ6IGNoYW5nZS5sb2dpY2FsSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICByZWFzb24sXG4gICAgaG90c3dhcE9ubHlWaXNpYmxlOiBob3Rzd2FwT25seVZpc2liaWxpdHksXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UoXG4gIGNoYW5nZTogUmVzb3VyY2VDaGFuZ2UsXG4gIHJlYXNvbj86IHN0cmluZyxcbik6IENoYW5nZUhvdHN3YXBSZXN1bHQge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZWplY3RlZENoYW5nZXM6IE9iamVjdC5rZXlzKGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpLFxuICAgICAgbG9naWNhbElkOiBjaGFuZ2UubG9naWNhbElkLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgIHJlYXNvbixcbiAgICB9LFxuICBdO1xufVxuIl19