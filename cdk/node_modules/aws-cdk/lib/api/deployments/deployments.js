"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deployments = void 0;
const crypto_1 = require("crypto");
const cdk_assets = require("cdk-assets");
const chalk = require("chalk");
const asset_manifest_builder_1 = require("./asset-manifest-builder");
const asset_publishing_1 = require("./asset-publishing");
const checks_1 = require("./checks");
const cloudformation_1 = require("./cloudformation");
const deploy_stack_1 = require("./deploy-stack");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
const util_1 = require("../../util");
const environment_1 = require("../environment");
const stack_events_1 = require("../stack-events");
const toolkit_info_1 = require("../toolkit-info");
const template_body_parameter_1 = require("../util/template-body-parameter");
const BOOTSTRAP_STACK_VERSION_FOR_ROLLBACK = 23;
/**
 * Scope for a single set of deployments from a set of Cloud Assembly Artifacts
 *
 * Manages lookup of SDKs, Bootstrap stacks, etc.
 */
class Deployments {
    constructor(props) {
        var _a;
        this.props = props;
        this.publisherCache = new Map();
        this.assetSdkProvider = props.sdkProvider;
        this.deployStackSdkProvider = props.sdkProvider;
        this.ioHelper = props.ioHelper;
        this.envs = new environment_1.EnvironmentAccess(props.sdkProvider, (_a = props.toolkitStackName) !== null && _a !== void 0 ? _a : toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME, this.ioHelper);
    }
    /**
     * Resolves the environment for a stack.
     */
    async resolveEnvironment(stack) {
        return this.envs.resolveStackEnvironment(stack);
    }
    async readCurrentTemplateWithNestedStacks(rootStackArtifact, retrieveProcessedTemplate = false) {
        const env = await this.envs.accessStackForLookupBestEffort(rootStackArtifact);
        return (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(rootStackArtifact, env.sdk, retrieveProcessedTemplate);
    }
    async readCurrentTemplate(stackArtifact) {
        await this.ioHelper.notify((0, messages_1.debug)(`Reading existing template for stack ${stackArtifact.displayName}.`));
        const env = await this.envs.accessStackForLookupBestEffort(stackArtifact);
        return (0, nested_stack_helpers_1.loadCurrentTemplate)(stackArtifact, env.sdk);
    }
    async resourceIdentifierSummaries(stackArtifact) {
        var _a;
        await this.ioHelper.notify((0, messages_1.debug)(`Retrieving template summary for stack ${stackArtifact.displayName}.`));
        // Currently, needs to use `deploy-role` since it may need to read templates in the staging
        // bucket which have been encrypted with a KMS key (and lookup-role may not read encrypted things)
        const env = await this.envs.accessStackForReadOnlyStackOperations(stackArtifact);
        const cfn = env.sdk.cloudFormation();
        await (0, cloudformation_1.uploadStackTemplateAssets)(stackArtifact, this);
        // Upload the template, if necessary, before passing it to CFN
        const builder = new asset_manifest_builder_1.AssetManifestBuilder();
        const cfnParam = await (0, template_body_parameter_1.makeBodyParameter)(stackArtifact, env.resolvedEnvironment, builder, env.resources);
        // If the `makeBodyParameter` before this added assets, make sure to publish them before
        // calling the API.
        const addedAssets = builder.toManifest(stackArtifact.assembly.directory);
        for (const entry of addedAssets.entries) {
            await this.buildSingleAsset('no-version-validation', addedAssets, entry, {
                stack: stackArtifact,
            });
            await this.publishSingleAsset(addedAssets, entry, {
                stack: stackArtifact,
            });
        }
        const response = await cfn.getTemplateSummary(cfnParam);
        if (!response.ResourceIdentifierSummaries) {
            await this.ioHelper.notify((0, messages_1.debug)('GetTemplateSummary API call did not return "ResourceIdentifierSummaries"'));
        }
        return (_a = response.ResourceIdentifierSummaries) !== null && _a !== void 0 ? _a : [];
    }
    async deployStack(options) {
        var _a;
        let deploymentMethod = options.deploymentMethod;
        if (options.changeSetName || options.execute !== undefined) {
            if (deploymentMethod) {
                throw new error_1.ToolkitError("You cannot supply both 'deploymentMethod' and 'changeSetName/execute'. Supply one or the other.");
            }
            deploymentMethod = {
                method: 'change-set',
                changeSetName: options.changeSetName,
                execute: options.execute,
            };
        }
        const env = await this.envs.accessStackForMutableStackOperations(options.stack);
        // Do a verification of the bootstrap stack version
        await this.validateBootstrapStackVersion(options.stack.stackName, options.stack.requiresBootstrapStackVersion, options.stack.bootstrapStackVersionSsmParameter, env.resources);
        const executionRoleArn = await env.replacePlaceholders((_a = options.roleArn) !== null && _a !== void 0 ? _a : options.stack.cloudFormationExecutionRoleArn);
        return (0, deploy_stack_1.deployStack)({
            stack: options.stack,
            resolvedEnvironment: env.resolvedEnvironment,
            deployName: options.deployName,
            notificationArns: options.notificationArns,
            sdk: env.sdk,
            sdkProvider: this.deployStackSdkProvider,
            roleArn: executionRoleArn,
            reuseAssets: options.reuseAssets,
            envResources: env.resources,
            tags: options.tags,
            deploymentMethod,
            force: options.force,
            parameters: options.parameters,
            usePreviousParameters: options.usePreviousParameters,
            rollback: options.rollback,
            hotswap: options.hotswap,
            hotswapPropertyOverrides: options.hotswapPropertyOverrides,
            extraUserAgent: options.extraUserAgent,
            resourcesToImport: options.resourcesToImport,
            overrideTemplate: options.overrideTemplate,
            assetParallelism: options.assetParallelism,
        }, this.ioHelper);
    }
    async rollbackStack(options) {
        var _a, _b, _c;
        let resourcesToSkip = (_a = options.orphanLogicalIds) !== null && _a !== void 0 ? _a : [];
        if (options.force && resourcesToSkip.length > 0) {
            throw new error_1.ToolkitError('Cannot combine --force with --orphan');
        }
        const env = await this.envs.accessStackForMutableStackOperations(options.stack);
        if ((_b = options.validateBootstrapStackVersion) !== null && _b !== void 0 ? _b : true) {
            // Do a verification of the bootstrap stack version
            await this.validateBootstrapStackVersion(options.stack.stackName, BOOTSTRAP_STACK_VERSION_FOR_ROLLBACK, options.stack.bootstrapStackVersionSsmParameter, env.resources);
        }
        const cfn = env.sdk.cloudFormation();
        const deployName = options.stack.stackName;
        // We loop in case of `--force` and the stack ends up in `CONTINUE_UPDATE_ROLLBACK`.
        let maxLoops = 10;
        while (maxLoops--) {
            let cloudFormationStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
            const executionRoleArn = await env.replacePlaceholders((_c = options.roleArn) !== null && _c !== void 0 ? _c : options.stack.cloudFormationExecutionRoleArn);
            switch (cloudFormationStack.stackStatus.rollbackChoice) {
                case stack_events_1.RollbackChoice.NONE:
                    await this.ioHelper.notify((0, messages_1.warn)(`Stack ${deployName} does not need a rollback: ${cloudFormationStack.stackStatus}`));
                    return { notInRollbackableState: true };
                case stack_events_1.RollbackChoice.START_ROLLBACK:
                    await this.ioHelper.notify((0, messages_1.debug)(`Initiating rollback of stack ${deployName}`));
                    await cfn.rollbackStack({
                        StackName: deployName,
                        RoleARN: executionRoleArn,
                        ClientRequestToken: (0, crypto_1.randomUUID)(),
                        // Enabling this is just the better overall default, the only reason it isn't the upstream default is backwards compatibility
                        RetainExceptOnCreate: true,
                    });
                    break;
                case stack_events_1.RollbackChoice.CONTINUE_UPDATE_ROLLBACK:
                    if (options.force) {
                        // Find the failed resources from the deployment and automatically skip them
                        // (Using deployment log because we definitely have `DescribeStackEvents` permissions, and we might not have
                        // `DescribeStackResources` permissions).
                        const poller = new stack_events_1.StackEventPoller(cfn, {
                            stackName: deployName,
                            stackStatuses: ['ROLLBACK_IN_PROGRESS', 'UPDATE_ROLLBACK_IN_PROGRESS'],
                        });
                        await poller.poll();
                        resourcesToSkip = poller.resourceErrors
                            .filter((r) => !r.isStackEvent && r.parentStackLogicalIds.length === 0)
                            .map((r) => { var _a; return (_a = r.event.LogicalResourceId) !== null && _a !== void 0 ? _a : ''; });
                    }
                    const skipDescription = resourcesToSkip.length > 0 ? ` (orphaning: ${resourcesToSkip.join(', ')})` : '';
                    await this.ioHelper.notify((0, messages_1.warn)(`Continuing rollback of stack ${deployName}${skipDescription}`));
                    await cfn.continueUpdateRollback({
                        StackName: deployName,
                        ClientRequestToken: (0, crypto_1.randomUUID)(),
                        RoleARN: executionRoleArn,
                        ResourcesToSkip: resourcesToSkip,
                    });
                    break;
                case stack_events_1.RollbackChoice.ROLLBACK_FAILED:
                    await this.ioHelper.notify((0, messages_1.warn)(`Stack ${deployName} failed creation and rollback. This state cannot be rolled back. You can recreate this stack by running 'cdk deploy'.`));
                    return { notInRollbackableState: true };
                default:
                    throw new error_1.ToolkitError(`Unexpected rollback choice: ${cloudFormationStack.stackStatus.rollbackChoice}`);
            }
            const monitor = new stack_events_1.StackActivityMonitor({
                cfn,
                stack: options.stack,
                stackName: deployName,
                ioHelper: this.ioHelper,
            });
            await monitor.start();
            let stackErrorMessage = undefined;
            let finalStackState = cloudFormationStack;
            try {
                const successStack = await (0, cloudformation_1.stabilizeStack)(cfn, this.ioHelper, deployName);
                // This shouldn't really happen, but catch it anyway. You never know.
                if (!successStack) {
                    throw new error_1.ToolkitError('Stack deploy failed (the stack disappeared while we were rolling it back)');
                }
                finalStackState = successStack;
                const errors = monitor.errors.join(', ');
                if (errors) {
                    stackErrorMessage = errors;
                }
            }
            catch (e) {
                stackErrorMessage = suffixWithErrors((0, util_1.formatErrorMessage)(e), monitor.errors);
            }
            finally {
                await monitor.stop();
            }
            if (finalStackState.stackStatus.isRollbackSuccess || !stackErrorMessage) {
                return { success: true };
            }
            // Either we need to ignore some resources to continue the rollback, or something went wrong
            if (finalStackState.stackStatus.rollbackChoice === stack_events_1.RollbackChoice.CONTINUE_UPDATE_ROLLBACK && options.force) {
                // Do another loop-de-loop
                continue;
            }
            throw new error_1.ToolkitError(`${stackErrorMessage} (fix problem and retry, or orphan these resources using --orphan or --force)`);
        }
        throw new error_1.ToolkitError("Rollback did not finish after a large number of iterations; stopping because it looks like we're not making progress anymore. You can retry if rollback was progressing as expected.");
    }
    async destroyStack(options) {
        var _a;
        const env = await this.envs.accessStackForMutableStackOperations(options.stack);
        const executionRoleArn = await env.replacePlaceholders((_a = options.roleArn) !== null && _a !== void 0 ? _a : options.stack.cloudFormationExecutionRoleArn);
        return (0, deploy_stack_1.destroyStack)({
            sdk: env.sdk,
            roleArn: executionRoleArn,
            stack: options.stack,
            deployName: options.deployName,
        }, this.ioHelper);
    }
    async stackExists(options) {
        var _a;
        let env;
        if (options.tryLookupRole) {
            env = await this.envs.accessStackForLookupBestEffort(options.stack);
        }
        else {
            env = await this.envs.accessStackForReadOnlyStackOperations(options.stack);
        }
        const stack = await cloudformation_1.CloudFormationStack.lookup(env.sdk.cloudFormation(), (_a = options.deployName) !== null && _a !== void 0 ? _a : options.stack.stackName);
        return stack.exists;
    }
    /**
     * Build a single asset from an asset manifest
     *
     * If an assert manifest artifact is given, the bootstrap stack version
     * will be validated according to the constraints in that manifest artifact.
     * If that is not necessary, `'no-version-validation'` can be passed.
     */
    // eslint-disable-next-line max-len
    async buildSingleAsset(assetArtifact, assetManifest, asset, options) {
        if (assetArtifact !== 'no-version-validation') {
            const env = await this.envs.accessStackForReadOnlyStackOperations(options.stack);
            await this.validateBootstrapStackVersion(options.stack.stackName, assetArtifact.requiresBootstrapStackVersion, assetArtifact.bootstrapStackVersionSsmParameter, env.resources);
        }
        const resolvedEnvironment = await this.envs.resolveStackEnvironment(options.stack);
        const publisher = this.cachedPublisher(assetManifest, resolvedEnvironment, options.stackName);
        await publisher.buildEntry(asset);
        if (publisher.hasFailures) {
            throw new error_1.ToolkitError(`Failed to build asset ${asset.displayName(false)}`);
        }
    }
    /**
     * Publish a single asset from an asset manifest
     */
    async publishSingleAsset(assetManifest, asset, options) {
        const stackEnv = await this.envs.resolveStackEnvironment(options.stack);
        // No need to validate anymore, we already did that during build
        const publisher = this.cachedPublisher(assetManifest, stackEnv, options.stackName);
        await publisher.publishEntry(asset, {
            allowCrossAccount: await this.allowCrossAccountAssetPublishingForEnv(options.stack),
            force: options.forcePublish,
        });
        if (publisher.hasFailures) {
            throw new error_1.ToolkitError(`Failed to publish asset ${asset.displayName(true)}`);
        }
    }
    async allowCrossAccountAssetPublishingForEnv(stack) {
        if (this._allowCrossAccountAssetPublishing === undefined) {
            const env = await this.envs.accessStackForReadOnlyStackOperations(stack);
            this._allowCrossAccountAssetPublishing = await (0, checks_1.determineAllowCrossAccountAssetPublishing)(env.sdk, this.ioHelper, this.props.toolkitStackName);
        }
        return this._allowCrossAccountAssetPublishing;
    }
    /**
     * Return whether a single asset has been published already
     */
    async isSingleAssetPublished(assetManifest, asset, options) {
        const stackEnv = await this.envs.resolveStackEnvironment(options.stack);
        const publisher = this.cachedPublisher(assetManifest, stackEnv, options.stackName);
        return publisher.isEntryPublished(asset);
    }
    /**
     * Validate that the bootstrap stack has the right version for this stack
     *
     * Call into envResources.validateVersion, but prepend the stack name in case of failure.
     */
    async validateBootstrapStackVersion(stackName, requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter, envResources) {
        try {
            await envResources.validateVersion(requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter);
        }
        catch (e) {
            throw new error_1.ToolkitError(`${stackName}: ${(0, util_1.formatErrorMessage)(e)}`);
        }
    }
    cachedPublisher(assetManifest, env, stackName) {
        const existing = this.publisherCache.get(assetManifest);
        if (existing) {
            return existing;
        }
        const prefix = stackName ? `${chalk.bold(stackName)}: ` : '';
        const publisher = new cdk_assets.AssetPublishing(assetManifest, {
            // The AssetPublishing class takes care of role assuming etc, so it's okay to
            // give it a direct `SdkProvider`.
            aws: new asset_publishing_1.PublishingAws(this.assetSdkProvider, env),
            progressListener: new ParallelSafeAssetProgress(prefix, this.ioHelper),
        });
        this.publisherCache.set(assetManifest, publisher);
        return publisher;
    }
}
exports.Deployments = Deployments;
/**
 * Asset progress that doesn't do anything with percentages (currently)
 */
class ParallelSafeAssetProgress extends asset_publishing_1.BasePublishProgressListener {
    constructor(prefix, ioHelper) {
        super(ioHelper);
        this.prefix = prefix;
    }
    getMessage(type, event) {
        return `${this.prefix}${type}: ${event.message}`;
    }
}
function suffixWithErrors(msg, errors) {
    return errors && errors.length > 0 ? `${msg}: ${errors.join(', ')}` : msg;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95bWVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkZXBsb3ltZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBb0M7QUFFcEMseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixxRUFBZ0U7QUFDaEUseURBRzRCO0FBQzVCLHFDQUFxRTtBQU1yRSxxREFJMEI7QUFDMUIsaURBQTJEO0FBRzNELGlFQUlnQztBQUVoQyxpREFBaUQ7QUFDakQsK0NBQW1EO0FBQ25ELHFDQUFnRDtBQUVoRCxnREFBOEU7QUFFOUUsa0RBQXlGO0FBRXpGLGtEQUE2RDtBQUM3RCw2RUFBb0U7QUFFcEUsTUFBTSxvQ0FBb0MsR0FBRyxFQUFFLENBQUM7QUF1UWhEOzs7O0dBSUc7QUFDSCxNQUFhLFdBQVc7SUE2QnRCLFlBQTZCLEtBQXVCOztRQUF2QixVQUFLLEdBQUwsS0FBSyxDQUFrQjtRQU5uQyxtQkFBYyxHQUFHLElBQUksR0FBRyxFQUF3RCxDQUFDO1FBT2hHLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQzFDLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ2hELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQztRQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksK0JBQWlCLENBQy9CLEtBQUssQ0FBQyxXQUFXLEVBQ2pCLE1BQUEsS0FBSyxDQUFDLGdCQUFnQixtQ0FBSSx5Q0FBMEIsRUFDcEQsSUFBSSxDQUFDLFFBQVEsQ0FDZCxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLGtCQUFrQixDQUFDLEtBQXdDO1FBQ3RFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRU0sS0FBSyxDQUFDLG1DQUFtQyxDQUM5QyxpQkFBb0QsRUFDcEQs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TSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzVFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNka19hc3NldHMgZnJvbSAnY2RrLWFzc2V0cyc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0QnVpbGRlciB9IGZyb20gJy4vYXNzZXQtbWFuaWZlc3QtYnVpbGRlcic7XG5pbXBvcnQge1xuICBCYXNlUHVibGlzaFByb2dyZXNzTGlzdGVuZXIsXG4gIFB1Ymxpc2hpbmdBd3MsXG59IGZyb20gJy4vYXNzZXQtcHVibGlzaGluZyc7XG5pbXBvcnQgeyBkZXRlcm1pbmVBbGxvd0Nyb3NzQWNjb3VudEFzc2V0UHVibGlzaGluZyB9IGZyb20gJy4vY2hlY2tzJztcbmltcG9ydCB0eXBlIHtcbiAgUmVzb3VyY2VzVG9JbXBvcnQsXG4gIFRlbXBsYXRlLFxuICBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMsXG59IGZyb20gJy4vY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHtcbiAgQ2xvdWRGb3JtYXRpb25TdGFjayxcbiAgc3RhYmlsaXplU3RhY2ssXG4gIHVwbG9hZFN0YWNrVGVtcGxhdGVBc3NldHMsXG59IGZyb20gJy4vY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgZGVwbG95U3RhY2ssIGRlc3Ryb3lTdGFjayB9IGZyb20gJy4vZGVwbG95LXN0YWNrJztcbmltcG9ydCB0eXBlIHsgRGVwbG95bWVudE1ldGhvZCB9IGZyb20gJy4vZGVwbG95bWVudC1tZXRob2QnO1xuaW1wb3J0IHR5cGUgeyBEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4vZGVwbG95bWVudC1yZXN1bHQnO1xuaW1wb3J0IHtcbiAgbG9hZEN1cnJlbnRUZW1wbGF0ZSxcbiAgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MsXG4gIHR5cGUgUm9vdFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyxcbn0gZnJvbSAnLi9uZXN0ZWQtc3RhY2staGVscGVycyc7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi8uLi9jbGkvbWVzc2FnZXMnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB0eXBlIHsgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aC9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgdHlwZSBFbnZpcm9ubWVudFJlc291cmNlcywgRW52aXJvbm1lbnRBY2Nlc3MgfSBmcm9tICcuLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgdHlwZSB7IEhvdHN3YXBNb2RlLCBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMgfSBmcm9tICcuLi9ob3Rzd2FwL2NvbW1vbic7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5TW9uaXRvciwgU3RhY2tFdmVudFBvbGxlciwgUm9sbGJhY2tDaG9pY2UgfSBmcm9tICcuLi9zdGFjay1ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBUYWcgfSBmcm9tICcuLi90YWdzJztcbmltcG9ydCB7IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FIH0gZnJvbSAnLi4vdG9vbGtpdC1pbmZvJztcbmltcG9ydCB7IG1ha2VCb2R5UGFyYW1ldGVyIH0gZnJvbSAnLi4vdXRpbC90ZW1wbGF0ZS1ib2R5LXBhcmFtZXRlcic7XG5cbmNvbnN0IEJPT1RTVFJBUF9TVEFDS19WRVJTSU9OX0ZPUl9ST0xMQkFDSyA9IDIzO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveVN0YWNrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTdGFjayB0byBkZXBsb3lcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGlvbiByb2xlIGZvciB0aGUgZGVwbG95bWVudCAocGFzcyB0aHJvdWdoIHRvIENsb3VkRm9ybWF0aW9uKVxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEN1cnJlbnQgcm9sZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogVG9waWMgQVJOcyB0byBzZW5kIGEgbWVzc2FnZSB3aGVuIGRlcGxveW1lbnQgZmluaXNoZXMgKHBhc3MgdGhyb3VnaCB0byBDbG91ZEZvcm1hdGlvbilcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBub3RpZmljYXRpb25zXG4gICAqL1xuICByZWFkb25seSBub3RpZmljYXRpb25Bcm5zPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG5hbWUgdW5kZXIgd2hpY2ggc3RhY2sgd2lsbCBiZSBkZXBsb3llZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFVzZSBhcnRpZmFjdCBkZWZhdWx0XG4gICAqL1xuICByZWFkb25seSBkZXBsb3lOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSB0b29sa2l0IHN0YWNrLCBpZiBub3QgdGhlIGRlZmF1bHQgbmFtZVxuICAgKlxuICAgKiBAZGVmYXVsdCAnQ0RLVG9vbGtpdCdcbiAgICovXG4gIHJlYWRvbmx5IHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgSURzIHdoaWNoIHNob3VsZCBOT1QgYmUgYnVpbHQgb3IgdXBsb2FkZWRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBCdWlsZCBhbGwgYXNzZXRzXG4gICAqL1xuICByZWFkb25seSByZXVzZUFzc2V0cz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBTdGFjayB0YWdzIChwYXNzIHRocm91Z2ggdG8gQ2xvdWRGb3JtYXRpb24pXG4gICAqL1xuICByZWFkb25seSB0YWdzPzogVGFnW107XG5cbiAgLyoqXG4gICAqIFN0YWdlIHRoZSBjaGFuZ2Ugc2V0IGJ1dCBkb24ndCBleGVjdXRlIGl0XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gdHJ1ZVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgJ2RlcGxveW1lbnRNZXRob2QnIGluc3RlYWRcbiAgICovXG4gIHJlYWRvbmx5IGV4ZWN1dGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBuYW1lIHRvIHVzZSBmb3IgdGhlIENsb3VkRm9ybWF0aW9uIGNoYW5nZSBzZXQuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgYSBuYW1lIHdpbGwgYmUgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSAnZGVwbG95bWVudE1ldGhvZCcgaW5zdGVhZFxuICAgKi9cbiAgcmVhZG9ubHkgY2hhbmdlU2V0TmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBkZXBsb3ltZW50IG1ldGhvZCAoZGlyZWN0IG9yIHVzaW5nIGEgY2hhbmdlIHNldClcbiAgICpcbiAgICogQGRlZmF1bHQgLSBDaGFuZ2Ugc2V0IHdpdGggZGVmYXVsdCBvcHRpb25zXG4gICAqL1xuICByZWFkb25seSBkZXBsb3ltZW50TWV0aG9kPzogRGVwbG95bWVudE1ldGhvZDtcblxuICAvKipcbiAgICogRm9yY2UgZGVwbG95bWVudCwgZXZlbiBpZiB0aGUgZGVwbG95ZWQgdGVtcGxhdGUgaXMgaWRlbnRpY2FsIHRvIHRoZSBvbmUgd2UgYXJlIGFib3V0IHRvIGRlcGxveS5cbiAgICogQGRlZmF1bHQgZmFsc2UgZGVwbG95bWVudCB3aWxsIGJlIHNraXBwZWQgaWYgdGhlIHRlbXBsYXRlIGlzIGlkZW50aWNhbFxuICAgKi9cbiAgcmVhZG9ubHkgZm9yY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFeHRyYSBwYXJhbWV0ZXJzIGZvciBDbG91ZEZvcm1hdGlvblxuICAgKiBAZGVmYXVsdCAtIG5vIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGVtcGxhdGVcbiAgICovXG4gIHJlYWRvbmx5IHBhcmFtZXRlcnM/OiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcblxuICAvKipcbiAgICogVXNlIHByZXZpb3VzIHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBJZiBub3Qgc2V0LCBhbGwgcGFyYW1ldGVycyBtdXN0IGJlIHNwZWNpZmllZCBmb3IgZXZlcnkgZGVwbG95bWVudC5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdXNlUHJldmlvdXNQYXJhbWV0ZXJzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUm9sbGJhY2sgZmFpbGVkIGRlcGxveW1lbnRzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHJvbGxiYWNrPzogYm9vbGVhbjtcblxuICAvKlxuICAgKiBXaGV0aGVyIHRvIHBlcmZvcm0gYSAnaG90c3dhcCcgZGVwbG95bWVudC5cbiAgICogQSAnaG90c3dhcCcgZGVwbG95bWVudCB3aWxsIGF0dGVtcHQgdG8gc2hvcnQtY2lyY3VpdCBDbG91ZEZvcm1hdGlvblxuICAgKiBhbmQgdXBkYXRlIHRoZSBhZmZlY3RlZCByZXNvdXJjZXMgbGlrZSBMYW1iZGEgZnVuY3Rpb25zIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGBIb3Rzd2FwTW9kZS5GVUxMX0RFUExPWU1FTlRgIGZvciByZWd1bGFyIGRlcGxveW1lbnRzLCBgSG90c3dhcE1vZGUuSE9UU1dBUF9PTkxZYCBmb3IgJ3dhdGNoJyBkZXBsb3ltZW50c1xuICAgKi9cbiAgcmVhZG9ubHkgaG90c3dhcD86IEhvdHN3YXBNb2RlO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0aWVzIHRoYXQgY29uZmlndXJlIGhvdHN3YXAgYmVoYXZpb3JcbiAgICovXG4gIHJlYWRvbmx5IGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcz86IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcztcblxuICAvKipcbiAgICogVGhlIGV4dHJhIHN0cmluZyB0byBhcHBlbmQgdG8gdGhlIFVzZXItQWdlbnQgaGVhZGVyIHdoZW4gcGVyZm9ybWluZyBBV1MgU0RLIGNhbGxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vdGhpbmcgZXh0cmEgaXMgYXBwZW5kZWQgdG8gdGhlIFVzZXItQWdlbnQgaGVhZGVyXG4gICAqL1xuICByZWFkb25seSBleHRyYVVzZXJBZ2VudD86IHN0cmluZztcblxuICAvKipcbiAgICogTGlzdCBvZiBleGlzdGluZyByZXNvdXJjZXMgdG8gYmUgSU1QT1JURUQgaW50byB0aGUgc3RhY2ssIGluc3RlYWQgb2YgYmVpbmcgQ1JFQVRFRFxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VzVG9JbXBvcnQ/OiBSZXNvdXJjZXNUb0ltcG9ydDtcblxuICAvKipcbiAgICogSWYgcHJlc2VudCwgdXNlIHRoaXMgZ2l2ZW4gdGVtcGxhdGUgaW5zdGVhZCBvZiB0aGUgc3RvcmVkIG9uZVxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFVzZSB0aGUgc3RvcmVkIHRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSBvdmVycmlkZVRlbXBsYXRlPzogYW55O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGJ1aWxkL3B1Ymxpc2ggYXNzZXRzIGluIHBhcmFsbGVsXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWUgVG8gcmVtYWluIGJhY2t3YXJkIGNvbXBhdGlibGUuXG4gICAqL1xuICByZWFkb25seSBhc3NldFBhcmFsbGVsaXNtPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBkZXBsb3kgaWYgdGhlIGFwcCBjb250YWlucyBubyBzdGFja3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmVOb1N0YWNrcz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm9sbGJhY2tTdGFja09wdGlvbnMge1xuICAvKipcbiAgICogU3RhY2sgdG8gcm9sbCBiYWNrXG4gICAqL1xuICByZWFkb25seSBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRpb24gcm9sZSBmb3IgdGhlIGRlcGxveW1lbnQgKHBhc3MgdGhyb3VnaCB0byBDbG91ZEZvcm1hdGlvbilcbiAgICpcbiAgICogQGRlZmF1bHQgLSBDdXJyZW50IHJvbGVcbiAgICovXG4gIHJlYWRvbmx5IHJvbGVBcm4/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERvbid0IHNob3cgc3RhY2sgZGVwbG95bWVudCBldmVudHMsIGp1c3Qgd2FpdFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgcXVpZXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBvbiBhIENJIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgY2k/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSB0b29sa2l0IHN0YWNrLCBpZiBub3QgdGhlIGRlZmF1bHQgbmFtZVxuICAgKlxuICAgKiBAZGVmYXVsdCAnQ0RLVG9vbGtpdCdcbiAgICovXG4gIHJlYWRvbmx5IHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZm9yY2UgYSByb2xsYmFjayBvciBub3RcbiAgICpcbiAgICogRm9yY2luZyBhIHJvbGxiYWNrIHdpbGwgb3JwaGFuIGFsbCB1bmRlbGV0YWJsZSByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBmb3JjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE9ycGhhbiB0aGUgcmVzb3VyY2VzIHdpdGggdGhlIGdpdmVuIGxvZ2ljYWwgSURzXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gb3JwaGFuaW5nXG4gICAqL1xuICByZWFkb25seSBvcnBoYW5Mb2dpY2FsSWRzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdmFsaWRhdGUgdGhlIHZlcnNpb24gb2YgdGhlIGJvb3RzdHJhcCBzdGFjayBwZXJtaXNzaW9uc1xuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSB2YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm9sbGJhY2tTdGFja1Jlc3VsdCB7XG4gIHJlYWRvbmx5IG5vdEluUm9sbGJhY2thYmxlU3RhdGU/OiBib29sZWFuO1xuICByZWFkb25seSBzdWNjZXNzPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEFzc2V0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTdGFjayB3aXRoIGFzc2V0cyB0byBidWlsZC5cbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGlvbiByb2xlIGZvciB0aGUgYnVpbGRpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQ3VycmVudCByb2xlXG4gICAqL1xuICByZWFkb25seSByb2xlQXJuPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkU3RhY2tBc3NldHNPcHRpb25zIGV4dGVuZHMgQXNzZXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFN0YWNrIG5hbWUgdGhpcyBhc3NldCBpcyBmb3JcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrTmFtZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFB1Ymxpc2hTdGFja0Fzc2V0c09wdGlvbnMgZXh0ZW5kcyBBc3NldE9wdGlvbnMge1xuICAvKipcbiAgICogU3RhY2sgbmFtZSB0aGlzIGFzc2V0IGlzIGZvclxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgcHVibGlzaCwgZXZlbiBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZm9yY2VQdWJsaXNoPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXN0cm95U3RhY2tPcHRpb25zIHtcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbiAgZGVwbG95TmFtZT86IHN0cmluZztcbiAgcm9sZUFybj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFja0V4aXN0c09wdGlvbnMge1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuICBkZXBsb3lOYW1lPzogc3RyaW5nO1xuICB0cnlMb29rdXBSb2xlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXBsb3ltZW50c1Byb3BzIHtcbiAgcmVhZG9ubHkgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuICByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nO1xuICByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG59XG5cbi8qKlxuICogU2NvcGUgZm9yIGEgc2luZ2xlIHNldCBvZiBkZXBsb3ltZW50cyBmcm9tIGEgc2V0IG9mIENsb3VkIEFzc2VtYmx5IEFydGlmYWN0c1xuICpcbiAqIE1hbmFnZXMgbG9va3VwIG9mIFNES3MsIEJvb3RzdHJhcCBzdGFja3MsIGV0Yy5cbiAqL1xuZXhwb3J0IGNsYXNzIERlcGxveW1lbnRzIHtcbiAgcHVibGljIHJlYWRvbmx5IGVudnM6IEVudmlyb25tZW50QWNjZXNzO1xuXG4gIC8qKlxuICAgKiBTREsgcHJvdmlkZXIgZm9yIGFzc2V0IHB1Ymxpc2hpbmcgKGRvIG5vdCB1c2UgZm9yIGFueXRoaW5nIGVsc2UpLlxuICAgKlxuICAgKiBUaGlzIFNESyBwcm92aWRlciBpcyBvbmx5IGFsbG93ZWQgdG8gYmUgdXNlZCBmb3IgdGhhdCBwdXJwb3NlLCBub3RoaW5nIGVsc2UuXG4gICAqXG4gICAqIEl0J3Mgbm90IGEgZGlmZmVyZW50IG9iamVjdCwgYnV0IHRoZSBmaWVsZCBuYW1lIHNob3VsZCBpbXBseSB0aGF0IHRoaXNcbiAgICogb2JqZWN0IHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgZXhjZXB0IHRvIHBhc3MgdG8gYXNzZXQgaGFuZGxpbmcgcm91dGluZXMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGFzc2V0U2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuXG4gIC8qKlxuICAgKiBTREsgcHJvdmlkZXIgZm9yIHBhc3NpbmcgdG8gZGVwbG95U3RhY2tcbiAgICpcbiAgICogVGhpcyBTREsgcHJvdmlkZXIgaXMgb25seSBhbGxvd2VkIHRvIGJlIHVzZWQgZm9yIHRoYXQgcHVycG9zZSwgbm90aGluZyBlbHNlLlxuICAgKlxuICAgKiBJdCdzIG5vdCBhIGRpZmZlcmVudCBvYmplY3QsIGJ1dCB0aGUgZmllbGQgbmFtZSBzaG91bGQgaW1wbHkgdGhhdCB0aGlzXG4gICAqIG9iamVjdCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGV4Y2VwdCB0byBwYXNzIHRvIGBkZXBsb3lTdGFja2AuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGRlcGxveVN0YWNrU2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgcHVibGlzaGVyQ2FjaGUgPSBuZXcgTWFwPGNka19hc3NldHMuQXNzZXRNYW5pZmVzdCwgY2RrX2Fzc2V0cy5Bc3NldFB1Ymxpc2hpbmc+KCk7XG5cbiAgcHJpdmF0ZSBfYWxsb3dDcm9zc0FjY291bnRBc3NldFB1Ymxpc2hpbmc6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogRGVwbG95bWVudHNQcm9wcykge1xuICAgIHRoaXMuYXNzZXRTZGtQcm92aWRlciA9IHByb3BzLnNka1Byb3ZpZGVyO1xuICAgIHRoaXMuZGVwbG95U3RhY2tTZGtQcm92aWRlciA9IHByb3BzLnNka1Byb3ZpZGVyO1xuICAgIHRoaXMuaW9IZWxwZXIgPSBwcm9wcy5pb0hlbHBlcjtcbiAgICB0aGlzLmVudnMgPSBuZXcgRW52aXJvbm1lbnRBY2Nlc3MoXG4gICAgICBwcm9wcy5zZGtQcm92aWRlcixcbiAgICAgIHByb3BzLnRvb2xraXRTdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUsXG4gICAgICB0aGlzLmlvSGVscGVyLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIGVudmlyb25tZW50IGZvciBhIHN0YWNrLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlc29sdmVFbnZpcm9ubWVudChzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudD4ge1xuICAgIHJldHVybiB0aGlzLmVudnMucmVzb2x2ZVN0YWNrRW52aXJvbm1lbnQoc3RhY2spO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzKFxuICAgIHJvb3RTdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gICAgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZTogYm9vbGVhbiA9IGZhbHNlLFxuICApOiBQcm9taXNlPFJvb3RUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3M+IHtcbiAgICBjb25zdCBlbnYgPSBhd2FpdCB0aGlzLmVudnMuYWNjZXNzU3RhY2tGb3JMb29rdXBCZXN0RWZmb3J0KHJvb3RTdGFja0FydGlmYWN0KTtcbiAgICByZXR1cm4gbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3Mocm9vdFN0YWNrQXJ0aWZhY3QsIGVudi5zZGssIHJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGUpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KTogUHJvbWlzZTxUZW1wbGF0ZT4ge1xuICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KGRlYnVnKGBSZWFkaW5nIGV4aXN0aW5nIHRlbXBsYXRlIGZvciBzdGFjayAke3N0YWNrQXJ0aWZhY3QuZGlzcGxheU5hbWV9LmApKTtcbiAgICBjb25zdCBlbnYgPSBhd2FpdCB0aGlzLmVudnMuYWNjZXNzU3RhY2tGb3JMb29rdXBCZXN0RWZmb3J0KHN0YWNrQXJ0aWZhY3QpO1xuICAgIHJldHVybiBsb2FkQ3VycmVudFRlbXBsYXRlKHN0YWNrQXJ0aWZhY3QsIGVudi5zZGspO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyhcbiAgICBzdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gICk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzPiB7XG4gICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoZGVidWcoYFJldHJpZXZpbmcgdGVtcGxhdGUgc3VtbWFyeSBmb3Igc3RhY2sgJHtzdGFja0FydGlmYWN0LmRpc3BsYXlOYW1lfS5gKSk7XG4gICAgLy8gQ3VycmVudGx5LCBuZWVkcyB0byB1c2UgYGRlcGxveS1yb2xlYCBzaW5jZSBpdCBtYXkgbmVlZCB0byByZWFkIHRlbXBsYXRlcyBpbiB0aGUgc3RhZ2luZ1xuICAgIC8vIGJ1Y2tldCB3aGljaCBoYXZlIGJlZW4gZW5jcnlwdGVkIHdpdGggYSBLTVMga2V5IChhbmQgbG9va3VwLXJvbGUgbWF5IG5vdCByZWFkIGVuY3J5cHRlZCB0aGluZ3MpXG4gICAgY29uc3QgZW52ID0gYXdhaXQgdGhpcy5lbnZzLmFjY2Vzc1N0YWNrRm9yUmVhZE9ubHlTdGFja09wZXJhdGlvbnMoc3RhY2tBcnRpZmFjdCk7XG4gICAgY29uc3QgY2ZuID0gZW52LnNkay5jbG91ZEZvcm1hdGlvbigpO1xuXG4gICAgYXdhaXQgdXBsb2FkU3RhY2tUZW1wbGF0ZUFzc2V0cyhzdGFja0FydGlmYWN0LCB0aGlzKTtcblxuICAgIC8vIFVwbG9hZCB0aGUgdGVtcGxhdGUsIGlmIG5lY2Vzc2FyeSwgYmVmb3JlIHBhc3NpbmcgaXQgdG8gQ0ZOXG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBBc3NldE1hbmlmZXN0QnVpbGRlcigpO1xuICAgIGNvbnN0IGNmblBhcmFtID0gYXdhaXQgbWFrZUJvZHlQYXJhbWV0ZXIoXG4gICAgICBzdGFja0FydGlmYWN0LFxuICAgICAgZW52LnJlc29sdmVkRW52aXJvbm1lbnQsXG4gICAgICBidWlsZGVyLFxuICAgICAgZW52LnJlc291cmNlcyk7XG5cbiAgICAvLyBJZiB0aGUgYG1ha2VCb2R5UGFyYW1ldGVyYCBiZWZvcmUgdGhpcyBhZGRlZCBhc3NldHMsIG1ha2Ugc3VyZSB0byBwdWJsaXNoIHRoZW0gYmVmb3JlXG4gICAgLy8gY2FsbGluZyB0aGUgQVBJLlxuICAgIGNvbnN0IGFkZGVkQXNzZXRzID0gYnVpbGRlci50b01hbmlmZXN0KHN0YWNrQXJ0aWZhY3QuYXNzZW1ibHkuZGlyZWN0b3J5KTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFkZGVkQXNzZXRzLmVudHJpZXMpIHtcbiAgICAgIGF3YWl0IHRoaXMuYnVpbGRTaW5nbGVBc3NldCgnbm8tdmVyc2lvbi12YWxpZGF0aW9uJywgYWRkZWRBc3NldHMsIGVudHJ5LCB7XG4gICAgICAgIHN0YWNrOiBzdGFja0FydGlmYWN0LFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hTaW5nbGVBc3NldChhZGRlZEFzc2V0cywgZW50cnksIHtcbiAgICAgICAgc3RhY2s6IHN0YWNrQXJ0aWZhY3QsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNmbi5nZXRUZW1wbGF0ZVN1bW1hcnkoY2ZuUGFyYW0pO1xuICAgIGlmICghcmVzcG9uc2UuUmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShkZWJ1ZygnR2V0VGVtcGxhdGVTdW1tYXJ5IEFQSSBjYWxsIGRpZCBub3QgcmV0dXJuIFwiUmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzXCInKSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5SZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMgPz8gW107XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVwbG95U3RhY2sob3B0aW9uczogRGVwbG95U3RhY2tPcHRpb25zKTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIGxldCBkZXBsb3ltZW50TWV0aG9kID0gb3B0aW9ucy5kZXBsb3ltZW50TWV0aG9kO1xuICAgIGlmIChvcHRpb25zLmNoYW5nZVNldE5hbWUgfHwgb3B0aW9ucy5leGVjdXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChkZXBsb3ltZW50TWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgICAgXCJZb3UgY2Fubm90IHN1cHBseSBib3RoICdkZXBsb3ltZW50TWV0aG9kJyBhbmQgJ2NoYW5nZVNldE5hbWUvZXhlY3V0ZScuIFN1cHBseSBvbmUgb3IgdGhlIG90aGVyLlwiLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVwbG95bWVudE1ldGhvZCA9IHtcbiAgICAgICAgbWV0aG9kOiAnY2hhbmdlLXNldCcsXG4gICAgICAgIGNoYW5nZVNldE5hbWU6IG9wdGlvbnMuY2hhbmdlU2V0TmFtZSxcbiAgICAgICAgZXhlY3V0ZTogb3B0aW9ucy5leGVjdXRlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnYgPSBhd2FpdCB0aGlzLmVudnMuYWNjZXNzU3RhY2tGb3JNdXRhYmxlU3RhY2tPcGVyYXRpb25zKG9wdGlvbnMuc3RhY2spO1xuXG4gICAgLy8gRG8gYSB2ZXJpZmljYXRpb24gb2YgdGhlIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uXG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICAgIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLFxuICAgICAgb3B0aW9ucy5zdGFjay5yZXF1aXJlc0Jvb3RzdHJhcFN0YWNrVmVyc2lvbixcbiAgICAgIG9wdGlvbnMuc3RhY2suYm9vdHN0cmFwU3RhY2tWZXJzaW9uU3NtUGFyYW1ldGVyLFxuICAgICAgZW52LnJlc291cmNlcyk7XG5cbiAgICBjb25zdCBleGVjdXRpb25Sb2xlQXJuID0gYXdhaXQgZW52LnJlcGxhY2VQbGFjZWhvbGRlcnMob3B0aW9ucy5yb2xlQXJuID8/IG9wdGlvbnMuc3RhY2suY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Sb2xlQXJuKTtcblxuICAgIHJldHVybiBkZXBsb3lTdGFjayh7XG4gICAgICBzdGFjazogb3B0aW9ucy5zdGFjayxcbiAgICAgIHJlc29sdmVkRW52aXJvbm1lbnQ6IGVudi5yZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgZGVwbG95TmFtZTogb3B0aW9ucy5kZXBsb3lOYW1lLFxuICAgICAgbm90aWZpY2F0aW9uQXJuczogb3B0aW9ucy5ub3RpZmljYXRpb25Bcm5zLFxuICAgICAgc2RrOiBlbnYuc2RrLFxuICAgICAgc2RrUHJvdmlkZXI6IHRoaXMuZGVwbG95U3RhY2tTZGtQcm92aWRlcixcbiAgICAgIHJvbGVBcm46IGV4ZWN1dGlvblJvbGVBcm4sXG4gICAgICByZXVzZUFzc2V0czogb3B0aW9ucy5yZXVzZUFzc2V0cyxcbiAgICAgIGVudlJlc291cmNlczogZW52LnJlc291cmNlcyxcbiAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyxcbiAgICAgIGRlcGxveW1lbnRNZXRob2QsXG4gICAgICBmb3JjZTogb3B0aW9ucy5mb3JjZSxcbiAgICAgIHBhcmFtZXRlcnM6IG9wdGlvbnMucGFyYW1ldGVycyxcbiAgICAgIHVzZVByZXZpb3VzUGFyYW1ldGVyczogb3B0aW9ucy51c2VQcmV2aW91c1BhcmFtZXRlcnMsXG4gICAgICByb2xsYmFjazogb3B0aW9ucy5yb2xsYmFjayxcbiAgICAgIGhvdHN3YXA6IG9wdGlvbnMuaG90c3dhcCxcbiAgICAgIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogb3B0aW9ucy5ob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gICAgICBleHRyYVVzZXJBZ2VudDogb3B0aW9ucy5leHRyYVVzZXJBZ2VudCxcbiAgICAgIHJlc291cmNlc1RvSW1wb3J0OiBvcHRpb25zLnJlc291cmNlc1RvSW1wb3J0LFxuICAgICAgb3ZlcnJpZGVUZW1wbGF0ZTogb3B0aW9ucy5vdmVycmlkZVRlbXBsYXRlLFxuICAgICAgYXNzZXRQYXJhbGxlbGlzbTogb3B0aW9ucy5hc3NldFBhcmFsbGVsaXNtLFxuICAgIH0sIHRoaXMuaW9IZWxwZXIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJvbGxiYWNrU3RhY2sob3B0aW9uczogUm9sbGJhY2tTdGFja09wdGlvbnMpOiBQcm9taXNlPFJvbGxiYWNrU3RhY2tSZXN1bHQ+IHtcbiAgICBsZXQgcmVzb3VyY2VzVG9Ta2lwOiBzdHJpbmdbXSA9IG9wdGlvbnMub3JwaGFuTG9naWNhbElkcyA/PyBbXTtcbiAgICBpZiAob3B0aW9ucy5mb3JjZSAmJiByZXNvdXJjZXNUb1NraXAubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQ2Fubm90IGNvbWJpbmUgLS1mb3JjZSB3aXRoIC0tb3JwaGFuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZW52ID0gYXdhaXQgdGhpcy5lbnZzLmFjY2Vzc1N0YWNrRm9yTXV0YWJsZVN0YWNrT3BlcmF0aW9ucyhvcHRpb25zLnN0YWNrKTtcblxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uID8/IHRydWUpIHtcbiAgICAgIC8vIERvIGEgdmVyaWZpY2F0aW9uIG9mIHRoZSBib290c3RyYXAgc3RhY2sgdmVyc2lvblxuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICAgICAgb3B0aW9ucy5zdGFjay5zdGFja05hbWUsXG4gICAgICAgIEJPT1RTVFJBUF9TVEFDS19WRVJTSU9OX0ZPUl9ST0xMQkFDSyxcbiAgICAgICAgb3B0aW9ucy5zdGFjay5ib290c3RyYXBTdGFja1ZlcnNpb25Tc21QYXJhbWV0ZXIsXG4gICAgICAgIGVudi5yZXNvdXJjZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGNmbiA9IGVudi5zZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBkZXBsb3lOYW1lID0gb3B0aW9ucy5zdGFjay5zdGFja05hbWU7XG5cbiAgICAvLyBXZSBsb29wIGluIGNhc2Ugb2YgYC0tZm9yY2VgIGFuZCB0aGUgc3RhY2sgZW5kcyB1cCBpbiBgQ09OVElOVUVfVVBEQVRFX1JPTExCQUNLYC5cbiAgICBsZXQgbWF4TG9vcHMgPSAxMDtcbiAgICB3aGlsZSAobWF4TG9vcHMtLSkge1xuICAgICAgbGV0IGNsb3VkRm9ybWF0aW9uU3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIGRlcGxveU5hbWUpO1xuXG4gICAgICBjb25zdCBleGVjdXRpb25Sb2xlQXJuID0gYXdhaXQgZW52LnJlcGxhY2VQbGFjZWhvbGRlcnMob3B0aW9ucy5yb2xlQXJuID8/IG9wdGlvbnMuc3RhY2suY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Sb2xlQXJuKTtcblxuICAgICAgc3dpdGNoIChjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrU3RhdHVzLnJvbGxiYWNrQ2hvaWNlKSB7XG4gICAgICAgIGNhc2UgUm9sbGJhY2tDaG9pY2UuTk9ORTpcbiAgICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeSh3YXJuKGBTdGFjayAke2RlcGxveU5hbWV9IGRvZXMgbm90IG5lZWQgYSByb2xsYmFjazogJHtjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrU3RhdHVzfWApKTtcbiAgICAgICAgICByZXR1cm4geyBub3RJblJvbGxiYWNrYWJsZVN0YXRlOiB0cnVlIH07XG5cbiAgICAgICAgY2FzZSBSb2xsYmFja0Nob2ljZS5TVEFSVF9ST0xMQkFDSzpcbiAgICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShkZWJ1ZyhgSW5pdGlhdGluZyByb2xsYmFjayBvZiBzdGFjayAke2RlcGxveU5hbWV9YCkpO1xuICAgICAgICAgIGF3YWl0IGNmbi5yb2xsYmFja1N0YWNrKHtcbiAgICAgICAgICAgIFN0YWNrTmFtZTogZGVwbG95TmFtZSxcbiAgICAgICAgICAgIFJvbGVBUk46IGV4ZWN1dGlvblJvbGVBcm4sXG4gICAgICAgICAgICBDbGllbnRSZXF1ZXN0VG9rZW46IHJhbmRvbVVVSUQoKSxcbiAgICAgICAgICAgIC8vIEVuYWJsaW5nIHRoaXMgaXMganVzdCB0aGUgYmV0dGVyIG92ZXJhbGwgZGVmYXVsdCwgdGhlIG9ubHkgcmVhc29uIGl0IGlzbid0IHRoZSB1cHN0cmVhbSBkZWZhdWx0IGlzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBSZXRhaW5FeGNlcHRPbkNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJvbGxiYWNrQ2hvaWNlLkNPTlRJTlVFX1VQREFURV9ST0xMQkFDSzpcbiAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZSkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmFpbGVkIHJlc291cmNlcyBmcm9tIHRoZSBkZXBsb3ltZW50IGFuZCBhdXRvbWF0aWNhbGx5IHNraXAgdGhlbVxuICAgICAgICAgICAgLy8gKFVzaW5nIGRlcGxveW1lbnQgbG9nIGJlY2F1c2Ugd2UgZGVmaW5pdGVseSBoYXZlIGBEZXNjcmliZVN0YWNrRXZlbnRzYCBwZXJtaXNzaW9ucywgYW5kIHdlIG1pZ2h0IG5vdCBoYXZlXG4gICAgICAgICAgICAvLyBgRGVzY3JpYmVTdGFja1Jlc291cmNlc2AgcGVybWlzc2lvbnMpLlxuICAgICAgICAgICAgY29uc3QgcG9sbGVyID0gbmV3IFN0YWNrRXZlbnRQb2xsZXIoY2ZuLCB7XG4gICAgICAgICAgICAgIHN0YWNrTmFtZTogZGVwbG95TmFtZSxcbiAgICAgICAgICAgICAgc3RhY2tTdGF0dXNlczogWydST0xMQkFDS19JTl9QUk9HUkVTUycsICdVUERBVEVfUk9MTEJBQ0tfSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcG9sbGVyLnBvbGwoKTtcbiAgICAgICAgICAgIHJlc291cmNlc1RvU2tpcCA9IHBvbGxlci5yZXNvdXJjZUVycm9yc1xuICAgICAgICAgICAgICAuZmlsdGVyKChyKSA9PiAhci5pc1N0YWNrRXZlbnQgJiYgci5wYXJlbnRTdGFja0xvZ2ljYWxJZHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAubWFwKChyKSA9PiByLmV2ZW50LkxvZ2ljYWxSZXNvdXJjZUlkID8/ICcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBza2lwRGVzY3JpcHRpb24gPSByZXNvdXJjZXNUb1NraXAubGVuZ3RoID4gMCA/IGAgKG9ycGhhbmluZzogJHtyZXNvdXJjZXNUb1NraXAuam9pbignLCAnKX0pYCA6ICcnO1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KHdhcm4oYENvbnRpbnVpbmcgcm9sbGJhY2sgb2Ygc3RhY2sgJHtkZXBsb3lOYW1lfSR7c2tpcERlc2NyaXB0aW9ufWApKTtcbiAgICAgICAgICBhd2FpdCBjZm4uY29udGludWVVcGRhdGVSb2xsYmFjayh7XG4gICAgICAgICAgICBTdGFja05hbWU6IGRlcGxveU5hbWUsXG4gICAgICAgICAgICBDbGllbnRSZXF1ZXN0VG9rZW46IHJhbmRvbVVVSUQoKSxcbiAgICAgICAgICAgIFJvbGVBUk46IGV4ZWN1dGlvblJvbGVBcm4sXG4gICAgICAgICAgICBSZXNvdXJjZXNUb1NraXA6IHJlc291cmNlc1RvU2tpcCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJvbGxiYWNrQ2hvaWNlLlJPTExCQUNLX0ZBSUxFRDpcbiAgICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeSh3YXJuKFxuICAgICAgICAgICAgYFN0YWNrICR7ZGVwbG95TmFtZX0gZmFpbGVkIGNyZWF0aW9uIGFuZCByb2xsYmFjay4gVGhpcyBzdGF0ZSBjYW5ub3QgYmUgcm9sbGVkIGJhY2suIFlvdSBjYW4gcmVjcmVhdGUgdGhpcyBzdGFjayBieSBydW5uaW5nICdjZGsgZGVwbG95Jy5gLFxuICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybiB7IG5vdEluUm9sbGJhY2thYmxlU3RhdGU6IHRydWUgfTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFVuZXhwZWN0ZWQgcm9sbGJhY2sgY2hvaWNlOiAke2Nsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tTdGF0dXMucm9sbGJhY2tDaG9pY2V9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vbml0b3IgPSBuZXcgU3RhY2tBY3Rpdml0eU1vbml0b3Ioe1xuICAgICAgICBjZm4sXG4gICAgICAgIHN0YWNrOiBvcHRpb25zLnN0YWNrLFxuICAgICAgICBzdGFja05hbWU6IGRlcGxveU5hbWUsXG4gICAgICAgIGlvSGVscGVyOiB0aGlzLmlvSGVscGVyLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBtb25pdG9yLnN0YXJ0KCk7XG5cbiAgICAgIGxldCBzdGFja0Vycm9yTWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgbGV0IGZpbmFsU3RhY2tTdGF0ZSA9IGNsb3VkRm9ybWF0aW9uU3RhY2s7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdWNjZXNzU3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHRoaXMuaW9IZWxwZXIsIGRlcGxveU5hbWUpO1xuXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IHJlYWxseSBoYXBwZW4sIGJ1dCBjYXRjaCBpdCBhbnl3YXkuIFlvdSBuZXZlciBrbm93LlxuICAgICAgICBpZiAoIXN1Y2Nlc3NTdGFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ1N0YWNrIGRlcGxveSBmYWlsZWQgKHRoZSBzdGFjayBkaXNhcHBlYXJlZCB3aGlsZSB3ZSB3ZXJlIHJvbGxpbmcgaXQgYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbFN0YWNrU3RhdGUgPSBzdWNjZXNzU3RhY2s7XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gbW9uaXRvci5lcnJvcnMuam9pbignLCAnKTtcbiAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgIHN0YWNrRXJyb3JNZXNzYWdlID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgc3RhY2tFcnJvck1lc3NhZ2UgPSBzdWZmaXhXaXRoRXJyb3JzKGZvcm1hdEVycm9yTWVzc2FnZShlKSwgbW9uaXRvci5lcnJvcnMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgbW9uaXRvci5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbFN0YWNrU3RhdGUuc3RhY2tTdGF0dXMuaXNSb2xsYmFja1N1Y2Nlc3MgfHwgIXN0YWNrRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgIH1cblxuICAgICAgLy8gRWl0aGVyIHdlIG5lZWQgdG8gaWdub3JlIHNvbWUgcmVzb3VyY2VzIHRvIGNvbnRpbnVlIHRoZSByb2xsYmFjaywgb3Igc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIGlmIChmaW5hbFN0YWNrU3RhdGUuc3RhY2tTdGF0dXMucm9sbGJhY2tDaG9pY2UgPT09IFJvbGxiYWNrQ2hvaWNlLkNPTlRJTlVFX1VQREFURV9ST0xMQkFDSyAmJiBvcHRpb25zLmZvcmNlKSB7XG4gICAgICAgIC8vIERvIGFub3RoZXIgbG9vcC1kZS1sb29wXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICBgJHtzdGFja0Vycm9yTWVzc2FnZX0gKGZpeCBwcm9ibGVtIGFuZCByZXRyeSwgb3Igb3JwaGFuIHRoZXNlIHJlc291cmNlcyB1c2luZyAtLW9ycGhhbiBvciAtLWZvcmNlKWAsXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgXCJSb2xsYmFjayBkaWQgbm90IGZpbmlzaCBhZnRlciBhIGxhcmdlIG51bWJlciBvZiBpdGVyYXRpb25zOyBzdG9wcGluZyBiZWNhdXNlIGl0IGxvb2tzIGxpa2Ugd2UncmUgbm90IG1ha2luZyBwcm9ncmVzcyBhbnltb3JlLiBZb3UgY2FuIHJldHJ5IGlmIHJvbGxiYWNrIHdhcyBwcm9ncmVzc2luZyBhcyBleHBlY3RlZC5cIixcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3lTdGFjayhvcHRpb25zOiBEZXN0cm95U3RhY2tPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZW52ID0gYXdhaXQgdGhpcy5lbnZzLmFjY2Vzc1N0YWNrRm9yTXV0YWJsZVN0YWNrT3BlcmF0aW9ucyhvcHRpb25zLnN0YWNrKTtcbiAgICBjb25zdCBleGVjdXRpb25Sb2xlQXJuID0gYXdhaXQgZW52LnJlcGxhY2VQbGFjZWhvbGRlcnMob3B0aW9ucy5yb2xlQXJuID8/IG9wdGlvbnMuc3RhY2suY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Sb2xlQXJuKTtcblxuICAgIHJldHVybiBkZXN0cm95U3RhY2soe1xuICAgICAgc2RrOiBlbnYuc2RrLFxuICAgICAgcm9sZUFybjogZXhlY3V0aW9uUm9sZUFybixcbiAgICAgIHN0YWNrOiBvcHRpb25zLnN0YWNrLFxuICAgICAgZGVwbG95TmFtZTogb3B0aW9ucy5kZXBsb3lOYW1lLFxuICAgIH0sIHRoaXMuaW9IZWxwZXIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHN0YWNrRXhpc3RzKG9wdGlvbnM6IFN0YWNrRXhpc3RzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxldCBlbnY7XG4gICAgaWYgKG9wdGlvbnMudHJ5TG9va3VwUm9sZSkge1xuICAgICAgZW52ID0gYXdhaXQgdGhpcy5lbnZzLmFjY2Vzc1N0YWNrRm9yTG9va3VwQmVzdEVmZm9ydChvcHRpb25zLnN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW52ID0gYXdhaXQgdGhpcy5lbnZzLmFjY2Vzc1N0YWNrRm9yUmVhZE9ubHlTdGFja09wZXJhdGlvbnMob3B0aW9ucy5zdGFjayk7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoZW52LnNkay5jbG91ZEZvcm1hdGlvbigpLCBvcHRpb25zLmRlcGxveU5hbWUgPz8gb3B0aW9ucy5zdGFjay5zdGFja05hbWUpO1xuICAgIHJldHVybiBzdGFjay5leGlzdHM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBzaW5nbGUgYXNzZXQgZnJvbSBhbiBhc3NldCBtYW5pZmVzdFxuICAgKlxuICAgKiBJZiBhbiBhc3NlcnQgbWFuaWZlc3QgYXJ0aWZhY3QgaXMgZ2l2ZW4sIHRoZSBib290c3RyYXAgc3RhY2sgdmVyc2lvblxuICAgKiB3aWxsIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvbnN0cmFpbnRzIGluIHRoYXQgbWFuaWZlc3QgYXJ0aWZhY3QuXG4gICAqIElmIHRoYXQgaXMgbm90IG5lY2Vzc2FyeSwgYCduby12ZXJzaW9uLXZhbGlkYXRpb24nYCBjYW4gYmUgcGFzc2VkLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgcHVibGljIGFzeW5jIGJ1aWxkU2luZ2xlQXNzZXQoXG4gICAgYXNzZXRBcnRpZmFjdDogY3hhcGkuQXNzZXRNYW5pZmVzdEFydGlmYWN0IHwgJ25vLXZlcnNpb24tdmFsaWRhdGlvbicsXG4gICAgYXNzZXRNYW5pZmVzdDogY2RrX2Fzc2V0cy5Bc3NldE1hbmlmZXN0LFxuICAgIGFzc2V0OiBjZGtfYXNzZXRzLklNYW5pZmVzdEVudHJ5LFxuICAgIG9wdGlvbnM6IEJ1aWxkU3RhY2tBc3NldHNPcHRpb25zLFxuICApIHtcbiAgICBpZiAoYXNzZXRBcnRpZmFjdCAhPT0gJ25vLXZlcnNpb24tdmFsaWRhdGlvbicpIHtcbiAgICAgIGNvbnN0IGVudiA9IGF3YWl0IHRoaXMuZW52cy5hY2Nlc3NTdGFja0ZvclJlYWRPbmx5U3RhY2tPcGVyYXRpb25zKG9wdGlvbnMuc3RhY2spO1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICAgICAgb3B0aW9ucy5zdGFjay5zdGFja05hbWUsXG4gICAgICAgIGFzc2V0QXJ0aWZhY3QucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb24sXG4gICAgICAgIGFzc2V0QXJ0aWZhY3QuYm9vdHN0cmFwU3RhY2tWZXJzaW9uU3NtUGFyYW1ldGVyLFxuICAgICAgICBlbnYucmVzb3VyY2VzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZEVudmlyb25tZW50ID0gYXdhaXQgdGhpcy5lbnZzLnJlc29sdmVTdGFja0Vudmlyb25tZW50KG9wdGlvbnMuc3RhY2spO1xuXG4gICAgY29uc3QgcHVibGlzaGVyID0gdGhpcy5jYWNoZWRQdWJsaXNoZXIoYXNzZXRNYW5pZmVzdCwgcmVzb2x2ZWRFbnZpcm9ubWVudCwgb3B0aW9ucy5zdGFja05hbWUpO1xuICAgIGF3YWl0IHB1Ymxpc2hlci5idWlsZEVudHJ5KGFzc2V0KTtcbiAgICBpZiAocHVibGlzaGVyLmhhc0ZhaWx1cmVzKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gYnVpbGQgYXNzZXQgJHthc3NldC5kaXNwbGF5TmFtZShmYWxzZSl9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBzaW5nbGUgYXNzZXQgZnJvbSBhbiBhc3NldCBtYW5pZmVzdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHB1Ymxpc2hTaW5nbGVBc3NldChcbiAgICBhc3NldE1hbmlmZXN0OiBjZGtfYXNzZXRzLkFzc2V0TWFuaWZlc3QsXG4gICAgYXNzZXQ6IGNka19hc3NldHMuSU1hbmlmZXN0RW50cnksXG4gICAgb3B0aW9uczogUHVibGlzaFN0YWNrQXNzZXRzT3B0aW9ucyxcbiAgKSB7XG4gICAgY29uc3Qgc3RhY2tFbnYgPSBhd2FpdCB0aGlzLmVudnMucmVzb2x2ZVN0YWNrRW52aXJvbm1lbnQob3B0aW9ucy5zdGFjayk7XG5cbiAgICAvLyBObyBuZWVkIHRvIHZhbGlkYXRlIGFueW1vcmUsIHdlIGFscmVhZHkgZGlkIHRoYXQgZHVyaW5nIGJ1aWxkXG4gICAgY29uc3QgcHVibGlzaGVyID0gdGhpcy5jYWNoZWRQdWJsaXNoZXIoYXNzZXRNYW5pZmVzdCwgc3RhY2tFbnYsIG9wdGlvbnMuc3RhY2tOYW1lKTtcbiAgICBhd2FpdCBwdWJsaXNoZXIucHVibGlzaEVudHJ5KGFzc2V0LCB7XG4gICAgICBhbGxvd0Nyb3NzQWNjb3VudDogYXdhaXQgdGhpcy5hbGxvd0Nyb3NzQWNjb3VudEFzc2V0UHVibGlzaGluZ0ZvckVudihvcHRpb25zLnN0YWNrKSxcbiAgICAgIGZvcmNlOiBvcHRpb25zLmZvcmNlUHVibGlzaCxcbiAgICB9KTtcbiAgICBpZiAocHVibGlzaGVyLmhhc0ZhaWx1cmVzKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gcHVibGlzaCBhc3NldCAke2Fzc2V0LmRpc3BsYXlOYW1lKHRydWUpfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYWxsb3dDcm9zc0FjY291bnRBc3NldFB1Ymxpc2hpbmdGb3JFbnYoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICh0aGlzLl9hbGxvd0Nyb3NzQWNjb3VudEFzc2V0UHVibGlzaGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlbnYgPSBhd2FpdCB0aGlzLmVudnMuYWNjZXNzU3RhY2tGb3JSZWFkT25seVN0YWNrT3BlcmF0aW9ucyhzdGFjayk7XG4gICAgICB0aGlzLl9hbGxvd0Nyb3NzQWNjb3VudEFzc2V0UHVibGlzaGluZyA9IGF3YWl0IGRldGVybWluZUFsbG93Q3Jvc3NBY2NvdW50QXNzZXRQdWJsaXNoaW5nKGVudi5zZGssIHRoaXMuaW9IZWxwZXIsIHRoaXMucHJvcHMudG9vbGtpdFN0YWNrTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hbGxvd0Nyb3NzQWNjb3VudEFzc2V0UHVibGlzaGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciBhIHNpbmdsZSBhc3NldCBoYXMgYmVlbiBwdWJsaXNoZWQgYWxyZWFkeVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlzU2luZ2xlQXNzZXRQdWJsaXNoZWQoXG4gICAgYXNzZXRNYW5pZmVzdDogY2RrX2Fzc2V0cy5Bc3NldE1hbmlmZXN0LFxuICAgIGFzc2V0OiBjZGtfYXNzZXRzLklNYW5pZmVzdEVudHJ5LFxuICAgIG9wdGlvbnM6IFB1Ymxpc2hTdGFja0Fzc2V0c09wdGlvbnMsXG4gICkge1xuICAgIGNvbnN0IHN0YWNrRW52ID0gYXdhaXQgdGhpcy5lbnZzLnJlc29sdmVTdGFja0Vudmlyb25tZW50KG9wdGlvbnMuc3RhY2spO1xuICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMuY2FjaGVkUHVibGlzaGVyKGFzc2V0TWFuaWZlc3QsIHN0YWNrRW52LCBvcHRpb25zLnN0YWNrTmFtZSk7XG4gICAgcmV0dXJuIHB1Ymxpc2hlci5pc0VudHJ5UHVibGlzaGVkKGFzc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGF0IHRoZSBib290c3RyYXAgc3RhY2sgaGFzIHRoZSByaWdodCB2ZXJzaW9uIGZvciB0aGlzIHN0YWNrXG4gICAqXG4gICAqIENhbGwgaW50byBlbnZSZXNvdXJjZXMudmFsaWRhdGVWZXJzaW9uLCBidXQgcHJlcGVuZCB0aGUgc3RhY2sgbmFtZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uKFxuICAgIHN0YWNrTmFtZTogc3RyaW5nLFxuICAgIHJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgYm9vdHN0cmFwU3RhY2tWZXJzaW9uU3NtUGFyYW1ldGVyOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZW52UmVzb3VyY2VzOiBFbnZpcm9ubWVudFJlc291cmNlcyxcbiAgKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGVudlJlc291cmNlcy52YWxpZGF0ZVZlcnNpb24ocmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb24sIGJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlcik7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke3N0YWNrTmFtZX06ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2FjaGVkUHVibGlzaGVyKGFzc2V0TWFuaWZlc3Q6IGNka19hc3NldHMuQXNzZXRNYW5pZmVzdCwgZW52OiBjeGFwaS5FbnZpcm9ubWVudCwgc3RhY2tOYW1lPzogc3RyaW5nKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLnB1Ymxpc2hlckNhY2hlLmdldChhc3NldE1hbmlmZXN0KTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0gc3RhY2tOYW1lID8gYCR7Y2hhbGsuYm9sZChzdGFja05hbWUpfTogYCA6ICcnO1xuICAgIGNvbnN0IHB1Ymxpc2hlciA9IG5ldyBjZGtfYXNzZXRzLkFzc2V0UHVibGlzaGluZyhhc3NldE1hbmlmZXN0LCB7XG4gICAgICAvLyBUaGUgQXNzZXRQdWJsaXNoaW5nIGNsYXNzIHRha2VzIGNhcmUgb2Ygcm9sZSBhc3N1bWluZyBldGMsIHNvIGl0J3Mgb2theSB0b1xuICAgICAgLy8gZ2l2ZSBpdCBhIGRpcmVjdCBgU2RrUHJvdmlkZXJgLlxuICAgICAgYXdzOiBuZXcgUHVibGlzaGluZ0F3cyh0aGlzLmFzc2V0U2RrUHJvdmlkZXIsIGVudiksXG4gICAgICBwcm9ncmVzc0xpc3RlbmVyOiBuZXcgUGFyYWxsZWxTYWZlQXNzZXRQcm9ncmVzcyhwcmVmaXgsIHRoaXMuaW9IZWxwZXIpLFxuICAgIH0pO1xuICAgIHRoaXMucHVibGlzaGVyQ2FjaGUuc2V0KGFzc2V0TWFuaWZlc3QsIHB1Ymxpc2hlcik7XG4gICAgcmV0dXJuIHB1Ymxpc2hlcjtcbiAgfVxufVxuXG4vKipcbiAqIEFzc2V0IHByb2dyZXNzIHRoYXQgZG9lc24ndCBkbyBhbnl0aGluZyB3aXRoIHBlcmNlbnRhZ2VzIChjdXJyZW50bHkpXG4gKi9cbmNsYXNzIFBhcmFsbGVsU2FmZUFzc2V0UHJvZ3Jlc3MgZXh0ZW5kcyBCYXNlUHVibGlzaFByb2dyZXNzTGlzdGVuZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBpb0hlbHBlcjogSW9IZWxwZXIpIHtcbiAgICBzdXBlcihpb0hlbHBlcik7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0TWVzc2FnZSh0eXBlOiBjZGtfYXNzZXRzLkV2ZW50VHlwZSwgZXZlbnQ6IGNka19hc3NldHMuSVB1Ymxpc2hQcm9ncmVzcyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMucHJlZml4fSR7dHlwZX06ICR7ZXZlbnQubWVzc2FnZX1gO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1ZmZpeFdpdGhFcnJvcnMobXNnOiBzdHJpbmcsIGVycm9ycz86IHN0cmluZ1tdKSB7XG4gIHJldHVybiBlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCA+IDAgPyBgJHttc2d9OiAke2Vycm9ycy5qb2luKCcsICcpfWAgOiBtc2c7XG59XG4iXX0=