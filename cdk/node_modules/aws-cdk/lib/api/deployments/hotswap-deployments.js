"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = tryHotswapDeployment;
const util_1 = require("util");
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const private_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
const error_1 = require("../../toolkit/error");
const util_2 = require("../../util");
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
const appsync_mapping_templates_1 = require("../hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("../hotswap/code-build-projects");
const common_1 = require("../hotswap/common");
const ecs_services_1 = require("../hotswap/ecs-services");
const lambda_functions_1 = require("../hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("../hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("../hotswap/stepfunctions-state-machines");
const plugin_1 = require("../plugin");
// Must use a require() otherwise esbuild complains about calling a namespace
// eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/consistent-type-imports
const pLimit = require('p-limit');
const RESOURCE_DETECTORS = {
    // Lambda
    'AWS::Lambda::Function': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Version': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Alias': lambda_functions_1.isHotswappableLambdaFunctionChange,
    // AppSync
    'AWS::AppSync::Resolver': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::FunctionConfiguration': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::GraphQLSchema': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::ApiKey': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::ECS::TaskDefinition': ecs_services_1.isHotswappableEcsServiceChange,
    'AWS::CodeBuild::Project': code_build_projects_1.isHotswappableCodeBuildProjectChange,
    'AWS::StepFunctions::StateMachine': stepfunctions_state_machines_1.isHotswappableStateMachineChange,
    'Custom::CDKBucketDeployment': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::IAM::Policy': async (logicalId, change, evaluateCfnTemplate) => {
        // If the policy is for a S3BucketDeploymentChange, we can ignore the change
        if (await (0, s3_bucket_deployments_1.skipChangeForS3DeployCustomResourcePolicy)(logicalId, change, evaluateCfnTemplate)) {
            return [];
        }
        return (0, common_1.reportNonHotswappableResource)(change, 'This resource type is not supported for hotswap deployments');
    },
    'AWS::CDK::Metadata': async () => [],
};
/**
 * Perform a hotswap deployment, short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, ioHelper, assetParams, cloudFormationStack, stackArtifact, hotswapMode, hotswapPropertyOverrides) {
    const hotswapSpan = await ioHelper.span(private_1.SPAN.HOTSWAP).begin({
        stack: stackArtifact,
        mode: hotswapMode,
    });
    const result = await hotswapDeployment(sdkProvider, hotswapSpan, assetParams, stackArtifact, hotswapMode, hotswapPropertyOverrides);
    await hotswapSpan.end();
    if ((result === null || result === void 0 ? void 0 : result.hotswapped) === true) {
        return {
            type: 'did-deploy-stack',
            noOp: result.hotswappableChanges.length === 0,
            stackArn: cloudFormationStack.stackId,
            outputs: cloudFormationStack.outputs,
        };
    }
    return undefined;
}
/**
 * Perform a hotswap deployment, short-circuiting CloudFormation if possible.
 * Returns information about the attempted hotswap deployment
 */
async function hotswapDeployment(sdkProvider, ioSpan, assetParams, stack, hotswapMode, hotswapPropertyOverrides) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stack.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, plugin_1.Mode.ForWriting)).sdk;
    const currentTemplate = await (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(stack, sdk);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackArtifact: stack,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        sdk,
        nestedStacks: currentTemplate.nestedStacks,
    });
    const stackChanges = cfn_diff.fullDiff(currentTemplate.deployedRootTemplate, stack.template);
    const { hotswappableChanges, nonHotswappableChanges } = await classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStacks, hotswapPropertyOverrides);
    await logNonHotswappableChanges(ioSpan, nonHotswappableChanges, hotswapMode);
    // preserve classic hotswap behavior
    if (hotswapMode === 'fall-back') {
        if (nonHotswappableChanges.length > 0) {
            return {
                stack,
                hotswapped: false,
                hotswappableChanges,
                nonHotswappableChanges,
            };
        }
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, ioSpan, hotswappableChanges);
    return {
        stack,
        hotswapped: true,
        hotswappableChanges,
        nonHotswappableChanges,
    };
}
/**
 * Classifies all changes to all resources as either hotswappable or not.
 * Metadata changes are excluded from the list of (non)hotswappable resources.
 */
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames, hotswapPropertyOverrides) {
    var _a, _b;
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    const promises = [];
    const hotswappableResources = new Array();
    const nonHotswappableResources = new Array();
    for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
        nonHotswappableResources.push({
            hotswappable: false,
            reason: 'output was changed',
            logicalId,
            rejectedChanges: [],
            resourceType: 'Stack Output',
        });
    }
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (((_a = change.newValue) === null || _a === void 0 ? void 0 : _a.Type) === 'AWS::CloudFormation::Stack' && ((_b = change.oldValue) === null || _b === void 0 ? void 0 : _b.Type) === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk, hotswapPropertyOverrides);
            hotswappableResources.push(...nestedHotswappableResources.hotswappableChanges);
            nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappableChanges);
            continue;
        }
        const hotswappableChangeCandidate = isCandidateForHotswapping(change, logicalId);
        // we don't need to run this through the detector functions, we can already judge this
        if ('hotswappable' in hotswappableChangeCandidate) {
            if (!hotswappableChangeCandidate.hotswappable) {
                nonHotswappableResources.push(hotswappableChangeCandidate);
            }
            continue;
        }
        const resourceType = hotswappableChangeCandidate.newValue.Type;
        if (resourceType in RESOURCE_DETECTORS) {
            // run detector functions lazily to prevent unhandled promise rejections
            promises.push(() => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate, hotswapPropertyOverrides));
        }
        else {
            (0, common_1.reportNonHotswappableChange)(nonHotswappableResources, hotswappableChangeCandidate, undefined, 'This resource type is not supported for hotswap deployments');
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        // Constant set of promises per resource
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const resourceDetectionResults of changesDetectionResults) {
        for (const propertyResult of resourceDetectionResults) {
            propertyResult.hotswappable
                ? hotswappableResources.push(propertyResult)
                : nonHotswappableResources.push(propertyResult);
        }
    }
    return {
        hotswappableChanges: hotswappableResources,
        nonHotswappableChanges: nonHotswappableResources,
    };
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, (resChange) => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, (resChange) => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackTemplates, evaluateCfnTemplate, sdk, hotswapPropertyOverrides) {
    var _a, _b;
    const nestedStack = nestedStackTemplates[logicalId];
    if (!nestedStack.physicalName) {
        return {
            hotswappableChanges: [],
            nonHotswappableChanges: [
                {
                    hotswappable: false,
                    logicalId,
                    reason: `physical name for AWS::CloudFormation::Stack '${logicalId}' could not be found in CloudFormation, so this is a newly created nested stack and cannot be hotswapped`,
                    rejectedChanges: [],
                    resourceType: 'AWS::CloudFormation::Stack',
                },
            ],
        };
    }
    const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(nestedStack.physicalName, nestedStack.generatedTemplate, (_b = (_a = change.newValue) === null || _a === void 0 ? void 0 : _a.Properties) === null || _b === void 0 ? void 0 : _b.Parameters);
    const nestedDiff = cfn_diff.fullDiff(nestedStackTemplates[logicalId].deployedTemplate, nestedStackTemplates[logicalId].generatedTemplate);
    return classifyResourceChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackTemplates[logicalId].nestedStackTemplates, hotswapPropertyOverrides);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return (oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties));
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * Returns a `HotswappableChangeCandidate` if the change is hotswappable
 * Returns an empty `HotswappableChange` if the change is to CDK::Metadata
 * Returns a `NonHotswappableChange` if the change is not hotswappable
 */
function isCandidateForHotswapping(change, logicalId) {
    var _a, _b, _c, _d, _e;
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.oldValue) {
        return {
            hotswappable: false,
            resourceType: change.newValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was created by this deployment`,
        };
    }
    else if (!change.newValue) {
        return {
            hotswappable: false,
            resourceType: change.oldValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was destroyed by this deployment`,
        };
    }
    // a resource has had its type changed
    if (((_a = change.newValue) === null || _a === void 0 ? void 0 : _a.Type) !== ((_b = change.oldValue) === null || _b === void 0 ? void 0 : _b.Type)) {
        return {
            hotswappable: false,
            resourceType: (_c = change.newValue) === null || _c === void 0 ? void 0 : _c.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' had its type changed from '${(_d = change.oldValue) === null || _d === void 0 ? void 0 : _d.Type}' to '${(_e = change.newValue) === null || _e === void 0 ? void 0 : _e.Type}'`,
        };
    }
    return {
        logicalId,
        oldValue: change.oldValue,
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, ioSpan, hotswappableChanges) {
    if (hotswappableChanges.length > 0) {
        await ioSpan.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(`\n${common_1.ICON} hotswapping resources:`));
    }
    const limit = pLimit(10);
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    return Promise.all(hotswappableChanges.map(hotswapOperation => limit(() => {
        return applyHotswappableChange(sdk, ioSpan, hotswapOperation);
    })));
}
async function applyHotswappableChange(sdk, ioSpan, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    for (const name of hotswapOperation.resourceNames) {
        await ioSpan.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg((0, util_1.format)(`   ${common_1.ICON} %s`, chalk.bold(name))));
    }
    // if the SDK call fails, an error will be thrown by the SDK
    // and will prevent the green 'hotswapped!' text from being displayed
    try {
        await hotswapOperation.apply(sdk);
    }
    catch (e) {
        if (e.name === 'TimeoutError' || e.name === 'AbortError') {
            const result = JSON.parse((0, util_2.formatErrorMessage)(e));
            const error = new error_1.ToolkitError(formatWaiterErrorResult(result));
            error.name = e.name;
            throw error;
        }
        throw e;
    }
    for (const name of hotswapOperation.resourceNames) {
        await ioSpan.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg((0, util_1.format)(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'))));
    }
    sdk.removeCustomUserAgent(customUserAgent);
}
function formatWaiterErrorResult(result) {
    const main = [
        `Resource is not in the expected state due to waiter status: ${result.state}`,
        result.reason ? `${result.reason}.` : '',
    ].join('. ');
    if (result.observedResponses != null) {
        const observedResponses = Object
            .entries(result.observedResponses)
            .map(([msg, count]) => `  - ${msg} (${count})`)
            .join('\n');
        return `${main} Observed responses:\n${observedResponses}`;
    }
    return main;
}
async function logNonHotswappableChanges(ioSpan, nonHotswappableChanges, hotswapMode) {
    if (nonHotswappableChanges.length === 0) {
        return;
    }
    /**
     * EKS Services can have a task definition that doesn't refer to the task definition being updated.
     * We have to log this as a non-hotswappable change to the task definition, but when we do,
     * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
     *
     * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
     */
    if (hotswapMode === 'hotswap-only') {
        nonHotswappableChanges = nonHotswappableChanges.filter((change) => change.hotswapOnlyVisible === true);
        if (nonHotswappableChanges.length === 0) {
            return;
        }
    }
    const messages = ['']; // start with empty line
    if (hotswapMode === 'hotswap-only') {
        messages.push((0, util_1.format)('%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback')));
    }
    else {
        messages.push((0, util_1.format)('%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found:')));
    }
    for (const change of nonHotswappableChanges) {
        if (change.rejectedChanges.length > 0) {
            messages.push((0, util_1.format)('    logicalID: %s, type: %s, rejected changes: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.bold(change.rejectedChanges), chalk.red(change.reason)));
        }
        else {
            messages.push((0, util_1.format)('    logicalID: %s, type: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.red(change.reason)));
        }
    }
    messages.push(''); // newline
    await ioSpan.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(messages.join('\n')));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUEyRkEsb0RBbUNDO0FBOUhELCtCQUE4QjtBQUM5Qix5REFBeUQ7QUFHekQsK0JBQStCO0FBRy9CLHlGQUF1RjtBQUl2RixpRUFBNkU7QUFDN0UsK0NBQW1EO0FBQ25ELHFDQUFnRDtBQUNoRCwwRkFBcUY7QUFDckYsb0ZBQW1GO0FBQ25GLHdFQUFzRjtBQVN0Riw4Q0FJMkI7QUFDM0IsMERBQXlFO0FBQ3pFLGtFQUFpRjtBQUNqRiw0RUFHMEM7QUFDMUMsMEZBQTJGO0FBQzNGLHNDQUFpQztBQUdqQyw2RUFBNkU7QUFDN0UsNEdBQTRHO0FBQzVHLE1BQU0sTUFBTSxHQUE2QixPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFXNUQsTUFBTSxrQkFBa0IsR0FBdUM7SUFDN0QsU0FBUztJQUNULHVCQUF1QixFQUFFLHFEQUFrQztJQUMzRCxzQkFBc0IsRUFBRSxxREFBa0M7SUFDMUQsb0JBQW9CLEVBQUUscURBQWtDO0lBRXhELFVBQVU7SUFDVix3QkFBd0IsRUFBRSx1REFBMkI7SUFDckQscUNBQXFDLEVBQUUsdURBQTJCO0lBQ2xFLDZCQUE2QixFQUFFLHVEQUEyQjtJQUMxRCxzQkFBc0IsRUFBRSx1REFBMkI7SUFFbkQsMEJBQTBCLEVBQUUsNkNBQThCO0lBQzFELHlCQUF5QixFQUFFLDBEQUFvQztJQUMvRCxrQ0FBa0MsRUFBRSwrREFBZ0M7SUFDcEUsNkJBQTZCLEVBQUUsOERBQXNDO0lBQ3JFLGtCQUFrQixFQUFFLEtBQUssRUFDdkIsU0FBaUIsRUFDakIsTUFBc0IsRUFDdEIsbUJBQW1ELEVBQ3JCLEVBQUU7UUFDaEMsNEVBQTRFO1FBQzVFLElBQUksTUFBTSxJQUFBLGlFQUF5QyxFQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLENBQUMsRUFBRSxDQUFDO1lBQzVG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QUFDO1lBQ3RDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBQSxhQUFNLEVBQ2xCLCtEQUErRCxFQUMvRCxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFDNUIsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxFQUNsQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FDekIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQzthQUFNLENBQUM7WUFDTixRQUFRLENBQUMsSUFBSSxDQUFDLElBQUEsYUFBTSxFQUNsQix5Q0FBeUMsRUFDekMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQzVCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUMvQixLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FDekIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztJQUNILENBQUM7SUFDRCxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVTtJQUU3QixNQUFNLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB0eXBlIHsgV2FpdGVyUmVzdWx0IH0gZnJvbSAnQHNtaXRoeS91dGlsLXdhaXRlcic7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgdHlwZSB7IFJlc291cmNlQ2hhbmdlIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3BheWxvYWRzJztcbmltcG9ydCB0eXBlIHsgSU1lc3NhZ2VTcGFuLCBJb0hlbHBlciB9IGZyb20gJy4uLy4uLy4uLy4uL0Bhd3MtY2RrL3RtcC10b29sa2l0LWhlbHBlcnMvc3JjL2FwaS9pby9wcml2YXRlJztcbmltcG9ydCB7IElPLCBTUEFOIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBTREssIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHR5cGUgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgdHlwZSB7IE5lc3RlZFN0YWNrVGVtcGxhdGVzIH0gZnJvbSAnLi9uZXN0ZWQtc3RhY2staGVscGVycyc7XG5pbXBvcnQgeyBsb2FkQ3VycmVudFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyB9IGZyb20gJy4vbmVzdGVkLXN0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4uL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSB9IGZyb20gJy4uL2hvdHN3YXAvYXBwc3luYy1tYXBwaW5nLXRlbXBsYXRlcyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZUNvZGVCdWlsZFByb2plY3RDaGFuZ2UgfSBmcm9tICcuLi9ob3Rzd2FwL2NvZGUtYnVpbGQtcHJvamVjdHMnO1xuaW1wb3J0IHR5cGUge1xuICBDaGFuZ2VIb3Rzd2FwUmVzdWx0LFxuICBIb3Rzd2FwT3BlcmF0aW9uLFxuICBOb25Ib3Rzd2FwcGFibGVDaGFuZ2UsXG4gIEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbiAgQ2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcyxcbiAgSG90c3dhcFJlc3VsdCxcbn0gZnJvbSAnLi4vaG90c3dhcC9jb21tb24nO1xuaW1wb3J0IHtcbiAgSUNPTixcbiAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlLFxuICByZXBvcnROb25Ib3Rzd2FwcGFibGVSZXNvdXJjZSxcbn0gZnJvbSAnLi4vaG90c3dhcC9jb21tb24nO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlIH0gZnJvbSAnLi4vaG90c3dhcC9lY3Mtc2VydmljZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSB9IGZyb20gJy4uL2hvdHN3YXAvbGFtYmRhLWZ1bmN0aW9ucyc7XG5pbXBvcnQge1xuICBza2lwQ2hhbmdlRm9yUzNEZXBsb3lDdXN0b21SZXNvdXJjZVBvbGljeSxcbiAgaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsXG59IGZyb20gJy4uL2hvdHN3YXAvczMtYnVja2V0LWRlcGxveW1lbnRzJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlU3RhdGVNYWNoaW5lQ2hhbmdlIH0gZnJvbSAnLi4vaG90c3dhcC9zdGVwZnVuY3Rpb25zLXN0YXRlLW1hY2hpbmVzJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuLi9wbHVnaW4nO1xuaW1wb3J0IHR5cGUgeyBTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuL2RlcGxveW1lbnQtcmVzdWx0JztcblxuLy8gTXVzdCB1c2UgYSByZXF1aXJlKCkgb3RoZXJ3aXNlIGVzYnVpbGQgY29tcGxhaW5zIGFib3V0IGNhbGxpbmcgYSBuYW1lc3BhY2Vcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtaW1wb3J0c1xuY29uc3QgcExpbWl0OiB0eXBlb2YgaW1wb3J0KCdwLWxpbWl0JykgPSByZXF1aXJlKCdwLWxpbWl0Jyk7XG5cbnR5cGUgSG90c3dhcERldGVjdG9yID0gKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBSZXNvdXJjZUNoYW5nZSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbikgPT4gUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PjtcblxudHlwZSBIb3Rzd2FwTW9kZSA9ICdob3Rzd2FwLW9ubHknIHwgJ2ZhbGwtYmFjayc7XG5cbmNvbnN0IFJFU09VUkNFX0RFVEVDVE9SUzogeyBba2V5OiBzdHJpbmddOiBIb3Rzd2FwRGV0ZWN0b3IgfSA9IHtcbiAgLy8gTGFtYmRhXG4gICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OlZlcnNpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OkFsaWFzJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcblxuICAvLyBBcHBTeW5jXG4gICdBV1M6OkFwcFN5bmM6OlJlc29sdmVyJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpGdW5jdGlvbkNvbmZpZ3VyYXRpb24nOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkdyYXBoUUxTY2hlbWEnOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkFwaUtleSc6IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSxcblxuICAnQVdTOjpFQ1M6OlRhc2tEZWZpbml0aW9uJzogaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlLFxuICAnQVdTOjpDb2RlQnVpbGQ6OlByb2plY3QnOiBpc0hvdHN3YXBwYWJsZUNvZGVCdWlsZFByb2plY3RDaGFuZ2UsXG4gICdBV1M6OlN0ZXBGdW5jdGlvbnM6OlN0YXRlTWFjaGluZSc6IGlzSG90c3dhcHBhYmxlU3RhdGVNYWNoaW5lQ2hhbmdlLFxuICAnQ3VzdG9tOjpDREtCdWNrZXREZXBsb3ltZW50JzogaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsXG4gICdBV1M6OklBTTo6UG9saWN5JzogYXN5bmMgKFxuICAgIGxvZ2ljYWxJZDogc3RyaW5nLFxuICAgIGNoYW5nZTogUmVzb3VyY2VDaGFuZ2UsXG4gICAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICApOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+ID0+IHtcbiAgICAvLyBJZiB0aGUgcG9saWN5IGlzIGZvciBhIFMzQnVja2V0RGVwbG95bWVudENoYW5nZSwgd2UgY2FuIGlnbm9yZSB0aGUgY2hhbmdlXG4gICAgaWYgKGF3YWl0IHNraXBDaGFuZ2VGb3JTM0RlcGxveUN1c3RvbVJlc291cmNlUG9saWN5KGxvZ2ljYWxJZCwgY2hhbmdlLCBldmFsdWF0ZUNmblRlbXBsYXRlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiByZXBvcnROb25Ib3Rzd2FwcGFibGVSZXNvdXJjZShjaGFuZ2UsICdUaGlzIHJlc291cmNlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgaG90c3dhcCBkZXBsb3ltZW50cycpO1xuICB9LFxuXG4gICdBV1M6OkNESzo6TWV0YWRhdGEnOiBhc3luYyAoKSA9PiBbXSxcbn07XG5cbi8qKlxuICogUGVyZm9ybSBhIGhvdHN3YXAgZGVwbG95bWVudCwgc2hvcnQtY2lyY3VpdGluZyBDbG91ZEZvcm1hdGlvbiBpZiBwb3NzaWJsZS5cbiAqIElmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHNob3J0LWNpcmN1aXQgdGhlIGRlcGxveW1lbnRcbiAqIChiZWNhdXNlIHRoZSBDREsgU3RhY2sgY29udGFpbnMgY2hhbmdlcyB0aGF0IGNhbm5vdCBiZSBkZXBsb3llZCB3aXRob3V0IENsb3VkRm9ybWF0aW9uKSxcbiAqIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cnlIb3Rzd2FwRGVwbG95bWVudChcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIGFzc2V0UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICBjbG91ZEZvcm1hdGlvblN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrLFxuICBzdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gIGhvdHN3YXBNb2RlOiBIb3Rzd2FwTW9kZSxcbiAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzOiBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4pOiBQcm9taXNlPFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBob3Rzd2FwU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5IT1RTV0FQKS5iZWdpbih7XG4gICAgc3RhY2s6IHN0YWNrQXJ0aWZhY3QsXG4gICAgbW9kZTogaG90c3dhcE1vZGUsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhvdHN3YXBEZXBsb3ltZW50KFxuICAgIHNka1Byb3ZpZGVyLFxuICAgIGhvdHN3YXBTcGFuLFxuICAgIGFzc2V0UGFyYW1zLFxuICAgIHN0YWNrQXJ0aWZhY3QsXG4gICAgaG90c3dhcE1vZGUsXG4gICAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuICApO1xuXG4gIGF3YWl0IGhvdHN3YXBTcGFuLmVuZCgpO1xuXG4gIGlmIChyZXN1bHQ/LmhvdHN3YXBwZWQgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RpZC1kZXBsb3ktc3RhY2snLFxuICAgICAgbm9PcDogcmVzdWx0LmhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID09PSAwLFxuICAgICAgc3RhY2tBcm46IGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tJZCxcbiAgICAgIG91dHB1dHM6IGNsb3VkRm9ybWF0aW9uU3RhY2sub3V0cHV0cyxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgaG90c3dhcCBkZXBsb3ltZW50LCBzaG9ydC1jaXJjdWl0aW5nIENsb3VkRm9ybWF0aW9uIGlmIHBvc3NpYmxlLlxuICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXR0ZW1wdGVkIGhvdHN3YXAgZGVwbG95bWVudFxuICovXG5hc3luYyBmdW5jdGlvbiBob3Rzd2FwRGVwbG95bWVudChcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICBpb1NwYW46IElNZXNzYWdlU3Bhbjxhbnk+LFxuICBhc3NldFBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8SG90c3dhcFJlc3VsdD4ge1xuICAvLyByZXNvbHZlIHRoZSBlbnZpcm9ubWVudCwgc28gd2UgY2FuIHN1YnN0aXR1dGUgdGhpbmdzIGxpa2UgQVdTOjpSZWdpb24gaW4gQ0ZOIGV4cHJlc3Npb25zXG4gIGNvbnN0IHJlc29sdmVkRW52ID0gYXdhaXQgc2RrUHJvdmlkZXIucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrLmVudmlyb25tZW50KTtcbiAgLy8gY3JlYXRlIGEgbmV3IFNESyB1c2luZyB0aGUgQ0xJIGNyZWRlbnRpYWxzLCBiZWNhdXNlIHRoZSBkZWZhdWx0IG9uZSB3aWxsIG5vdCB3b3JrIGZvciBuZXctc3R5bGUgc3ludGhlc2lzIC1cbiAgLy8gaXQgYXNzdW1lcyB0aGUgYm9vdHN0cmFwIGRlcGxveSBSb2xlLCB3aGljaCBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbnMgdG8gdXBkYXRlIExhbWJkYSBmdW5jdGlvbnNcbiAgY29uc3Qgc2RrID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KHJlc29sdmVkRW52LCBNb2RlLkZvcldyaXRpbmcpKS5zZGs7XG5cbiAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3Moc3RhY2ssIHNkayk7XG5cbiAgY29uc3QgZXZhbHVhdGVDZm5UZW1wbGF0ZSA9IG5ldyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUoe1xuICAgIHN0YWNrQXJ0aWZhY3Q6IHN0YWNrLFxuICAgIHBhcmFtZXRlcnM6IGFzc2V0UGFyYW1zLFxuICAgIGFjY291bnQ6IHJlc29sdmVkRW52LmFjY291bnQsXG4gICAgcmVnaW9uOiByZXNvbHZlZEVudi5yZWdpb24sXG4gICAgcGFydGl0aW9uOiAoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLnBhcnRpdGlvbixcbiAgICBzZGssXG4gICAgbmVzdGVkU3RhY2tzOiBjdXJyZW50VGVtcGxhdGUubmVzdGVkU3RhY2tzLFxuICB9KTtcblxuICBjb25zdCBzdGFja0NoYW5nZXMgPSBjZm5fZGlmZi5mdWxsRGlmZihjdXJyZW50VGVtcGxhdGUuZGVwbG95ZWRSb290VGVtcGxhdGUsIHN0YWNrLnRlbXBsYXRlKTtcbiAgY29uc3QgeyBob3Rzd2FwcGFibGVDaGFuZ2VzLCBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzIH0gPSBhd2FpdCBjbGFzc2lmeVJlc291cmNlQ2hhbmdlcyhcbiAgICBzdGFja0NoYW5nZXMsXG4gICAgZXZhbHVhdGVDZm5UZW1wbGF0ZSxcbiAgICBzZGssXG4gICAgY3VycmVudFRlbXBsYXRlLm5lc3RlZFN0YWNrcywgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuICApO1xuXG4gIGF3YWl0IGxvZ05vbkhvdHN3YXBwYWJsZUNoYW5nZXMoaW9TcGFuLCBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLCBob3Rzd2FwTW9kZSk7XG5cbiAgLy8gcHJlc2VydmUgY2xhc3NpYyBob3Rzd2FwIGJlaGF2aW9yXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gJ2ZhbGwtYmFjaycpIHtcbiAgICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFjayxcbiAgICAgICAgaG90c3dhcHBlZDogZmFsc2UsXG4gICAgICAgIGhvdHN3YXBwYWJsZUNoYW5nZXMsXG4gICAgICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGFwcGx5IHRoZSBzaG9ydC1jaXJjdWl0YWJsZSBjaGFuZ2VzXG4gIGF3YWl0IGFwcGx5QWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhzZGssIGlvU3BhbiwgaG90c3dhcHBhYmxlQ2hhbmdlcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFjayxcbiAgICBob3Rzd2FwcGVkOiB0cnVlLFxuICAgIGhvdHN3YXBwYWJsZUNoYW5nZXMsXG4gICAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDbGFzc2lmaWVzIGFsbCBjaGFuZ2VzIHRvIGFsbCByZXNvdXJjZXMgYXMgZWl0aGVyIGhvdHN3YXBwYWJsZSBvciBub3QuXG4gKiBNZXRhZGF0YSBjaGFuZ2VzIGFyZSBleGNsdWRlZCBmcm9tIHRoZSBsaXN0IG9mIChub24paG90c3dhcHBhYmxlIHJlc291cmNlcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2xhc3NpZnlSZXNvdXJjZUNoYW5nZXMoXG4gIHN0YWNrQ2hhbmdlczogY2ZuX2RpZmYuVGVtcGxhdGVEaWZmLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIHNkazogU0RLLFxuICBuZXN0ZWRTdGFja05hbWVzOiB7IFtuZXN0ZWRTdGFja05hbWU6IHN0cmluZ106IE5lc3RlZFN0YWNrVGVtcGxhdGVzIH0sXG4gIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuKTogUHJvbWlzZTxDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzPiB7XG4gIGNvbnN0IHJlc291cmNlRGlmZmVyZW5jZXMgPSBnZXRTdGFja1Jlc291cmNlRGlmZmVyZW5jZXMoc3RhY2tDaGFuZ2VzKTtcblxuICBjb25zdCBwcm9taXNlczogQXJyYXk8KCkgPT4gUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0Pj4gPSBbXTtcbiAgY29uc3QgaG90c3dhcHBhYmxlUmVzb3VyY2VzID0gbmV3IEFycmF5PEhvdHN3YXBPcGVyYXRpb24+KCk7XG4gIGNvbnN0IG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcyA9IG5ldyBBcnJheTxOb25Ib3Rzd2FwcGFibGVDaGFuZ2U+KCk7XG4gIGZvciAoY29uc3QgbG9naWNhbElkIG9mIE9iamVjdC5rZXlzKHN0YWNrQ2hhbmdlcy5vdXRwdXRzLmNoYW5nZXMpKSB7XG4gICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlYXNvbjogJ291dHB1dCB3YXMgY2hhbmdlZCcsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVzb3VyY2VUeXBlOiAnU3RhY2sgT3V0cHV0JyxcbiAgICB9KTtcbiAgfVxuICAvLyBnYXRoZXIgdGhlIHJlc3VsdHMgb2YgdGhlIGRldGVjdG9yIGZ1bmN0aW9uc1xuICBmb3IgKGNvbnN0IFtsb2dpY2FsSWQsIGNoYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzb3VyY2VEaWZmZXJlbmNlcykpIHtcbiAgICBpZiAoY2hhbmdlLm5ld1ZhbHVlPy5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snICYmIGNoYW5nZS5vbGRWYWx1ZT8uVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJykge1xuICAgICAgY29uc3QgbmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzID0gYXdhaXQgZmluZE5lc3RlZEhvdHN3YXBwYWJsZUNoYW5nZXMoXG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBuZXN0ZWRTdGFja05hbWVzLFxuICAgICAgICBldmFsdWF0ZUNmblRlbXBsYXRlLFxuICAgICAgICBzZGssXG4gICAgICAgIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbiAgICAgICk7XG4gICAgICBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5uZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMuaG90c3dhcHBhYmxlQ2hhbmdlcyk7XG4gICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5uZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMubm9uSG90c3dhcHBhYmxlQ2hhbmdlcyk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSA9IGlzQ2FuZGlkYXRlRm9ySG90c3dhcHBpbmcoY2hhbmdlLCBsb2dpY2FsSWQpO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcnVuIHRoaXMgdGhyb3VnaCB0aGUgZGV0ZWN0b3IgZnVuY3Rpb25zLCB3ZSBjYW4gYWxyZWFkeSBqdWRnZSB0aGlzXG4gICAgaWYgKCdob3Rzd2FwcGFibGUnIGluIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSkge1xuICAgICAgaWYgKCFob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUuaG90c3dhcHBhYmxlKSB7XG4gICAgICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlVHlwZTogc3RyaW5nID0gaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLm5ld1ZhbHVlLlR5cGU7XG4gICAgaWYgKHJlc291cmNlVHlwZSBpbiBSRVNPVVJDRV9ERVRFQ1RPUlMpIHtcbiAgICAgIC8vIHJ1biBkZXRlY3RvciBmdW5jdGlvbnMgbGF6aWx5IHRvIHByZXZlbnQgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uc1xuICAgICAgcHJvbWlzZXMucHVzaCgoKSA9PlxuICAgICAgICBSRVNPVVJDRV9ERVRFQ1RPUlNbcmVzb3VyY2VUeXBlXShsb2dpY2FsSWQsIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSwgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShcbiAgICAgICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLFxuICAgICAgICBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgJ1RoaXMgcmVzb3VyY2UgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBob3Rzd2FwIGRlcGxveW1lbnRzJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBhbGwgZGV0ZWN0b3IgcmVzdWx0c1xuICBjb25zdCBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0czogQXJyYXk8Q2hhbmdlSG90c3dhcFJlc3VsdD4gPSBbXTtcbiAgZm9yIChjb25zdCBkZXRlY3RvclJlc3VsdFByb21pc2VzIG9mIHByb21pc2VzKSB7XG4gICAgLy8gQ29uc3RhbnQgc2V0IG9mIHByb21pc2VzIHBlciByZXNvdXJjZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgIGNvbnN0IGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYXdhaXQgZGV0ZWN0b3JSZXN1bHRQcm9taXNlcygpKTtcbiAgICBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0cy5wdXNoKGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcmVzb3VyY2VEZXRlY3Rpb25SZXN1bHRzIG9mIGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzKSB7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eVJlc3VsdCBvZiByZXNvdXJjZURldGVjdGlvblJlc3VsdHMpIHtcbiAgICAgIHByb3BlcnR5UmVzdWx0LmhvdHN3YXBwYWJsZVxuICAgICAgICA/IGhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKHByb3BlcnR5UmVzdWx0KVxuICAgICAgICA6IG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKHByb3BlcnR5UmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhvdHN3YXBwYWJsZUNoYW5nZXM6IGhvdHN3YXBwYWJsZVJlc291cmNlcyxcbiAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMsXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgY2hhbmdlcyB0byByZXNvdXJjZXMgaW4gdGhlIGdpdmVuIFN0YWNrLlxuICpcbiAqIEBwYXJhbSBzdGFja0NoYW5nZXMgdGhlIGNvbGxlY3Rpb24gb2YgYWxsIGNoYW5nZXMgdG8gYSBnaXZlbiBTdGFja1xuICovXG5mdW5jdGlvbiBnZXRTdGFja1Jlc291cmNlRGlmZmVyZW5jZXMoc3RhY2tDaGFuZ2VzOiBjZm5fZGlmZi5UZW1wbGF0ZURpZmYpOiB7XG4gIFtsb2dpY2FsSWQ6IHN0cmluZ106IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZTtcbn0ge1xuICAvLyB3ZSBuZWVkIHRvIGNvbGxhcHNlIGxvZ2ljYWwgSUQgcmVuYW1lIGNoYW5nZXMgaW50byBvbmUgY2hhbmdlLFxuICAvLyBhcyB0aGV5IGFyZSByZXByZXNlbnRlZCBpbiBzdGFja0NoYW5nZXMgYXMgYSBwYWlyIG9mIHR3byBjaGFuZ2VzOiBvbmUgYWRkaXRpb24gYW5kIG9uZSByZW1vdmFsXG4gIGNvbnN0IGFsbFJlc291cmNlQ2hhbmdlczogeyBbbG9nSWQ6IHN0cmluZ106IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB9ID0gc3RhY2tDaGFuZ2VzLnJlc291cmNlcy5jaGFuZ2VzO1xuICBjb25zdCBhbGxSZW1vdmFsQ2hhbmdlcyA9IGZpbHRlckRpY3QoYWxsUmVzb3VyY2VDaGFuZ2VzLCAocmVzQ2hhbmdlKSA9PiByZXNDaGFuZ2UuaXNSZW1vdmFsKTtcbiAgY29uc3QgYWxsTm9uUmVtb3ZhbENoYW5nZXMgPSBmaWx0ZXJEaWN0KGFsbFJlc291cmNlQ2hhbmdlcywgKHJlc0NoYW5nZSkgPT4gIXJlc0NoYW5nZS5pc1JlbW92YWwpO1xuICBmb3IgKGNvbnN0IFtsb2dJZCwgbm9uUmVtb3ZhbENoYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsTm9uUmVtb3ZhbENoYW5nZXMpKSB7XG4gICAgaWYgKG5vblJlbW92YWxDaGFuZ2UuaXNBZGRpdGlvbikge1xuICAgICAgY29uc3QgYWRkQ2hhbmdlID0gbm9uUmVtb3ZhbENoYW5nZTtcbiAgICAgIC8vIHNlYXJjaCBmb3IgYW4gaWRlbnRpY2FsIHJlbW92YWwgY2hhbmdlXG4gICAgICBjb25zdCBpZGVudGljYWxSZW1vdmFsQ2hhbmdlID0gT2JqZWN0LmVudHJpZXMoYWxsUmVtb3ZhbENoYW5nZXMpLmZpbmQoKFtfLCByZW1DaGFuZ2VdKSA9PiB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzQXJlRm9yU2FtZVJlc291cmNlKHJlbUNoYW5nZSwgYWRkQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gaWYgd2UgZm91bmQgb25lLCB0aGVuIHRoaXMgbWVhbnMgdGhpcyBpcyBhIHJlbmFtZSBjaGFuZ2VcbiAgICAgIGlmIChpZGVudGljYWxSZW1vdmFsQ2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IFtyZW1vdmVkTG9nSWQsIHJlbW92ZWRSZXNvdXJjZUNoYW5nZV0gPSBpZGVudGljYWxSZW1vdmFsQ2hhbmdlO1xuICAgICAgICBhbGxOb25SZW1vdmFsQ2hhbmdlc1tsb2dJZF0gPSBtYWtlUmVuYW1lRGlmZmVyZW5jZShyZW1vdmVkUmVzb3VyY2VDaGFuZ2UsIGFkZENoYW5nZSk7XG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgcmVtb3ZhbCBjaGFuZ2UgdGhhdCBmb3JtcyB0aGUgcmVuYW1lIHBhaXJcbiAgICAgICAgZGVsZXRlIGFsbFJlbW92YWxDaGFuZ2VzW3JlbW92ZWRMb2dJZF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgYXJlIGFsbCBvZiB0aGUgcmVtYWluaW5nIHJlbW92YWwgY2hhbmdlcyxcbiAgLy8gcGx1cyBhbGwgb2YgdGhlIG5vbi1yZW1vdmFsIGNoYW5nZXNcbiAgLy8gKHdlIHNhdmVkIHRoZSByZW5hbWUgY2hhbmdlcyBpbiB0aGF0IG9iamVjdCBhbHJlYWR5KVxuICByZXR1cm4ge1xuICAgIC4uLmFsbFJlbW92YWxDaGFuZ2VzLFxuICAgIC4uLmFsbE5vblJlbW92YWxDaGFuZ2VzLFxuICB9O1xufVxuXG4vKiogRmlsdGVycyBhbiBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBiYXNlZCBvbiB3aGV0aGVyIHRoZSBjYWxsYmFjayByZXR1cm5zICd0cnVlJyBmb3IgdGhlIGdpdmVuIHZhbHVlIGluIHRoZSBvYmplY3QuICovXG5mdW5jdGlvbiBmaWx0ZXJEaWN0PFQ+KGRpY3Q6IHsgW2tleTogc3RyaW5nXTogVCB9LCBmdW5jOiAodDogVCkgPT4gYm9vbGVhbik6IHsgW2tleTogc3RyaW5nXTogVCB9IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRpY3QpLnJlZHVjZShcbiAgICAoYWNjLCBba2V5LCB0XSkgPT4ge1xuICAgICAgaWYgKGZ1bmModCkpIHtcbiAgICAgICAgYWNjW2tleV0gPSB0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9IGFzIHsgW2tleTogc3RyaW5nXTogVCB9LFxuICApO1xufVxuXG4vKiogRmluZHMgYW55IGhvdHN3YXBwYWJsZSBjaGFuZ2VzIGluIGFsbCBuZXN0ZWQgc3RhY2tzLiAqL1xuYXN5bmMgZnVuY3Rpb24gZmluZE5lc3RlZEhvdHN3YXBwYWJsZUNoYW5nZXMoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgbmVzdGVkU3RhY2tUZW1wbGF0ZXM6IHsgW25lc3RlZFN0YWNrTmFtZTogc3RyaW5nXTogTmVzdGVkU3RhY2tUZW1wbGF0ZXMgfSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IFNESyxcbiAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzOiBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4pOiBQcm9taXNlPENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXM+IHtcbiAgY29uc3QgbmVzdGVkU3RhY2sgPSBuZXN0ZWRTdGFja1RlbXBsYXRlc1tsb2dpY2FsSWRdO1xuICBpZiAoIW5lc3RlZFN0YWNrLnBoeXNpY2FsTmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGVDaGFuZ2VzOiBbXSxcbiAgICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICAgICAgbG9naWNhbElkLFxuICAgICAgICAgIHJlYXNvbjogYHBoeXNpY2FsIG5hbWUgZm9yIEFXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrICcke2xvZ2ljYWxJZH0nIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBDbG91ZEZvcm1hdGlvbiwgc28gdGhpcyBpcyBhIG5ld2x5IGNyZWF0ZWQgbmVzdGVkIHN0YWNrIGFuZCBjYW5ub3QgYmUgaG90c3dhcHBlZGAsXG4gICAgICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgICAgICByZXNvdXJjZVR5cGU6ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBldmFsdWF0ZU5lc3RlZENmblRlbXBsYXRlID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5jcmVhdGVOZXN0ZWRFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUoXG4gICAgbmVzdGVkU3RhY2sucGh5c2ljYWxOYW1lLFxuICAgIG5lc3RlZFN0YWNrLmdlbmVyYXRlZFRlbXBsYXRlLFxuICAgIGNoYW5nZS5uZXdWYWx1ZT8uUHJvcGVydGllcz8uUGFyYW1ldGVycyxcbiAgKTtcblxuICBjb25zdCBuZXN0ZWREaWZmID0gY2ZuX2RpZmYuZnVsbERpZmYoXG4gICAgbmVzdGVkU3RhY2tUZW1wbGF0ZXNbbG9naWNhbElkXS5kZXBsb3llZFRlbXBsYXRlLFxuICAgIG5lc3RlZFN0YWNrVGVtcGxhdGVzW2xvZ2ljYWxJZF0uZ2VuZXJhdGVkVGVtcGxhdGUsXG4gICk7XG5cbiAgcmV0dXJuIGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKFxuICAgIG5lc3RlZERpZmYsXG4gICAgZXZhbHVhdGVOZXN0ZWRDZm5UZW1wbGF0ZSxcbiAgICBzZGssXG4gICAgbmVzdGVkU3RhY2tUZW1wbGF0ZXNbbG9naWNhbElkXS5uZXN0ZWRTdGFja1RlbXBsYXRlcyxcbiAgICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gICk7XG59XG5cbi8qKiBSZXR1cm5zICd0cnVlJyBpZiBhIHBhaXIgb2YgY2hhbmdlcyBpcyBmb3IgdGhlIHNhbWUgcmVzb3VyY2UuICovXG5mdW5jdGlvbiBjaGFuZ2VzQXJlRm9yU2FtZVJlc291cmNlKFxuICBvbGRDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgbmV3Q2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBvbGRDaGFuZ2Uub2xkUmVzb3VyY2VUeXBlID09PSBuZXdDaGFuZ2UubmV3UmVzb3VyY2VUeXBlICYmXG4gICAgLy8gdGhpcyBpc24ndCBncmVhdCwgYnV0IEkgZG9uJ3Qgd2FudCB0byBicmluZyBpbiBzb21ldGhpbmcgbGlrZSB1bmRlcnNjb3JlIGp1c3QgZm9yIHRoaXMgY29tcGFyaXNvblxuICAgIEpTT04uc3RyaW5naWZ5KG9sZENoYW5nZS5vbGRQcm9wZXJ0aWVzKSA9PT0gSlNPTi5zdHJpbmdpZnkobmV3Q2hhbmdlLm5ld1Byb3BlcnRpZXMpXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZW5hbWVEaWZmZXJlbmNlKFxuICByZW1DaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgYWRkQ2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4pOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2Uge1xuICByZXR1cm4gbmV3IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZShcbiAgICAvLyB3ZSBoYXZlIHRvIGZpbGwgaW4gdGhlIG9sZCB2YWx1ZSwgYmVjYXVzZSBvdGhlcndpc2UgdGhpcyB3aWxsIGJlIGNsYXNzaWZpZWQgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZVxuICAgIHJlbUNoYW5nZS5vbGRWYWx1ZSxcbiAgICBhZGRDaGFuZ2UubmV3VmFsdWUsXG4gICAge1xuICAgICAgcmVzb3VyY2VUeXBlOiB7XG4gICAgICAgIG9sZFR5cGU6IHJlbUNoYW5nZS5vbGRSZXNvdXJjZVR5cGUsXG4gICAgICAgIG5ld1R5cGU6IGFkZENoYW5nZS5uZXdSZXNvdXJjZVR5cGUsXG4gICAgICB9LFxuICAgICAgcHJvcGVydHlEaWZmczogKGFkZENoYW5nZSBhcyBhbnkpLnByb3BlcnR5RGlmZnMsXG4gICAgICBvdGhlckRpZmZzOiAoYWRkQ2hhbmdlIGFzIGFueSkub3RoZXJEaWZmcyxcbiAgICB9LFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlYCBpZiB0aGUgY2hhbmdlIGlzIGhvdHN3YXBwYWJsZVxuICogUmV0dXJucyBhbiBlbXB0eSBgSG90c3dhcHBhYmxlQ2hhbmdlYCBpZiB0aGUgY2hhbmdlIGlzIHRvIENESzo6TWV0YWRhdGFcbiAqIFJldHVybnMgYSBgTm9uSG90c3dhcHBhYmxlQ2hhbmdlYCBpZiB0aGUgY2hhbmdlIGlzIG5vdCBob3Rzd2FwcGFibGVcbiAqL1xuZnVuY3Rpb24gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhcbiAgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuKTogSG90c3dhcE9wZXJhdGlvbiB8IE5vbkhvdHN3YXBwYWJsZUNoYW5nZSB8IFJlc291cmNlQ2hhbmdlIHtcbiAgLy8gYSByZXNvdXJjZSBoYXMgYmVlbiByZW1vdmVkIE9SIGEgcmVzb3VyY2UgaGFzIGJlZW4gYWRkZWQ7IHdlIGNhbid0IHNob3J0LWNpcmN1aXQgdGhhdCBjaGFuZ2VcbiAgaWYgKCFjaGFuZ2Uub2xkVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlIS5UeXBlLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlYXNvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIHdhcyBjcmVhdGVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgfTtcbiAgfSBlbHNlIGlmICghY2hhbmdlLm5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5vbGRWYWx1ZSEuVHlwZSxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICByZWFzb246IGByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyB3YXMgZGVzdHJveWVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGEgcmVzb3VyY2UgaGFzIGhhZCBpdHMgdHlwZSBjaGFuZ2VkXG4gIGlmIChjaGFuZ2UubmV3VmFsdWU/LlR5cGUgIT09IGNoYW5nZS5vbGRWYWx1ZT8uVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWU/LlR5cGUsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVhc29uOiBgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgaGFkIGl0cyB0eXBlIGNoYW5nZWQgZnJvbSAnJHtjaGFuZ2Uub2xkVmFsdWU/LlR5cGV9JyB0byAnJHtjaGFuZ2UubmV3VmFsdWU/LlR5cGV9J2AsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9naWNhbElkLFxuICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUsXG4gICAgbmV3VmFsdWU6IGNoYW5nZS5uZXdWYWx1ZSxcbiAgICBwcm9wZXJ0eVVwZGF0ZXM6IGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMsXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5QWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhzZGs6IFNESywgaW9TcGFuOiBJTWVzc2FnZVNwYW48YW55PiwgaG90c3dhcHBhYmxlQ2hhbmdlczogSG90c3dhcE9wZXJhdGlvbltdKTogUHJvbWlzZTx2b2lkW10+IHtcbiAgaWYgKGhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIGF3YWl0IGlvU3Bhbi5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGBcXG4ke0lDT059IGhvdHN3YXBwaW5nIHJlc291cmNlczpgKSk7XG4gIH1cbiAgY29uc3QgbGltaXQgPSBwTGltaXQoMTApO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgcmV0dXJuIFByb21pc2UuYWxsKGhvdHN3YXBwYWJsZUNoYW5nZXMubWFwKGhvdHN3YXBPcGVyYXRpb24gPT4gbGltaXQoKCkgPT4ge1xuICAgIHJldHVybiBhcHBseUhvdHN3YXBwYWJsZUNoYW5nZShzZGssIGlvU3BhbiwgaG90c3dhcE9wZXJhdGlvbik7XG4gIH0pKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5SG90c3dhcHBhYmxlQ2hhbmdlKHNkazogU0RLLCBpb1NwYW46IElNZXNzYWdlU3Bhbjxhbnk+LCBob3Rzd2FwT3BlcmF0aW9uOiBIb3Rzd2FwT3BlcmF0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIG5vdGUgdGhlIHR5cGUgb2Ygc2VydmljZSB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgaG90c3dhcHBlZCBpbiB0aGUgVXNlci1BZ2VudFxuICBjb25zdCBjdXN0b21Vc2VyQWdlbnQgPSBgY2RrLWhvdHN3YXAvc3VjY2Vzcy0ke2hvdHN3YXBPcGVyYXRpb24uc2VydmljZX1gO1xuICBzZGsuYXBwZW5kQ3VzdG9tVXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudCk7XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIGhvdHN3YXBPcGVyYXRpb24ucmVzb3VyY2VOYW1lcykge1xuICAgIGF3YWl0IGlvU3Bhbi5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGZvcm1hdChgICAgJHtJQ09OfSAlc2AsIGNoYWxrLmJvbGQobmFtZSkpKSk7XG4gIH1cblxuICAvLyBpZiB0aGUgU0RLIGNhbGwgZmFpbHMsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGJ5IHRoZSBTREtcbiAgLy8gYW5kIHdpbGwgcHJldmVudCB0aGUgZ3JlZW4gJ2hvdHN3YXBwZWQhJyB0ZXh0IGZyb20gYmVpbmcgZGlzcGxheWVkXG4gIHRyeSB7XG4gICAgYXdhaXQgaG90c3dhcE9wZXJhdGlvbi5hcHBseShzZGspO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBpZiAoZS5uYW1lID09PSAnVGltZW91dEVycm9yJyB8fCBlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgY29uc3QgcmVzdWx0OiBXYWl0ZXJSZXN1bHQgPSBKU09OLnBhcnNlKGZvcm1hdEVycm9yTWVzc2FnZShlKSk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBUb29sa2l0RXJyb3IoZm9ybWF0V2FpdGVyRXJyb3JSZXN1bHQocmVzdWx0KSk7XG4gICAgICBlcnJvci5uYW1lID0gZS5uYW1lO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgaG90c3dhcE9wZXJhdGlvbi5yZXNvdXJjZU5hbWVzKSB7XG4gICAgYXdhaXQgaW9TcGFuLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfSU5GTy5tc2coZm9ybWF0KGAke0lDT059ICVzICVzYCwgY2hhbGsuYm9sZChuYW1lKSwgY2hhbGsuZ3JlZW4oJ2hvdHN3YXBwZWQhJykpKSk7XG4gIH1cblxuICBzZGsucmVtb3ZlQ3VzdG9tVXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdhaXRlckVycm9yUmVzdWx0KHJlc3VsdDogV2FpdGVyUmVzdWx0KSB7XG4gIGNvbnN0IG1haW4gPSBbXG4gICAgYFJlc291cmNlIGlzIG5vdCBpbiB0aGUgZXhwZWN0ZWQgc3RhdGUgZHVlIHRvIHdhaXRlciBzdGF0dXM6ICR7cmVzdWx0LnN0YXRlfWAsXG4gICAgcmVzdWx0LnJlYXNvbiA/IGAke3Jlc3VsdC5yZWFzb259LmAgOiAnJyxcbiAgXS5qb2luKCcuICcpO1xuXG4gIGlmIChyZXN1bHQub2JzZXJ2ZWRSZXNwb25zZXMgIT0gbnVsbCkge1xuICAgIGNvbnN0IG9ic2VydmVkUmVzcG9uc2VzID0gT2JqZWN0XG4gICAgICAuZW50cmllcyhyZXN1bHQub2JzZXJ2ZWRSZXNwb25zZXMpXG4gICAgICAubWFwKChbbXNnLCBjb3VudF0pID0+IGAgIC0gJHttc2d9ICgke2NvdW50fSlgKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgcmV0dXJuIGAke21haW59IE9ic2VydmVkIHJlc3BvbnNlczpcXG4ke29ic2VydmVkUmVzcG9uc2VzfWA7XG4gIH1cblxuICByZXR1cm4gbWFpbjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9nTm9uSG90c3dhcHBhYmxlQ2hhbmdlcyhcbiAgaW9TcGFuOiBJTWVzc2FnZVNwYW48YW55PixcbiAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlczogTm9uSG90c3dhcHBhYmxlQ2hhbmdlW10sXG4gIGhvdHN3YXBNb2RlOiBIb3Rzd2FwTW9kZSxcbik6IFByb21pc2U8dm9pZD4ge1xuICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIEVLUyBTZXJ2aWNlcyBjYW4gaGF2ZSBhIHRhc2sgZGVmaW5pdGlvbiB0aGF0IGRvZXNuJ3QgcmVmZXIgdG8gdGhlIHRhc2sgZGVmaW5pdGlvbiBiZWluZyB1cGRhdGVkLlxuICAgKiBXZSBoYXZlIHRvIGxvZyB0aGlzIGFzIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UgdG8gdGhlIHRhc2sgZGVmaW5pdGlvbiwgYnV0IHdoZW4gd2UgZG8sXG4gICAqIHdlIHdpbmQgdXAgaG90c3dhcHBpbmcgdGhlIHRhc2sgZGVmaW5pdGlvbiBhbmQgbG9nZ2luZyBpdCBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGlzIGxvZ2ljIHByZXZlbnRzIHVzIGZyb20gbG9nZ2luZyB0aGF0IGNoYW5nZSBhcyBub24taG90c3dhcHBhYmxlIHdoZW4gd2UgaG90c3dhcCBpdC5cbiAgICovXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gJ2hvdHN3YXAtb25seScpIHtcbiAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzID0gbm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSkgPT4gY2hhbmdlLmhvdHN3YXBPbmx5VmlzaWJsZSA9PT0gdHJ1ZSk7XG5cbiAgICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXNzYWdlcyA9IFsnJ107IC8vIHN0YXJ0IHdpdGggZW1wdHkgbGluZVxuXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gJ2hvdHN3YXAtb25seScpIHtcbiAgICBtZXNzYWdlcy5wdXNoKGZvcm1hdCgnJXMgJXMnLCBjaGFsay5yZWQoJ+KaoO+4jycpLCBjaGFsay5yZWQoJ1RoZSBmb2xsb3dpbmcgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VzIHdlcmUgZm91bmQuIFRvIHJlY29uY2lsZSB0aGVzZSB1c2luZyBDbG91ZEZvcm1hdGlvbiwgc3BlY2lmeSAtLWhvdHN3YXAtZmFsbGJhY2snKSkpO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2VzLnB1c2goZm9ybWF0KCclcyAlcycsIGNoYWxrLnJlZCgn4pqg77iPJyksIGNoYWxrLnJlZCgnVGhlIGZvbGxvd2luZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgd2VyZSBmb3VuZDonKSkpO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGFuZ2Ugb2Ygbm9uSG90c3dhcHBhYmxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2UucmVqZWN0ZWRDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goZm9ybWF0KFxuICAgICAgICAnICAgIGxvZ2ljYWxJRDogJXMsIHR5cGU6ICVzLCByZWplY3RlZCBjaGFuZ2VzOiAlcywgcmVhc29uOiAlcycsXG4gICAgICAgIGNoYWxrLmJvbGQoY2hhbmdlLmxvZ2ljYWxJZCksXG4gICAgICAgIGNoYWxrLmJvbGQoY2hhbmdlLnJlc291cmNlVHlwZSksXG4gICAgICAgIGNoYWxrLmJvbGQoY2hhbmdlLnJlamVjdGVkQ2hhbmdlcyksXG4gICAgICAgIGNoYWxrLnJlZChjaGFuZ2UucmVhc29uKSxcbiAgICAgICkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKGZvcm1hdChcbiAgICAgICAgJyAgICBsb2dpY2FsSUQ6ICVzLCB0eXBlOiAlcywgcmVhc29uOiAlcycsXG4gICAgICAgIGNoYWxrLmJvbGQoY2hhbmdlLmxvZ2ljYWxJZCksXG4gICAgICAgIGNoYWxrLmJvbGQoY2hhbmdlLnJlc291cmNlVHlwZSksXG4gICAgICAgIGNoYWxrLnJlZChjaGFuZ2UucmVhc29uKSxcbiAgICAgICkpO1xuICAgIH1cbiAgfVxuICBtZXNzYWdlcy5wdXNoKCcnKTsgLy8gbmV3bGluZVxuXG4gIGF3YWl0IGlvU3Bhbi5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKG1lc3NhZ2VzLmpvaW4oJ1xcbicpKSk7XG59XG4iXX0=