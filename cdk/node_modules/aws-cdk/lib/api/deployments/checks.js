"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineAllowCrossAccountAssetPublishing = determineAllowCrossAccountAssetPublishing;
exports.getBootstrapStackInfo = getBootstrapStackInfo;
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
async function determineAllowCrossAccountAssetPublishing(sdk, ioHelper, customStackName) {
    try {
        const stackName = customStackName || 'CDKToolkit';
        const stackInfo = await getBootstrapStackInfo(sdk, stackName);
        if (!stackInfo.hasStagingBucket) {
            // indicates an intentional cross account setup
            return true;
        }
        if (stackInfo.bootstrapVersion >= 21) {
            // bootstrap stack version 21 contains a fix that will prevent cross
            // account publishing on the IAM level
            // https://github.com/aws/aws-cdk/pull/30823
            return true;
        }
        // If there is a staging bucket AND the bootstrap version is old, then we want to protect
        // against accidental cross-account publishing.
        return false;
    }
    catch (e) {
        // You would think we would need to fail closed here, but the reality is
        // that we get here if we couldn't find the bootstrap stack: that is
        // completely valid, and many large organizations may have their own method
        // of creating bootstrap resources. If they do, there's nothing for us to validate,
        // but we can't use that as a reason to disallow cross-account publishing. We'll just
        // have to trust they did their due diligence. So we fail open.
        await ioHelper.notify((0, messages_1.debug)(`Error determining cross account asset publishing: ${e}`));
        await ioHelper.notify((0, messages_1.debug)('Defaulting to allowing cross account asset publishing'));
        return true;
    }
}
async function getBootstrapStackInfo(sdk, stackName) {
    var _a, _b, _c;
    try {
        const cfn = sdk.cloudFormation();
        const stackResponse = await cfn.describeStacks({ StackName: stackName });
        if (!stackResponse.Stacks || stackResponse.Stacks.length === 0) {
            throw new error_1.ToolkitError(`Toolkit stack ${stackName} not found`);
        }
        const stack = stackResponse.Stacks[0];
        const versionOutput = (_a = stack.Outputs) === null || _a === void 0 ? void 0 : _a.find(output => output.OutputKey === 'BootstrapVersion');
        if (!(versionOutput === null || versionOutput === void 0 ? void 0 : versionOutput.OutputValue)) {
            throw new error_1.ToolkitError(`Unable to find BootstrapVersion output in the toolkit stack ${stackName}`);
        }
        const bootstrapVersion = parseInt(versionOutput.OutputValue);
        if (isNaN(bootstrapVersion)) {
            throw new error_1.ToolkitError(`Invalid BootstrapVersion value: ${versionOutput.OutputValue}`);
        }
        // try to get bucketname from the logical resource id. If there is no
        // bucketname, or the value doesn't look like an S3 bucket name, we assume
        // the bucket doesn't exist (this is for the case where a template customizer did
        // not dare to remove the Output, but put a dummy value there like '' or '-' or '***').
        //
        // We would have preferred to look at the stack resources here, but
        // unfortunately the deploy role doesn't have permissions call DescribeStackResources.
        const bucketName = (_c = (_b = stack.Outputs) === null || _b === void 0 ? void 0 : _b.find(output => output.OutputKey === 'BucketName')) === null || _c === void 0 ? void 0 : _c.OutputValue;
        // Must begin and end with letter or number.
        const hasStagingBucket = !!(bucketName && bucketName.match(/^[a-z0-9]/) && bucketName.match(/[a-z0-9]$/));
        return {
            hasStagingBucket,
            bootstrapVersion,
        };
    }
    catch (e) {
        throw new error_1.ToolkitError(`Error retrieving toolkit stack info: ${e}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2hlY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBS0EsOEZBbUNDO0FBT0Qsc0RBdUNDO0FBckZELGlEQUEyQztBQUMzQywrQ0FBbUQ7QUFHNUMsS0FBSyxVQUFVLHlDQUF5QyxDQUM3RCxHQUFRLEVBQ1IsUUFBa0IsRUFDbEIsZUFBd0I7SUFFeEIsSUFBSSxDQUFDO1FBQ0gsTUFBTSxTQUFTLEdBQUcsZUFBZSxJQUFJLFlBQVksQ0FBQztRQUNsRCxNQUFNLFNBQVMsR0FBRyxNQUFNLHFCQUFxQixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUU5RCxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDaEMsK0NBQStDO1lBQy9DLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELElBQUksU0FBUyxDQUFDLGdCQUFnQixJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQ3JDLG9FQUFvRTtZQUNwRSxzQ0FBc0M7WUFDdEMsNENBQTRDO1lBQzVDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELHlGQUF5RjtRQUN6RiwrQ0FBK0M7UUFDL0MsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNYLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEUsMkVBQTJFO1FBQzNFLG1GQUFtRjtRQUNuRixxRkFBcUY7UUFDckYsK0RBQStEO1FBQy9ELE1BQU0sUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFBLGdCQUFLLEVBQUMscURBQXFELENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN2RixNQUFNLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBQSxnQkFBSyxFQUFDLHVEQUF1RCxDQUFDLENBQUMsQ0FBQztRQUN0RixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7QUFDSCxDQUFDO0FBT00sS0FBSyxVQUFVLHFCQUFxQixDQUFDLEdBQVEsRUFBRSxTQUFpQjs7SUFDckUsSUFBSSxDQUFDO1FBQ0gsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sYUFBYSxHQUFHLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBRXpFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQy9ELE1BQU0sSUFBSSxvQkFBWSxDQUFDLGlCQUFpQixTQUFTLFlBQVksQ0FBQyxDQUFDO1FBQ2pFLENBQUM7UUFFRCxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sYUFBYSxHQUFHLE1BQUEsS0FBSyxDQUFDLE9BQU8sMENBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsS0FBSyxrQkFBa0IsQ0FBQyxDQUFDO1FBRTdGLElBQUksQ0FBQyxDQUFBLGFBQWEsYUFBYixhQUFhLHVCQUFiLGFBQWEsQ0FBRSxXQUFXLENBQUEsRUFBRSxDQUFDO1lBQ2hDLE1BQU0sSUFBSSxvQkFBWSxDQUFDLCtEQUErRCxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQ3JHLENBQUM7UUFFRCxNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDN0QsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1lBQzVCLE1BQU0sSUFBSSxvQkFBWSxDQUFDLG1DQUFtQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUN6RixDQUFDO1FBRUQscUVBQXFFO1FBQ3JFLDBFQUEwRTtRQUMxRSxpRkFBaUY7UUFDakYsdUZBQXVGO1FBQ3ZGLEVBQUU7UUFDRixtRUFBbUU7UUFDbkUsc0ZBQXNGO1FBQ3RGLE1BQU0sVUFBVSxHQUFHLE1BQUEsTUFBQSxLQUFLLENBQUMsT0FBTywwQ0FBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxLQUFLLFlBQVksQ0FBQywwQ0FBRSxXQUFXLENBQUM7UUFDakcsNENBQTRDO1FBQzVDLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBRTFHLE9BQU87WUFDTCxnQkFBZ0I7WUFDaEIsZ0JBQWdCO1NBQ2pCLENBQUM7SUFDSixDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNYLE1BQU0sSUFBSSxvQkFBWSxDQUFDLHdDQUF3QyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uLy4uLy4uLy4uL0Bhd3MtY2RrL3RtcC10b29sa2l0LWhlbHBlcnMvc3JjL2FwaS9pby9wcml2YXRlJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vY2xpL21lc3NhZ2VzJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVBbGxvd0Nyb3NzQWNjb3VudEFzc2V0UHVibGlzaGluZyhcbiAgc2RrOiBTREssXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgY3VzdG9tU3RhY2tOYW1lPzogc3RyaW5nLFxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhY2tOYW1lID0gY3VzdG9tU3RhY2tOYW1lIHx8ICdDREtUb29sa2l0JztcbiAgICBjb25zdCBzdGFja0luZm8gPSBhd2FpdCBnZXRCb290c3RyYXBTdGFja0luZm8oc2RrLCBzdGFja05hbWUpO1xuXG4gICAgaWYgKCFzdGFja0luZm8uaGFzU3RhZ2luZ0J1Y2tldCkge1xuICAgICAgLy8gaW5kaWNhdGVzIGFuIGludGVudGlvbmFsIGNyb3NzIGFjY291bnQgc2V0dXBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdGFja0luZm8uYm9vdHN0cmFwVmVyc2lvbiA+PSAyMSkge1xuICAgICAgLy8gYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gMjEgY29udGFpbnMgYSBmaXggdGhhdCB3aWxsIHByZXZlbnQgY3Jvc3NcbiAgICAgIC8vIGFjY291bnQgcHVibGlzaGluZyBvbiB0aGUgSUFNIGxldmVsXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvcHVsbC8zMDgyM1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBzdGFnaW5nIGJ1Y2tldCBBTkQgdGhlIGJvb3RzdHJhcCB2ZXJzaW9uIGlzIG9sZCwgdGhlbiB3ZSB3YW50IHRvIHByb3RlY3RcbiAgICAvLyBhZ2FpbnN0IGFjY2lkZW50YWwgY3Jvc3MtYWNjb3VudCBwdWJsaXNoaW5nLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFlvdSB3b3VsZCB0aGluayB3ZSB3b3VsZCBuZWVkIHRvIGZhaWwgY2xvc2VkIGhlcmUsIGJ1dCB0aGUgcmVhbGl0eSBpc1xuICAgIC8vIHRoYXQgd2UgZ2V0IGhlcmUgaWYgd2UgY291bGRuJ3QgZmluZCB0aGUgYm9vdHN0cmFwIHN0YWNrOiB0aGF0IGlzXG4gICAgLy8gY29tcGxldGVseSB2YWxpZCwgYW5kIG1hbnkgbGFyZ2Ugb3JnYW5pemF0aW9ucyBtYXkgaGF2ZSB0aGVpciBvd24gbWV0aG9kXG4gICAgLy8gb2YgY3JlYXRpbmcgYm9vdHN0cmFwIHJlc291cmNlcy4gSWYgdGhleSBkbywgdGhlcmUncyBub3RoaW5nIGZvciB1cyB0byB2YWxpZGF0ZSxcbiAgICAvLyBidXQgd2UgY2FuJ3QgdXNlIHRoYXQgYXMgYSByZWFzb24gdG8gZGlzYWxsb3cgY3Jvc3MtYWNjb3VudCBwdWJsaXNoaW5nLiBXZSdsbCBqdXN0XG4gICAgLy8gaGF2ZSB0byB0cnVzdCB0aGV5IGRpZCB0aGVpciBkdWUgZGlsaWdlbmNlLiBTbyB3ZSBmYWlsIG9wZW4uXG4gICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KGRlYnVnKGBFcnJvciBkZXRlcm1pbmluZyBjcm9zcyBhY2NvdW50IGFzc2V0IHB1Ymxpc2hpbmc6ICR7ZX1gKSk7XG4gICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KGRlYnVnKCdEZWZhdWx0aW5nIHRvIGFsbG93aW5nIGNyb3NzIGFjY291bnQgYXNzZXQgcHVibGlzaGluZycpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgQm9vdHN0cmFwU3RhY2tJbmZvIHtcbiAgaGFzU3RhZ2luZ0J1Y2tldDogYm9vbGVhbjtcbiAgYm9vdHN0cmFwVmVyc2lvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Qm9vdHN0cmFwU3RhY2tJbmZvKHNkazogU0RLLCBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Qm9vdHN0cmFwU3RhY2tJbmZvPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2ZuID0gc2RrLmNsb3VkRm9ybWF0aW9uKCk7XG4gICAgY29uc3Qgc3RhY2tSZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZVN0YWNrcyh7IFN0YWNrTmFtZTogc3RhY2tOYW1lIH0pO1xuXG4gICAgaWYgKCFzdGFja1Jlc3BvbnNlLlN0YWNrcyB8fCBzdGFja1Jlc3BvbnNlLlN0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFRvb2xraXQgc3RhY2sgJHtzdGFja05hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tSZXNwb25zZS5TdGFja3NbMF07XG4gICAgY29uc3QgdmVyc2lvbk91dHB1dCA9IHN0YWNrLk91dHB1dHM/LmZpbmQob3V0cHV0ID0+IG91dHB1dC5PdXRwdXRLZXkgPT09ICdCb290c3RyYXBWZXJzaW9uJyk7XG5cbiAgICBpZiAoIXZlcnNpb25PdXRwdXQ/Lk91dHB1dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbmFibGUgdG8gZmluZCBCb290c3RyYXBWZXJzaW9uIG91dHB1dCBpbiB0aGUgdG9vbGtpdCBzdGFjayAke3N0YWNrTmFtZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBib290c3RyYXBWZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvbk91dHB1dC5PdXRwdXRWYWx1ZSk7XG4gICAgaWYgKGlzTmFOKGJvb3RzdHJhcFZlcnNpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBJbnZhbGlkIEJvb3RzdHJhcFZlcnNpb24gdmFsdWU6ICR7dmVyc2lvbk91dHB1dC5PdXRwdXRWYWx1ZX1gKTtcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gZ2V0IGJ1Y2tldG5hbWUgZnJvbSB0aGUgbG9naWNhbCByZXNvdXJjZSBpZC4gSWYgdGhlcmUgaXMgbm9cbiAgICAvLyBidWNrZXRuYW1lLCBvciB0aGUgdmFsdWUgZG9lc24ndCBsb29rIGxpa2UgYW4gUzMgYnVja2V0IG5hbWUsIHdlIGFzc3VtZVxuICAgIC8vIHRoZSBidWNrZXQgZG9lc24ndCBleGlzdCAodGhpcyBpcyBmb3IgdGhlIGNhc2Ugd2hlcmUgYSB0ZW1wbGF0ZSBjdXN0b21pemVyIGRpZFxuICAgIC8vIG5vdCBkYXJlIHRvIHJlbW92ZSB0aGUgT3V0cHV0LCBidXQgcHV0IGEgZHVtbXkgdmFsdWUgdGhlcmUgbGlrZSAnJyBvciAnLScgb3IgJyoqKicpLlxuICAgIC8vXG4gICAgLy8gV2Ugd291bGQgaGF2ZSBwcmVmZXJyZWQgdG8gbG9vayBhdCB0aGUgc3RhY2sgcmVzb3VyY2VzIGhlcmUsIGJ1dFxuICAgIC8vIHVuZm9ydHVuYXRlbHkgdGhlIGRlcGxveSByb2xlIGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9ucyBjYWxsIERlc2NyaWJlU3RhY2tSZXNvdXJjZXMuXG4gICAgY29uc3QgYnVja2V0TmFtZSA9IHN0YWNrLk91dHB1dHM/LmZpbmQob3V0cHV0ID0+IG91dHB1dC5PdXRwdXRLZXkgPT09ICdCdWNrZXROYW1lJyk/Lk91dHB1dFZhbHVlO1xuICAgIC8vIE11c3QgYmVnaW4gYW5kIGVuZCB3aXRoIGxldHRlciBvciBudW1iZXIuXG4gICAgY29uc3QgaGFzU3RhZ2luZ0J1Y2tldCA9ICEhKGJ1Y2tldE5hbWUgJiYgYnVja2V0TmFtZS5tYXRjaCgvXlthLXowLTldLykgJiYgYnVja2V0TmFtZS5tYXRjaCgvW2EtejAtOV0kLykpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc1N0YWdpbmdCdWNrZXQsXG4gICAgICBib290c3RyYXBWZXJzaW9uLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBFcnJvciByZXRyaWV2aW5nIHRvb2xraXQgc3RhY2sgaW5mbzogJHtlfWApO1xuICB9XG59XG4iXX0=