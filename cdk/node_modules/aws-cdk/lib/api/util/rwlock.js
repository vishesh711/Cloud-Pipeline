"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RWLock = void 0;
const fs_1 = require("fs");
const path = require("path");
const error_1 = require("../../toolkit/error");
/**
 * A single-writer/multi-reader lock on a directory
 *
 * It uses marker files with PIDs in them as a locking marker; the PIDs will be
 * checked for liveness, so that if the process exits without cleaning up the
 * files the lock is implicitly released.
 *
 * This class is not 100% race safe, but in practice it should be a lot
 * better than the 0 protection we have today.
 */
/* istanbul ignore next: code paths are unpredictable */
class RWLock {
    constructor(directory) {
        this.directory = directory;
        this.readCounter = 0;
        this.pidString = `${process.pid}`;
        this.writerFile = path.join(this.directory, 'synth.lock');
    }
    /**
     * Acquire a writer lock.
     *
     * No other readers or writers must exist for the given directory.
     */
    async acquireWrite() {
        await this.assertNoOtherWriters();
        const readers = await this.currentReaders();
        if (readers.length > 0) {
            throw new error_1.ToolkitError(`Other CLIs (PID=${readers}) are currently reading from ${this.directory}. Invoke the CLI in sequence, or use '--output' to synth into different directories.`);
        }
        await writeFileAtomic(this.writerFile, this.pidString);
        return {
            release: async () => {
                await deleteFile(this.writerFile);
            },
            convertToReaderLock: async () => {
                // Acquire the read lock before releasing the write lock. Slightly less
                // chance of racing!
                const ret = await this.doAcquireRead();
                await deleteFile(this.writerFile);
                return ret;
            },
        };
    }
    /**
     * Acquire a read lock
     *
     * Will fail if there are any writers.
     */
    async acquireRead() {
        await this.assertNoOtherWriters();
        return this.doAcquireRead();
    }
    /**
     * Obtains the name fo a (new) `readerFile` to use. This includes a counter so
     * that if multiple threads of the same PID attempt to concurrently acquire
     * the same lock, they're guaranteed to use a different reader file name (only
     * one thread will ever execute JS code at once, guaranteeing the readCounter
     * is incremented "atomically" from the point of view of this PID.).
     */
    readerFile() {
        return path.join(this.directory, `read.${this.pidString}.${++this.readCounter}.lock`);
    }
    /**
     * Do the actual acquiring of a read lock.
     */
    async doAcquireRead() {
        const readerFile = this.readerFile();
        await writeFileAtomic(readerFile, this.pidString);
        return {
            release: async () => {
                await deleteFile(readerFile);
            },
        };
    }
    async assertNoOtherWriters() {
        const writer = await this.currentWriter();
        if (writer) {
            throw new error_1.ToolkitError(`Another CLI (PID=${writer}) is currently synthing to ${this.directory}. Invoke the CLI in sequence, or use '--output' to synth into different directories.`);
        }
    }
    /**
     * Check the current writer (if any)
     */
    async currentWriter() {
        const contents = await readFileIfExists(this.writerFile);
        if (!contents) {
            return undefined;
        }
        const pid = parseInt(contents, 10);
        if (!processExists(pid)) {
            // Do cleanup of a stray file now
            await deleteFile(this.writerFile);
            return undefined;
        }
        return pid;
    }
    /**
     * Check the current readers (if any)
     */
    async currentReaders() {
        const re = /^read\.([^.]+)\.[^.]+\.lock$/;
        const ret = new Array();
        let children;
        try {
            children = await fs_1.promises.readdir(this.directory, { encoding: 'utf-8' });
        }
        catch (e) {
            // Can't be locked if the directory doesn't exist
            if (e.code === 'ENOENT') {
                return [];
            }
            throw e;
        }
        for (const fname of children) {
            const m = fname.match(re);
            if (m) {
                const pid = parseInt(m[1], 10);
                if (processExists(pid)) {
                    ret.push(pid);
                }
                else {
                    // Do cleanup of a stray file now
                    await deleteFile(path.join(this.directory, fname));
                }
            }
        }
        return ret;
    }
}
exports.RWLock = RWLock;
/* istanbul ignore next: code paths are unpredictable */
async function readFileIfExists(filename) {
    try {
        return await fs_1.promises.readFile(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            return undefined;
        }
        throw e;
    }
}
let tmpCounter = 0;
/* istanbul ignore next: code paths are unpredictable */
async function writeFileAtomic(filename, contents) {
    await fs_1.promises.mkdir(path.dirname(filename), { recursive: true });
    const tmpFile = `${filename}.${process.pid}_${++tmpCounter}`;
    await fs_1.promises.writeFile(tmpFile, contents, { encoding: 'utf-8' });
    await fs_1.promises.rename(tmpFile, filename);
}
/* istanbul ignore next: code paths are unpredictable */
async function deleteFile(filename) {
    try {
        await fs_1.promises.unlink(filename);
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            return;
        }
        throw e;
    }
}
/* istanbul ignore next: code paths are unpredictable */
function processExists(pid) {
    try {
        process.kill(pid, 0);
        return true;
    }
    catch (e) {
        return false;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicndsb2NrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicndsb2NrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJCQUFvQztBQUNwQyw2QkFBNkI7QUFDN0IsK0NBQW1EO0FBRW5EOzs7Ozs7Ozs7R0FTRztBQUNILHdEQUF3RDtBQUN4RCxNQUFhLE1BQU07SUFLakIsWUFBNEIsU0FBaUI7UUFBakIsY0FBUyxHQUFULFNBQVMsQ0FBUTtRQUZyQyxnQkFBVyxHQUFHLENBQUMsQ0FBQztRQUd0QixJQUFJLENBQUMsU0FBUyxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRWxDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLFlBQVk7UUFDdkIsTUFBTSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUVsQyxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUM1QyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDdkIsTUFBTSxJQUFJLG9CQUFZLENBQUMsbUJBQW1CLE9BQU8sZ0NBQWdDLElBQUksQ0FBQyxTQUFTLHNGQUFzRixDQUFDLENBQUM7UUFDekwsQ0FBQztRQUVELE1BQU0sZUFBZSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXZELE9BQU87WUFDTCxPQUFPLEVBQUUsS0FBSyxJQUFJLEVBQUU7Z0JBQ2xCLE1BQU0sVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNwQyxDQUFDO1lBQ0QsbUJBQW1CLEVBQUUsS0FBSyxJQUFJLEVBQUU7Z0JBQzlCLHVFQUF1RTtnQkFDdkUsb0JBQW9CO2dCQUNwQixNQUFNLEdBQUcs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UUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDN0QsTUFBTSxhQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNyQyxDQUFDO0FBRUQsd0RBQXdEO0FBQ3hELEtBQUssVUFBVSxVQUFVLENBQUMsUUFBZ0I7SUFDeEMsSUFBSSxDQUFDO1FBQ0gsTUFBTSxhQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1FBQ2hCLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUN4QixPQUFPO1FBQ1QsQ0FBQztRQUNELE1BQU0sQ0FBQyxDQUFDO0lBQ1YsQ0FBQztBQUNILENBQUM7QUFFRCx3REFBd0Q7QUFDeEQsU0FBUyxhQUFhLENBQUMsR0FBVztJQUNoQyxJQUFJLENBQUM7UUFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyQixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1FBQ1gsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvZXJyb3InO1xuXG4vKipcbiAqIEEgc2luZ2xlLXdyaXRlci9tdWx0aS1yZWFkZXIgbG9jayBvbiBhIGRpcmVjdG9yeVxuICpcbiAqIEl0IHVzZXMgbWFya2VyIGZpbGVzIHdpdGggUElEcyBpbiB0aGVtIGFzIGEgbG9ja2luZyBtYXJrZXI7IHRoZSBQSURzIHdpbGwgYmVcbiAqIGNoZWNrZWQgZm9yIGxpdmVuZXNzLCBzbyB0aGF0IGlmIHRoZSBwcm9jZXNzIGV4aXRzIHdpdGhvdXQgY2xlYW5pbmcgdXAgdGhlXG4gKiBmaWxlcyB0aGUgbG9jayBpcyBpbXBsaWNpdGx5IHJlbGVhc2VkLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbm90IDEwMCUgcmFjZSBzYWZlLCBidXQgaW4gcHJhY3RpY2UgaXQgc2hvdWxkIGJlIGEgbG90XG4gKiBiZXR0ZXIgdGhhbiB0aGUgMCBwcm90ZWN0aW9uIHdlIGhhdmUgdG9kYXkuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjb2RlIHBhdGhzIGFyZSB1bnByZWRpY3RhYmxlICovXG5leHBvcnQgY2xhc3MgUldMb2NrIHtcbiAgcHJpdmF0ZSByZWFkb25seSBwaWRTdHJpbmc6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSB3cml0ZXJGaWxlOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZENvdW50ZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkaXJlY3Rvcnk6IHN0cmluZykge1xuICAgIHRoaXMucGlkU3RyaW5nID0gYCR7cHJvY2Vzcy5waWR9YDtcblxuICAgIHRoaXMud3JpdGVyRmlsZSA9IHBhdGguam9pbih0aGlzLmRpcmVjdG9yeSwgJ3N5bnRoLmxvY2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3F1aXJlIGEgd3JpdGVyIGxvY2suXG4gICAqXG4gICAqIE5vIG90aGVyIHJlYWRlcnMgb3Igd3JpdGVycyBtdXN0IGV4aXN0IGZvciB0aGUgZ2l2ZW4gZGlyZWN0b3J5LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGFjcXVpcmVXcml0ZSgpOiBQcm9taXNlPElXcml0ZXJMb2NrPiB7XG4gICAgYXdhaXQgdGhpcy5hc3NlcnROb090aGVyV3JpdGVycygpO1xuXG4gICAgY29uc3QgcmVhZGVycyA9IGF3YWl0IHRoaXMuY3VycmVudFJlYWRlcnMoKTtcbiAgICBpZiAocmVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBPdGhlciBDTElzIChQSUQ9JHtyZWFkZXJzfSkgYXJlIGN1cnJlbnRseSByZWFkaW5nIGZyb20gJHt0aGlzLmRpcmVjdG9yeX0uIEludm9rZSB0aGUgQ0xJIGluIHNlcXVlbmNlLCBvciB1c2UgJy0tb3V0cHV0JyB0byBzeW50aCBpbnRvIGRpZmZlcmVudCBkaXJlY3Rvcmllcy5gKTtcbiAgICB9XG5cbiAgICBhd2FpdCB3cml0ZUZpbGVBdG9taWModGhpcy53cml0ZXJGaWxlLCB0aGlzLnBpZFN0cmluZyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVsZWFzZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkZWxldGVGaWxlKHRoaXMud3JpdGVyRmlsZSk7XG4gICAgICB9LFxuICAgICAgY29udmVydFRvUmVhZGVyTG9jazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBY3F1aXJlIHRoZSByZWFkIGxvY2sgYmVmb3JlIHJlbGVhc2luZyB0aGUgd3JpdGUgbG9jay4gU2xpZ2h0bHkgbGVzc1xuICAgICAgICAvLyBjaGFuY2Ugb2YgcmFjaW5nIVxuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCB0aGlzLmRvQWNxdWlyZVJlYWQoKTtcbiAgICAgICAgYXdhaXQgZGVsZXRlRmlsZSh0aGlzLndyaXRlckZpbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFjcXVpcmUgYSByZWFkIGxvY2tcbiAgICpcbiAgICogV2lsbCBmYWlsIGlmIHRoZXJlIGFyZSBhbnkgd3JpdGVycy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBhY3F1aXJlUmVhZCgpOiBQcm9taXNlPElMb2NrPiB7XG4gICAgYXdhaXQgdGhpcy5hc3NlcnROb090aGVyV3JpdGVycygpO1xuICAgIHJldHVybiB0aGlzLmRvQWNxdWlyZVJlYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRhaW5zIHRoZSBuYW1lIGZvIGEgKG5ldykgYHJlYWRlckZpbGVgIHRvIHVzZS4gVGhpcyBpbmNsdWRlcyBhIGNvdW50ZXIgc29cbiAgICogdGhhdCBpZiBtdWx0aXBsZSB0aHJlYWRzIG9mIHRoZSBzYW1lIFBJRCBhdHRlbXB0IHRvIGNvbmN1cnJlbnRseSBhY3F1aXJlXG4gICAqIHRoZSBzYW1lIGxvY2ssIHRoZXkncmUgZ3VhcmFudGVlZCB0byB1c2UgYSBkaWZmZXJlbnQgcmVhZGVyIGZpbGUgbmFtZSAob25seVxuICAgKiBvbmUgdGhyZWFkIHdpbGwgZXZlciBleGVjdXRlIEpTIGNvZGUgYXQgb25jZSwgZ3VhcmFudGVlaW5nIHRoZSByZWFkQ291bnRlclxuICAgKiBpcyBpbmNyZW1lbnRlZCBcImF0b21pY2FsbHlcIiBmcm9tIHRoZSBwb2ludCBvZiB2aWV3IG9mIHRoaXMgUElELikuXG4gICAqL1xuICBwcml2YXRlIHJlYWRlckZpbGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMuZGlyZWN0b3J5LCBgcmVhZC4ke3RoaXMucGlkU3RyaW5nfS4keysrdGhpcy5yZWFkQ291bnRlcn0ubG9ja2ApO1xuICB9XG5cbiAgLyoqXG4gICAqIERvIHRoZSBhY3R1YWwgYWNxdWlyaW5nIG9mIGEgcmVhZCBsb2NrLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkb0FjcXVpcmVSZWFkKCk6IFByb21pc2U8SUxvY2s+IHtcbiAgICBjb25zdCByZWFkZXJGaWxlID0gdGhpcy5yZWFkZXJGaWxlKCk7XG4gICAgYXdhaXQgd3JpdGVGaWxlQXRvbWljKHJlYWRlckZpbGUsIHRoaXMucGlkU3RyaW5nKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVsZWFzZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkZWxldGVGaWxlKHJlYWRlckZpbGUpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhc3NlcnROb090aGVyV3JpdGVycygpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBhd2FpdCB0aGlzLmN1cnJlbnRXcml0ZXIoKTtcbiAgICBpZiAod3JpdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBBbm90aGVyIENMSSAoUElEPSR7d3JpdGVyfSkgaXMgY3VycmVudGx5IHN5bnRoaW5nIHRvICR7dGhpcy5kaXJlY3Rvcnl9LiBJbnZva2UgdGhlIENMSSBpbiBzZXF1ZW5jZSwgb3IgdXNlICctLW91dHB1dCcgdG8gc3ludGggaW50byBkaWZmZXJlbnQgZGlyZWN0b3JpZXMuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBjdXJyZW50IHdyaXRlciAoaWYgYW55KVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjdXJyZW50V3JpdGVyKCk6IFByb21pc2U8bnVtYmVyIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgY29udGVudHMgPSBhd2FpdCByZWFkRmlsZUlmRXhpc3RzKHRoaXMud3JpdGVyRmlsZSk7XG4gICAgaWYgKCFjb250ZW50cykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBwaWQgPSBwYXJzZUludChjb250ZW50cywgMTApO1xuICAgIGlmICghcHJvY2Vzc0V4aXN0cyhwaWQpKSB7XG4gICAgICAvLyBEbyBjbGVhbnVwIG9mIGEgc3RyYXkgZmlsZSBub3dcbiAgICAgIGF3YWl0IGRlbGV0ZUZpbGUodGhpcy53cml0ZXJGaWxlKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgY3VycmVudCByZWFkZXJzIChpZiBhbnkpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRSZWFkZXJzKCk6IFByb21pc2U8bnVtYmVyW10+IHtcbiAgICBjb25zdCByZSA9IC9ecmVhZFxcLihbXi5dKylcXC5bXi5dK1xcLmxvY2skLztcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuXG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIHRyeSB7XG4gICAgICBjaGlsZHJlbiA9IGF3YWl0IGZzLnJlYWRkaXIodGhpcy5kaXJlY3RvcnksIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBDYW4ndCBiZSBsb2NrZWQgaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZm5hbWUgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IG0gPSBmbmFtZS5tYXRjaChyZSk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBjb25zdCBwaWQgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgICAgIGlmIChwcm9jZXNzRXhpc3RzKHBpZCkpIHtcbiAgICAgICAgICByZXQucHVzaChwaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvIGNsZWFudXAgb2YgYSBzdHJheSBmaWxlIG5vd1xuICAgICAgICAgIGF3YWl0IGRlbGV0ZUZpbGUocGF0aC5qb2luKHRoaXMuZGlyZWN0b3J5LCBmbmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBhY3F1aXJlZCBsb2NrXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUxvY2sge1xuICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD47XG59XG5cbi8qKlxuICogQW4gYWNxdWlyZWQgd3JpdGVyIGxvY2tcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJV3JpdGVyTG9jayBleHRlbmRzIElMb2NrIHtcbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHdyaXRlciBsb2NrIHRvIGEgcmVhZGVyIGxvY2tcbiAgICovXG4gIGNvbnZlcnRUb1JlYWRlckxvY2soKTogUHJvbWlzZTxJTG9jaz47XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjb2RlIHBhdGhzIGFyZSB1bnByZWRpY3RhYmxlICovXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZUlmRXhpc3RzKGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmcy5yZWFkRmlsZShmaWxlbmFtZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxubGV0IHRtcENvdW50ZXIgPSAwO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGNvZGUgcGF0aHMgYXJlIHVucHJlZGljdGFibGUgKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUF0b21pYyhmaWxlbmFtZTogc3RyaW5nLCBjb250ZW50czogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGZzLm1rZGlyKHBhdGguZGlybmFtZShmaWxlbmFtZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICBjb25zdCB0bXBGaWxlID0gYCR7ZmlsZW5hbWV9LiR7cHJvY2Vzcy5waWR9XyR7Kyt0bXBDb3VudGVyfWA7XG4gIGF3YWl0IGZzLndyaXRlRmlsZSh0bXBGaWxlLCBjb250ZW50cywgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgYXdhaXQgZnMucmVuYW1lKHRtcEZpbGUsIGZpbGVuYW1lKTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGNvZGUgcGF0aHMgYXJlIHVucHJlZGljdGFibGUgKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUZpbGUoZmlsZW5hbWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLnVubGluayhmaWxlbmFtZSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGlmIChlLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGNvZGUgcGF0aHMgYXJlIHVucHJlZGljdGFibGUgKi9cbmZ1bmN0aW9uIHByb2Nlc3NFeGlzdHMocGlkOiBudW1iZXIpIHtcbiAgdHJ5IHtcbiAgICBwcm9jZXNzLmtpbGwocGlkLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl19