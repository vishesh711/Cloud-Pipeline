"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudExecutable = void 0;
const cloud_assembly_1 = require("./cloud-assembly");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const error_1 = require("../../toolkit/error");
/**
 * Represent the Cloud Executable and the synthesis we can do on it
 */
class CloudExecutable {
    constructor(props) {
        this.props = props;
    }
    /**
     * Return whether there is an app command from the configuration
     */
    get hasApp() {
        return !!this.props.configuration.settings.get(['app']);
    }
    /**
     * Synthesize a set of stacks.
     *
     * @param cacheCloudAssembly whether to cache the Cloud Assembly after it has been first synthesized.
     *   This is 'true' by default, and only set to 'false' for 'cdk watch',
     *   which needs to re-synthesize the Assembly each time it detects a change to the project files
     */
    async synthesize(cacheCloudAssembly = true) {
        if (!this._cloudAssembly || !cacheCloudAssembly) {
            this._cloudAssembly = await this.doSynthesize();
        }
        return this._cloudAssembly;
    }
    async doSynthesize() {
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        // (When the executable runs, it will tell us about context it wants to use
        // but it missing. We'll then look up the context and run the executable again, and
        // again, until it doesn't complain anymore or we've stopped making progress).
        let previouslyMissingKeys;
        while (true) {
            const assembly = await this.props.synthesizer(this.props.sdkProvider, this.props.configuration);
            if (assembly.manifest.missing && assembly.manifest.missing.length > 0) {
                const missingKeys = missingContextKeys(assembly.manifest.missing);
                if (!this.canLookup) {
                    throw new error_1.ToolkitError('Context lookups have been disabled. '
                        + 'Make sure all necessary context is already in \'cdk.context.json\' by running \'cdk synth\' on a machine with sufficient AWS credentials and committing the result. '
                        + `Missing context keys: '${Array.from(missingKeys).join(', ')}'`);
                }
                let tryLookup = true;
                if (previouslyMissingKeys && setsEqual(missingKeys, previouslyMissingKeys)) {
                    (0, logging_1.debug)('Not making progress trying to resolve environmental context. Giving up.');
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeys;
                if (tryLookup) {
                    (0, logging_1.debug)('Some context information is missing. Fetching...');
                    await contextproviders.provideContextValues(assembly.manifest.missing, this.props.configuration.context, this.props.sdkProvider);
                    // Cache the new context to disk
                    await this.props.configuration.saveContext();
                    // Execute again
                    continue;
                }
            }
            return new cloud_assembly_1.CloudAssembly(assembly);
        }
    }
    get canLookup() {
        var _a;
        return !!((_a = this.props.configuration.settings.get(['lookups'])) !== null && _a !== void 0 ? _a : true);
    }
}
exports.CloudExecutable = CloudExecutable;
/**
 * Return all keys of missing context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
function setsEqual(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtZXhlY3V0YWJsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkLWV4ZWN1dGFibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EscURBQWlEO0FBRWpELDREQUE0RDtBQUM1RCwyQ0FBc0M7QUFDdEMsK0NBQW1EO0FBeUJuRDs7R0FFRztBQUNILE1BQWEsZUFBZTtJQUcxQixZQUE2QixLQUEyQjtRQUEzQixVQUFLLEdBQUwsS0FBSyxDQUFzQjtJQUN4RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLE1BQU07UUFDZixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksS0FBSyxDQUFDLFVBQVUsQ0FBQyxxQkFBOEIsSUFBSTtRQUN4RCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDaEQsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNsRCxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7SUFFTyxLQUFLLENBQUMsWUFBWTtRQUN4QixpR0FBaUc7UUFDakcsMkVBQTJFO1FBQzNFLG1GQUFtRjtRQUNuRiw4RUFBOEU7UUFDOUUsSUFBSSxxQkFBOEMsQ0FBQztRQUNuRCxPQUFPLElBQUksRUFBRSxDQUFDO1lBQ1osTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRWhHLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUN0RSxNQUFNLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUVsRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO29CQUNwQixNQUFNLElBQUksb0JBQVksQ0FDcEIsc0NBQXNDOzBCQUNwQyxzS0FBc0s7MEJBQ3RLLDBCQUEwQixLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZFLENBQUM7Z0JBRUQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDO2dCQUNyQixJQUFJLHFCQUFxQixJQUFJLFNBQVMsQ0FBQyxXQUFXLEVBQUUscUJBQXFCLENBQUMsRUFBRSxDQUFDO29CQUMzRSxJQUFBLGVBQUssRUFBQyx5RUFBeUUsQ0FBQyxDQUFDO29CQUNqRixTQUFTLEdBQUcsS0FBSyxDQUFDO2dCQUNwQixDQUFDO2dCQUVELHFCQUFxQixHQUFHLFdBQVcsQ0FBQztnQkFFcEMsSUFBSSxTQUFTLEVBQUUsQ0FBQztvQkFDZCxJQUFBLGVBQUssRUFBQyxrREFBa0QsQ0FBQyxDQUFDO29CQUUxRCxNQUFNLGdCQUFnQixDQUFDLG9CQUFvQixDQUN6QyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFDekIsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUUxQixnQ0FBZ0M7b0JBQ2hDLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7b0JBRTdDLGdCQUFnQjtvQkFDaEIsU0FBUztnQkFDWCxDQUFDO1lBQ0gsQ0FBQztZQUVELE9BQU8sSUFBSSw4QkFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7SUFDSCxDQUFDO0lBRUQsSUFBWSxTQUFTOztRQUNuQixPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLG1DQUFJLElBQUksQ0FBQyxDQUFDO0lBQ3hFLENBQUM7Q0FDRjtBQTdFRCwwQ0E2RUM7QUFFRDs7R0FFRztBQUNILFNBQVMsa0JBQWtCLENBQUMsT0FBZ0M7SUFDMUQsT0FBTyxJQUFJLEdBQUcsQ0FBQyxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNsRCxDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUksQ0FBUyxFQUFFLENBQVM7SUFDeEMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN0QixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFDRCxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDZCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7SUFDSCxDQUFDO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQ2xvdWRBc3NlbWJseSB9IGZyb20gJy4vY2xvdWQtYXNzZW1ibHknO1xuaW1wb3J0IHR5cGUgeyBDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vLi4vY2xpL3VzZXItY29uZmlndXJhdGlvbic7XG5pbXBvcnQgKiBhcyBjb250ZXh0cHJvdmlkZXJzIGZyb20gJy4uLy4uL2NvbnRleHQtcHJvdmlkZXJzJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB0eXBlIHsgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbi8qKlxuICogQHJldHVybnMgb3V0cHV0IGRpcmVjdG9yeVxuICovXG5leHBvcnQgdHlwZSBTeW50aGVzaXplciA9IChhd3M6IFNka1Byb3ZpZGVyLCBjb25maWc6IENvbmZpZ3VyYXRpb24pID0+IFByb21pc2U8Y3hhcGkuQ2xvdWRBc3NlbWJseT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xvdWRFeGVjdXRhYmxlUHJvcHMge1xuICAvKipcbiAgICogQXBwbGljYXRpb24gY29uZmlndXJhdGlvbiAoc2V0dGluZ3MgYW5kIGNvbnRleHQpXG4gICAqL1xuICBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBBV1Mgb2JqZWN0ICh1c2VkIGJ5IHN5bnRoZXNpemVyIGFuZCBjb250ZXh0cHJvdmlkZXIpXG4gICAqL1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgdG8gc3ludGhlc2l6ZSB0aGUgYWN0dWFsIHN0YWNrc1xuICAgKi9cbiAgc3ludGhlc2l6ZXI6IFN5bnRoZXNpemVyO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCB0aGUgQ2xvdWQgRXhlY3V0YWJsZSBhbmQgdGhlIHN5bnRoZXNpcyB3ZSBjYW4gZG8gb24gaXRcbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkRXhlY3V0YWJsZSB7XG4gIHByaXZhdGUgX2Nsb3VkQXNzZW1ibHk/OiBDbG91ZEFzc2VtYmx5O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IENsb3VkRXhlY3V0YWJsZVByb3BzKSB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlcmUgaXMgYW4gYXBwIGNvbW1hbmQgZnJvbSB0aGUgY29uZmlndXJhdGlvblxuICAgKi9cbiAgcHVibGljIGdldCBoYXNBcHAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2FwcCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2V0IG9mIHN0YWNrcy5cbiAgICpcbiAgICogQHBhcmFtIGNhY2hlQ2xvdWRBc3NlbWJseSB3aGV0aGVyIHRvIGNhY2hlIHRoZSBDbG91ZCBBc3NlbWJseSBhZnRlciBpdCBoYXMgYmVlbiBmaXJzdCBzeW50aGVzaXplZC5cbiAgICogICBUaGlzIGlzICd0cnVlJyBieSBkZWZhdWx0LCBhbmQgb25seSBzZXQgdG8gJ2ZhbHNlJyBmb3IgJ2NkayB3YXRjaCcsXG4gICAqICAgd2hpY2ggbmVlZHMgdG8gcmUtc3ludGhlc2l6ZSB0aGUgQXNzZW1ibHkgZWFjaCB0aW1lIGl0IGRldGVjdHMgYSBjaGFuZ2UgdG8gdGhlIHByb2plY3QgZmlsZXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzeW50aGVzaXplKGNhY2hlQ2xvdWRBc3NlbWJseTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPENsb3VkQXNzZW1ibHk+IHtcbiAgICBpZiAoIXRoaXMuX2Nsb3VkQXNzZW1ibHkgfHwgIWNhY2hlQ2xvdWRBc3NlbWJseSkge1xuICAgICAgdGhpcy5fY2xvdWRBc3NlbWJseSA9IGF3YWl0IHRoaXMuZG9TeW50aGVzaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbG91ZEFzc2VtYmx5O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBkb1N5bnRoZXNpemUoKTogUHJvbWlzZTxDbG91ZEFzc2VtYmx5PiB7XG4gICAgLy8gV2UgbWF5IG5lZWQgdG8gcnVuIHRoZSBjbG91ZCBleGVjdXRhYmxlIG11bHRpcGxlIHRpbWVzIGluIG9yZGVyIHRvIHNhdGlzZnkgYWxsIG1pc3NpbmcgY29udGV4dFxuICAgIC8vIChXaGVuIHRoZSBleGVjdXRhYmxlIHJ1bnMsIGl0IHdpbGwgdGVsbCB1cyBhYm91dCBjb250ZXh0IGl0IHdhbnRzIHRvIHVzZVxuICAgIC8vIGJ1dCBpdCBtaXNzaW5nLiBXZSdsbCB0aGVuIGxvb2sgdXAgdGhlIGNvbnRleHQgYW5kIHJ1biB0aGUgZXhlY3V0YWJsZSBhZ2FpbiwgYW5kXG4gICAgLy8gYWdhaW4sIHVudGlsIGl0IGRvZXNuJ3QgY29tcGxhaW4gYW55bW9yZSBvciB3ZSd2ZSBzdG9wcGVkIG1ha2luZyBwcm9ncmVzcykuXG4gICAgbGV0IHByZXZpb3VzbHlNaXNzaW5nS2V5czogU2V0PHN0cmluZz4gfCB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgdGhpcy5wcm9wcy5zeW50aGVzaXplcih0aGlzLnByb3BzLnNka1Byb3ZpZGVyLCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyAmJiBhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ0tleXMgPSBtaXNzaW5nQ29udGV4dEtleXMoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhbkxvb2t1cCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgICAgICAnQ29udGV4dCBsb29rdXBzIGhhdmUgYmVlbiBkaXNhYmxlZC4gJ1xuICAgICAgICAgICAgKyAnTWFrZSBzdXJlIGFsbCBuZWNlc3NhcnkgY29udGV4dCBpcyBhbHJlYWR5IGluIFxcJ2Nkay5jb250ZXh0Lmpzb25cXCcgYnkgcnVubmluZyBcXCdjZGsgc3ludGhcXCcgb24gYSBtYWNoaW5lIHdpdGggc3VmZmljaWVudCBBV1MgY3JlZGVudGlhbHMgYW5kIGNvbW1pdHRpbmcgdGhlIHJlc3VsdC4gJ1xuICAgICAgICAgICAgKyBgTWlzc2luZyBjb250ZXh0IGtleXM6ICcke0FycmF5LmZyb20obWlzc2luZ0tleXMpLmpvaW4oJywgJyl9J2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRyeUxvb2t1cCA9IHRydWU7XG4gICAgICAgIGlmIChwcmV2aW91c2x5TWlzc2luZ0tleXMgJiYgc2V0c0VxdWFsKG1pc3NpbmdLZXlzLCBwcmV2aW91c2x5TWlzc2luZ0tleXMpKSB7XG4gICAgICAgICAgZGVidWcoJ05vdCBtYWtpbmcgcHJvZ3Jlc3MgdHJ5aW5nIHRvIHJlc29sdmUgZW52aXJvbm1lbnRhbCBjb250ZXh0LiBHaXZpbmcgdXAuJyk7XG4gICAgICAgICAgdHJ5TG9va3VwID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c2x5TWlzc2luZ0tleXMgPSBtaXNzaW5nS2V5cztcblxuICAgICAgICBpZiAodHJ5TG9va3VwKSB7XG4gICAgICAgICAgZGVidWcoJ1NvbWUgY29udGV4dCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nLiBGZXRjaGluZy4uLicpO1xuXG4gICAgICAgICAgYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhcbiAgICAgICAgICAgIGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcsXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uY29udGV4dCxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuc2RrUHJvdmlkZXIpO1xuXG4gICAgICAgICAgLy8gQ2FjaGUgdGhlIG5ldyBjb250ZXh0IHRvIGRpc2tcbiAgICAgICAgICBhd2FpdCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2F2ZUNvbnRleHQoKTtcblxuICAgICAgICAgIC8vIEV4ZWN1dGUgYWdhaW5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENsb3VkQXNzZW1ibHkoYXNzZW1ibHkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGNhbkxvb2t1cCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2xvb2t1cHMnXSkgPz8gdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIGtleXMgb2YgbWlzc2luZyBjb250ZXh0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIG1pc3NpbmdDb250ZXh0S2V5cyhtaXNzaW5nPzogY3hhcGkuTWlzc2luZ0NvbnRleHRbXSk6IFNldDxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBTZXQoKG1pc3NpbmcgfHwgW10pLm1hcChtID0+IG0ua2V5KSk7XG59XG5cbmZ1bmN0aW9uIHNldHNFcXVhbDxBPihhOiBTZXQ8QT4sIGI6IFNldDxBPikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCB4IG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKHgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl19