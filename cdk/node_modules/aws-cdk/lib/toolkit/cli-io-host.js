"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliIoHost = void 0;
exports.isCI = isCI;
const util = require("node:util");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const chalk = require("chalk");
const promptly = require("promptly");
const error_1 = require("./error");
const private_1 = require("../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
const activity_printer_1 = require("../cli/activity-printer");
const deploy_1 = require("../commands/deploy");
/**
 * A simple IO host for the CLI that writes messages to the console.
 */
class CliIoHost {
    /**
     * Returns the singleton instance
     */
    static instance(props = {}, forceNew = false) {
        if (forceNew || !CliIoHost._instance) {
            CliIoHost._instance = new CliIoHost(props);
        }
        return CliIoHost._instance;
    }
    constructor(props = {}) {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Configure the target stream for notices
         *
         * (Not a setter because there's no need for additional logic when this value
         * is changed yet)
         */
        this.noticesDestination = 'stderr';
        this._progress = deploy_1.StackActivityProgress.BAR;
        // Corked Logging
        this.corkedCounter = 0;
        this.corkedLoggingBuffer = [];
        this.currentAction = (_a = props.currentAction) !== null && _a !== void 0 ? _a : 'none';
        this.isTTY = (_c = (_b = props.isTTY) !== null && _b !== void 0 ? _b : process.stdout.isTTY) !== null && _c !== void 0 ? _c : false;
        this.logLevel = (_d = props.logLevel) !== null && _d !== void 0 ? _d : 'info';
        this.isCI = (_e = props.isCI) !== null && _e !== void 0 ? _e : isCI();
        this.requireDeployApproval = (_f = props.requireDeployApproval) !== null && _f !== void 0 ? _f : cloud_assembly_schema_1.RequireApproval.BROADENING;
        this.stackProgress = (_g = props.stackProgress) !== null && _g !== void 0 ? _g : deploy_1.StackActivityProgress.BAR;
    }
    /**
     * Returns the singleton instance
     */
    registerIoHost(ioHost) {
        if (ioHost !== this) {
            this._internalIoHost = ioHost;
        }
    }
    /**
     * Update the stackProgress preference.
     */
    set stackProgress(type) {
        this._progress = type;
    }
    /**
     * Gets the stackProgress value.
     *
     * This takes into account other state of the ioHost,
     * like if isTTY and isCI.
     */
    get stackProgress() {
        // We can always use EVENTS
        if (this._progress === deploy_1.StackActivityProgress.EVENTS) {
            return this._progress;
        }
        // if a debug message (and thus any more verbose messages) are relevant to the current log level, we have verbose logging
        const verboseLogging = (0, private_1.isMessageRelevantForLevel)({ level: 'debug' }, this.logLevel);
        if (verboseLogging) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On Windows we cannot use fancy output
        const isWindows = process.platform === 'win32';
        if (isWindows) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On some CI systems (such as CircleCI) output still reports as a TTY so we also
        // need an individual check for whether we're running on CI.
        // see: https://discuss.circleci.com/t/circleci-terminal-is-a-tty-but-term-is-not-set/9965
        const fancyOutputAvailable = this.isTTY && !this.isCI;
        if (!fancyOutputAvailable) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // Use the user preference
        return this._progress;
    }
    /**
     * Executes a block of code with corked logging. All log messages during execution
     * are buffered and only written when all nested cork blocks complete (when CORK_COUNTER reaches 0).
     * The corking is bound to the specific instance of the CliIoHost.
     *
     * @param block - Async function to execute with corked logging
     * @returns Promise that resolves with the block's return value
     */
    async withCorkedLogging(block) {
        this.corkedCounter++;
        try {
            return await block();
        }
        finally {
            this.corkedCounter--;
            if (this.corkedCounter === 0) {
                // Process each buffered message through notify
                for (const ioMessage of this.corkedLoggingBuffer) {
                    await this.notify(ioMessage);
                }
                // remove all buffered messages in-place
                this.corkedLoggingBuffer.splice(0);
            }
        }
    }
    /**
     * Notifies the host of a message.
     * The caller waits until the notification completes.
     */
    async notify(msg) {
        if (this._internalIoHost) {
            return this._internalIoHost.notify(msg);
        }
        if (this.isStackActivity(msg)) {
            if (!this.activityPrinter) {
                this.activityPrinter = this.makeActivityPrinter();
            }
            await this.activityPrinter.notify(msg);
            return;
        }
        if (!(0, private_1.isMessageRelevantForLevel)(msg, this.logLevel)) {
            return;
        }
        if (this.corkedCounter > 0) {
            this.corkedLoggingBuffer.push(msg);
            return;
        }
        const output = this.formatMessage(msg);
        const stream = this.selectStream(msg);
        stream === null || stream === void 0 ? void 0 : stream.write(output);
    }
    /**
     * Detect stack activity messages so they can be send to the printer.
     */
    isStackActivity(msg) {
        return [
            'CDK_TOOLKIT_I5501',
            'CDK_TOOLKIT_I5502',
            'CDK_TOOLKIT_I5503',
        ].includes(msg.code);
    }
    /**
     * Detect special messages encode information about whether or not
     * they require approval
     */
    skipApprovalStep(msg) {
        var _a;
        const approvalToolkitCodes = ['CDK_TOOLKIT_I5060'];
        if (!approvalToolkitCodes.includes(msg.code)) {
            false;
        }
        switch (this.requireDeployApproval) {
            // Never require approval
            case cloud_assembly_schema_1.RequireApproval.NEVER:
                return true;
            // Always require approval
            case cloud_assembly_schema_1.RequireApproval.ANYCHANGE:
                return false;
            // Require approval if changes include broadening permissions
            case cloud_assembly_schema_1.RequireApproval.BROADENING:
                return ['none', 'non-broadening'].includes((_a = msg.data) === null || _a === void 0 ? void 0 : _a.permissionChangeType);
        }
    }
    /**
     * Determines the output stream, based on message and configuration.
     */
    selectStream(msg) {
        if (isNoticesMessage(msg)) {
            return targetStreamObject(this.noticesDestination);
        }
        return this.selectStreamFromLevel(msg.level);
    }
    /**
     * Determines the output stream, based on message level and configuration.
     */
    selectStreamFromLevel(level) {
        // The stream selection policy for the CLI is the following:
        //
        //   (1) Messages of level `result` always go to `stdout`
        //   (2) Messages of level `error` always go to `stderr`.
        //   (3a) All remaining messages go to `stderr`.
        //   (3b) If we are in CI mode, all remaining messages go to `stdout`.
        //
        switch (level) {
            case 'error':
                return process.stderr;
            case 'result':
                return process.stdout;
            default:
                return this.isCI ? process.stdout : process.stderr;
        }
    }
    /**
     * Notifies the host of a message that requires a response.
     *
     * If the host does not return a response the suggested
     * default response from the input message will be used.
     */
    async requestResponse(msg) {
        // First call out to a registered instance if we have one
        if (this._internalIoHost) {
            return this._internalIoHost.requestResponse(msg);
        }
        // If the request cannot be prompted for by the CliIoHost, we just accept the default
        if (!isPromptableRequest(msg)) {
            await this.notify(msg);
            return msg.defaultResponse;
        }
        const response = await this.withCorkedLogging(async () => {
            var _a, _b, _c;
            // prepare prompt data
            // @todo this format is not defined anywhere, probably should be
            const data = (_a = msg.data) !== null && _a !== void 0 ? _a : {};
            const motivation = (_b = data.motivation) !== null && _b !== void 0 ? _b : 'User input is needed';
            const concurrency = (_c = data.concurrency) !== null && _c !== void 0 ? _c : 0;
            // only talk to user if STDIN is a terminal (otherwise, fail)
            if (!this.isTTY) {
                throw new error_1.ToolkitError(`${motivation}, but terminal (TTY) is not attached so we are unable to get a confirmation from the user`);
            }
            // only talk to user if concurrency is 1 (otherwise, fail)
            if (concurrency > 1) {
                throw new error_1.ToolkitError(`${motivation}, but concurrency is greater than 1 so we are unable to get a confirmation from the user`);
            }
            // Special approval prompt
            // Determine if the message needs approval. If it does, continue (it is a basic confirmation prompt)
            // If it does not, return success (true). We only check messages with codes that we are aware
            // are requires approval codes.
            if (this.skipApprovalStep(msg)) {
                return true;
            }
            // Basic confirmation prompt
            // We treat all requests with a boolean response as confirmation prompts
            if (isConfirmationPrompt(msg)) {
                const confirmed = await promptly.confirm(`${chalk.cyan(msg.message)} (y/n)`);
                if (!confirmed) {
                    throw new error_1.ToolkitError('Aborted by user');
                }
                return confirmed;
            }
            // Asking for a specific value
            const prompt = extractPromptInfo(msg);
            const answer = await promptly.prompt(`${chalk.cyan(msg.message)} (${prompt.default})`, {
                default: prompt.default,
            });
            return prompt.convertAnswer(answer);
        });
        // We need to cast this because it is impossible to narrow the generic type
        // isPromptableRequest ensures that the response type is one we can prompt for
        // the remaining code ensure we are indeed returning the correct type
        return response;
    }
    /**
     * Formats a message for console output with optional color support
     */
    formatMessage(msg) {
        // apply provided style or a default style if we're in TTY mode
        let message_text = this.isTTY
            ? styleMap[msg.level](msg.message)
            : msg.message;
        // prepend timestamp if IoMessageLevel is DEBUG or TRACE. Postpend a newline.
        return ((msg.level === 'debug' || msg.level === 'trace')
            ? `[${this.formatTime(msg.time)}] ${message_text}`
            : message_text) + '\n';
    }
    /**
     * Formats date to HH:MM:SS
     */
    formatTime(d) {
        const pad = (n) => n.toString().padStart(2, '0');
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }
    /**
     * Get an instance of the ActivityPrinter
     */
    makeActivityPrinter() {
        const props = {
            stream: this.selectStreamFromLevel('info'),
        };
        switch (this.stackProgress) {
            case deploy_1.StackActivityProgress.EVENTS:
                return new activity_printer_1.HistoryActivityPrinter(props);
            case deploy_1.StackActivityProgress.BAR:
                return new activity_printer_1.CurrentActivityPrinter(props);
        }
    }
}
exports.CliIoHost = CliIoHost;
/**
 * This IoHost implementation considers a request promptable, if:
 * - it's a yes/no confirmation
 * - asking for a string or number value
 */
function isPromptableRequest(msg) {
    return isConfirmationPrompt(msg)
        || typeof msg.defaultResponse === 'string'
        || typeof msg.defaultResponse === 'number';
}
/**
 * Check if the request is a confirmation prompt
 * We treat all requests with a boolean response as confirmation prompts
 */
function isConfirmationPrompt(msg) {
    return typeof msg.defaultResponse === 'boolean';
}
/**
 * Helper to extract information for promptly from the request
 */
function extractPromptInfo(msg) {
    const isNumber = (typeof msg.defaultResponse === 'number');
    return {
        default: util.format(msg.defaultResponse),
        convertAnswer: isNumber ? (v) => Number(v) : (v) => String(v),
    };
}
const styleMap = {
    error: chalk.red,
    warn: chalk.yellow,
    result: chalk.white,
    info: chalk.white,
    debug: chalk.gray,
    trace: chalk.gray,
};
/**
 * Returns true if the current process is running in a CI environment
 * @returns true if the current process is running in a CI environment
 */
function isCI() {
    return process.env.CI !== undefined && process.env.CI !== 'false' && process.env.CI !== '0';
}
function targetStreamObject(x) {
    switch (x) {
        case 'stderr':
            return process.stderr;
        case 'stdout':
            return process.stdout;
        case 'drop':
            return undefined;
    }
}
function isNoticesMessage(msg) {
    return private_1.IO.CDK_TOOLKIT_I0100.is(msg) || private_1.IO.CDK_TOOLKIT_W0101.is(msg) || private_1.IO.CDK_TOOLKIT_E0101.is(msg) || private_1.IO.CDK_TOOLKIT_I0101.is(msg);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLWlvLWhvc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbGktaW8taG9zdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFxZUEsb0JBRUM7QUF2ZUQsa0NBQWtDO0FBQ2xDLDBFQUFpRTtBQUNqRSwrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLG1DQUF1QztBQUV2QyxzRkFBeUc7QUFFekcsOERBQXlGO0FBQ3pGLCtDQUEyRDtBQXFFM0Q7O0dBRUc7QUFDSCxNQUFhLFNBQVM7SUFDcEI7O09BRUc7SUFDSCxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQXdCLEVBQUUsRUFBRSxRQUFRLEdBQUcsS0FBSztRQUMxRCxJQUFJLFFBQVEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyQyxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFDRCxPQUFPLFNBQVMsQ0FBQyxTQUFTLENBQUM7SUFDN0IsQ0FBQztJQXNERCxZQUFvQixRQUF3QixFQUFFOztRQWxCOUM7Ozs7O1dBS0c7UUFDSSx1QkFBa0IsR0FBaUIsUUFBUSxDQUFDO1FBRzNDLGNBQVMsR0FBMEIsOEJBQXFCLENBQUMsR0FBRyxDQUFDO1FBS3JFLGlCQUFpQjtRQUNULGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ1Qsd0JBQW1CLEdBQXlCLEVBQUUsQ0FBQztRQUc5RCxJQUFJLENBQUMsYUFBYSxHQUFHLE1BQUEsS0FBSyxDQUFDLGFBQWEsbUNBQUksTUFBTSxDQUFDO1FBQ25ELElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBQSxNQUFBLEtBQUssQ0FBQyxLQUFLLG1DQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxtQ0FBSSxLQUFLLENBQUM7UUFDMUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFBLEtBQUssQ0FBQyxRQUFRLG1DQUFJLE1BQU0sQ0FBQztRQUN6QyxJQUFJLENBQUMsSUFBSSxHQUFH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QUFDLE1BQU0sQ0FBQztRQUN4QixLQUFLLFFBQVE7WUFDWCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDeEIsS0FBSyxNQUFNO1lBQ1QsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztBQUNILENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUFDLEdBQXVCO0lBQy9DLE9BQU8sWUFBRSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxZQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFlBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksWUFBRSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN0SSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IHsgUmVxdWlyZUFwcHJvdmFsIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIHByb21wdGx5IGZyb20gJ3Byb21wdGx5JztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgdHlwZSBJSW9Ib3N0LCB0eXBlIElvTWVzc2FnZSwgdHlwZSBJb01lc3NhZ2VDb2RlLCB0eXBlIElvTWVzc2FnZUxldmVsLCB0eXBlIElvUmVxdWVzdCwgdHlwZSBUb29sa2l0QWN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvJztcbmltcG9ydCB7IElPLCBpc01lc3NhZ2VSZWxldmFudEZvckxldmVsIH0gZnJvbSAnLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBBY3Rpdml0eVByaW50ZXJQcm9wcywgSUFjdGl2aXR5UHJpbnRlciB9IGZyb20gJy4uL2NsaS9hY3Rpdml0eS1wcmludGVyJztcbmltcG9ydCB7IEN1cnJlbnRBY3Rpdml0eVByaW50ZXIsIEhpc3RvcnlBY3Rpdml0eVByaW50ZXIgfSBmcm9tICcuLi9jbGkvYWN0aXZpdHktcHJpbnRlcic7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MgfSBmcm9tICcuLi9jb21tYW5kcy9kZXBsb3knO1xuXG5leHBvcnQgdHlwZSB7IElJb0hvc3QsIElvTWVzc2FnZSwgSW9NZXNzYWdlQ29kZSwgSW9NZXNzYWdlTGV2ZWwsIElvUmVxdWVzdCB9O1xuXG50eXBlIENsaUFjdGlvbiA9XG58IFRvb2xraXRBY3Rpb25cbnwgJ2NvbnRleHQnXG58ICdkb2NzJ1xufCAnbm90aWNlcydcbnwgJ3ZlcnNpb24nXG58ICdub25lJztcblxuZXhwb3J0IGludGVyZmFjZSBDbGlJb0hvc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBUb29sa2l0IGFjdGlvbiB0aGUgaG9zdHMgc3RhcnRzIHdpdGguXG4gICAqXG4gICAqIEBkZWZhdWx0ICdub25lJ1xuICAgKi9cbiAgcmVhZG9ubHkgY3VycmVudEFjdGlvbj86IFRvb2xraXRBY3Rpb247XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHZlcmJvc2l0eSBvZiB0aGUgb3V0cHV0LlxuICAgKlxuICAgKiBUaGUgQ2xpSW9Ib3N0IHdpbGwgc3RpbGwgcmVjZWl2ZSBhbGwgbWVzc2FnZXMgYW5kIHJlcXVlc3RzLFxuICAgKiBidXQgb25seSB0aGUgbWVzc2FnZXMgaW5jbHVkZWQgaW4gdGhpcyBsZXZlbCB3aWxsIGJlIHByaW50ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0ICdpbmZvJ1xuICAgKi9cbiAgcmVhZG9ubHkgbG9nTGV2ZWw/OiBJb01lc3NhZ2VMZXZlbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWMgVFRZIGRldGVjdGlvbi5cbiAgICpcbiAgICogV2hlbiBUVFkgaXMgZGlzYWJsZWQsIHRoZSBDTEkgd2lsbCBoYXZlIG5vIGludGVyYWN0aW9ucyBvciBjb2xvci5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBkZXRlcm1pbmVkIGZyb20gdGhlIGN1cnJlbnQgcHJvY2Vzc1xuICAgKi9cbiAgcmVhZG9ubHkgaXNUVFk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDbGlJb0hvc3QgaXMgcnVubmluZyBpbiBDSSBtb2RlLlxuICAgKlxuICAgKiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAgICogU2V0IHRvIGZhbHNlIGluIHRoZSBDbGlJb0hvc3QgY29uc3RydWN0b3IgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBpZiB0aGUgQ0xJIENJIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRldGVybWluZWQgZnJvbSB0aGUgZW52aXJvbm1lbnQsIHNwZWNpZmljYWxseSBiYXNlZCBvbiBgcHJvY2Vzcy5lbnYuQ0lgXG4gICAqL1xuICByZWFkb25seSBpc0NJPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW4gd2hhdCBzY2VuYXJpb3Mgc2hvdWxkIHRoZSBDbGlJb0hvc3QgYXNrIGZvciBhcHByb3ZhbFxuICAgKlxuICAgKiBAZGVmYXVsdCBSZXF1aXJlQXBwcm92YWwuQlJPQURFTklOR1xuICAgKi9cbiAgcmVhZG9ubHkgcmVxdWlyZURlcGxveUFwcHJvdmFsPzogUmVxdWlyZUFwcHJvdmFsO1xuXG4gIC8qXG4gICAqIFRoZSBpbml0aWFsIFRvb2xraXQgYWN0aW9uIHRoZSBob3N0cyBzdGFydHMgd2l0aC5cbiAgICpcbiAgICogQGRlZmF1bHQgU3RhY2tBY3Rpdml0eVByb2dyZXNzLkJBUlxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tQcm9ncmVzcz86IFN0YWNrQWN0aXZpdHlQcm9ncmVzcztcbn1cblxuLyoqXG4gKiBBIHR5cGUgZm9yIGNvbmZpZ3VyaW5nIGEgdGFyZ2V0IHN0cmVhbVxuICovXG5leHBvcnQgdHlwZSBUYXJnZXRTdHJlYW0gPSAnc3Rkb3V0JyB8ICdzdGRlcnInIHwgJ2Ryb3AnO1xuXG4vKipcbiAqIEEgc2ltcGxlIElPIGhvc3QgZm9yIHRoZSBDTEkgdGhhdCB3cml0ZXMgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGlJb0hvc3QgaW1wbGVtZW50cyBJSW9Ib3N0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKHByb3BzOiBDbGlJb0hvc3RQcm9wcyA9IHt9LCBmb3JjZU5ldyA9IGZhbHNlKTogQ2xpSW9Ib3N0IHtcbiAgICBpZiAoZm9yY2VOZXcgfHwgIUNsaUlvSG9zdC5faW5zdGFuY2UpIHtcbiAgICAgIENsaUlvSG9zdC5faW5zdGFuY2UgPSBuZXcgQ2xpSW9Ib3N0KHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIENsaUlvSG9zdC5faW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogU2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBDbGlJb0hvc3RcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZTogQ2xpSW9Ib3N0IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBhY3Rpb24gYmVpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDTEkuXG4gICAqL1xuICBwdWJsaWMgY3VycmVudEFjdGlvbjogQ2xpQWN0aW9uO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDbGlJb0hvc3QgaXMgcnVubmluZyBpbiBDSSBtb2RlLlxuICAgKlxuICAgKiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAgICovXG4gIHB1YmxpYyBpc0NJOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBob3N0IGNhbiB1c2UgaW50ZXJhY3Rpb25zIGFuZCBtZXNzYWdlIHN0eWxpbmcuXG4gICAqL1xuICBwdWJsaWMgaXNUVFk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRocmVzaG9sZC5cbiAgICpcbiAgICogTWVzc2FnZXMgd2l0aCBhIGxvd2VyIHByaW9yaXR5IGxldmVsIHdpbGwgYmUgaWdub3JlZC5cbiAgICovXG4gIHB1YmxpYyBsb2dMZXZlbDogSW9NZXNzYWdlTGV2ZWw7XG5cbiAgLyoqXG4gICAqIFRoZSBjb25kaXRpb25zIGZvciByZXF1aXJpbmcgYXBwcm92YWwgaW4gdGhpcyBDbGlJb0hvc3QuXG4gICAqL1xuICBwdWJsaWMgcmVxdWlyZURlcGxveUFwcHJvdmFsOiBSZXF1aXJlQXBwcm92YWw7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSB0aGUgdGFyZ2V0IHN0cmVhbSBmb3Igbm90aWNlc1xuICAgKlxuICAgKiAoTm90IGEgc2V0dGVyIGJlY2F1c2UgdGhlcmUncyBubyBuZWVkIGZvciBhZGRpdGlvbmFsIGxvZ2ljIHdoZW4gdGhpcyB2YWx1ZVxuICAgKiBpcyBjaGFuZ2VkIHlldClcbiAgICovXG4gIHB1YmxpYyBub3RpY2VzRGVzdGluYXRpb246IFRhcmdldFN0cmVhbSA9ICdzdGRlcnInO1xuXG4gIHByaXZhdGUgX2ludGVybmFsSW9Ib3N0PzogSUlvSG9zdDtcbiAgcHJpdmF0ZSBfcHJvZ3Jlc3M6IFN0YWNrQWN0aXZpdHlQcm9ncmVzcyA9IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CQVI7XG5cbiAgLy8gU3RhY2sgQWN0aXZpdHkgUHJpbnRlclxuICBwcml2YXRlIGFjdGl2aXR5UHJpbnRlcj86IElBY3Rpdml0eVByaW50ZXI7XG5cbiAgLy8gQ29ya2VkIExvZ2dpbmdcbiAgcHJpdmF0ZSBjb3JrZWRDb3VudGVyID0gMDtcbiAgcHJpdmF0ZSByZWFkb25seSBjb3JrZWRMb2dnaW5nQnVmZmVyOiBJb01lc3NhZ2U8dW5rbm93bj5bXSA9IFtdO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJvcHM6IENsaUlvSG9zdFByb3BzID0ge30pIHtcbiAgICB0aGlzLmN1cnJlbnRBY3Rpb24gPSBwcm9wcy5jdXJyZW50QWN0aW9uID8/ICdub25lJztcbiAgICB0aGlzLmlzVFRZID0gcHJvcHMuaXNUVFkgPz8gcHJvY2Vzcy5zdGRvdXQuaXNUVFkgPz8gZmFsc2U7XG4gICAgdGhpcy5sb2dMZXZlbCA9IHByb3BzLmxvZ0xldmVsID8/ICdpbmZvJztcbiAgICB0aGlzLmlzQ0kgPSBwcm9wcy5pc0NJID8/IGlzQ0koKTtcbiAgICB0aGlzLnJlcXVpcmVEZXBsb3lBcHByb3ZhbCA9IHByb3BzLnJlcXVpcmVEZXBsb3lBcHByb3ZhbCA/PyBSZXF1aXJlQXBwcm92YWwuQlJPQURFTklORztcblxuICAgIHRoaXMuc3RhY2tQcm9ncmVzcyA9IHByb3BzLnN0YWNrUHJvZ3Jlc3MgPz8gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkJBUjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlcklvSG9zdChpb0hvc3Q6IElJb0hvc3QpIHtcbiAgICBpZiAoaW9Ib3N0ICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbElvSG9zdCA9IGlvSG9zdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdGFja1Byb2dyZXNzIHByZWZlcmVuY2UuXG4gICAqL1xuICBwdWJsaWMgc2V0IHN0YWNrUHJvZ3Jlc3ModHlwZTogU3RhY2tBY3Rpdml0eVByb2dyZXNzKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YWNrUHJvZ3Jlc3MgdmFsdWUuXG4gICAqXG4gICAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IG90aGVyIHN0YXRlIG9mIHRoZSBpb0hvc3QsXG4gICAqIGxpa2UgaWYgaXNUVFkgYW5kIGlzQ0kuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrUHJvZ3Jlc3MoKTogU3RhY2tBY3Rpdml0eVByb2dyZXNzIHtcbiAgICAvLyBXZSBjYW4gYWx3YXlzIHVzZSBFVkVOVFNcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3MgPT09IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5FVkVOVFMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgICB9XG5cbiAgICAvLyBpZiBhIGRlYnVnIG1lc3NhZ2UgKGFuZCB0aHVzIGFueSBtb3JlIHZlcmJvc2UgbWVzc2FnZXMpIGFyZSByZWxldmFudCB0byB0aGUgY3VycmVudCBsb2cgbGV2ZWwsIHdlIGhhdmUgdmVyYm9zZSBsb2dnaW5nXG4gICAgY29uc3QgdmVyYm9zZUxvZ2dpbmcgPSBpc01lc3NhZ2VSZWxldmFudEZvckxldmVsKHsgbGV2ZWw6ICdkZWJ1ZycgfSwgdGhpcy5sb2dMZXZlbCk7XG4gICAgaWYgKHZlcmJvc2VMb2dnaW5nKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBPbiBXaW5kb3dzIHdlIGNhbm5vdCB1c2UgZmFuY3kgb3V0cHV0XG4gICAgY29uc3QgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBPbiBzb21lIENJIHN5c3RlbXMgKHN1Y2ggYXMgQ2lyY2xlQ0kpIG91dHB1dCBzdGlsbCByZXBvcnRzIGFzIGEgVFRZIHNvIHdlIGFsc29cbiAgICAvLyBuZWVkIGFuIGluZGl2aWR1YWwgY2hlY2sgZm9yIHdoZXRoZXIgd2UncmUgcnVubmluZyBvbiBDSS5cbiAgICAvLyBzZWU6IGh0dHBzOi8vZGlzY3Vzcy5jaXJjbGVjaS5jb20vdC9jaXJjbGVjaS10ZXJtaW5hbC1pcy1hLXR0eS1idXQtdGVybS1pcy1ub3Qtc2V0Lzk5NjVcbiAgICBjb25zdCBmYW5jeU91dHB1dEF2YWlsYWJsZSA9IHRoaXMuaXNUVFkgJiYgIXRoaXMuaXNDSTtcbiAgICBpZiAoIWZhbmN5T3V0cHV0QXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHVzZXIgcHJlZmVyZW5jZVxuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGJsb2NrIG9mIGNvZGUgd2l0aCBjb3JrZWQgbG9nZ2luZy4gQWxsIGxvZyBtZXNzYWdlcyBkdXJpbmcgZXhlY3V0aW9uXG4gICAqIGFyZSBidWZmZXJlZCBhbmQgb25seSB3cml0dGVuIHdoZW4gYWxsIG5lc3RlZCBjb3JrIGJsb2NrcyBjb21wbGV0ZSAod2hlbiBDT1JLX0NPVU5URVIgcmVhY2hlcyAwKS5cbiAgICogVGhlIGNvcmtpbmcgaXMgYm91bmQgdG8gdGhlIHNwZWNpZmljIGluc3RhbmNlIG9mIHRoZSBDbGlJb0hvc3QuXG4gICAqXG4gICAqIEBwYXJhbSBibG9jayAtIEFzeW5jIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2l0aCBjb3JrZWQgbG9nZ2luZ1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYmxvY2sncyByZXR1cm4gdmFsdWVcbiAgICovXG4gIHB1YmxpYyBhc3luYyB3aXRoQ29ya2VkTG9nZ2luZzxUPihibG9jazogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHRoaXMuY29ya2VkQ291bnRlcisrO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYmxvY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5jb3JrZWRDb3VudGVyLS07XG4gICAgICBpZiAodGhpcy5jb3JrZWRDb3VudGVyID09PSAwKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBidWZmZXJlZCBtZXNzYWdlIHRocm91Z2ggbm90aWZ5XG4gICAgICAgIGZvciAoY29uc3QgaW9NZXNzYWdlIG9mIHRoaXMuY29ya2VkTG9nZ2luZ0J1ZmZlcikge1xuICAgICAgICAgIGF3YWl0IHRoaXMubm90aWZ5KGlvTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBidWZmZXJlZCBtZXNzYWdlcyBpbi1wbGFjZVxuICAgICAgICB0aGlzLmNvcmtlZExvZ2dpbmdCdWZmZXIuc3BsaWNlKDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGUgaG9zdCBvZiBhIG1lc3NhZ2UuXG4gICAqIFRoZSBjYWxsZXIgd2FpdHMgdW50aWwgdGhlIG5vdGlmaWNhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbm90aWZ5KG1zZzogSW9NZXNzYWdlPHVua25vd24+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX2ludGVybmFsSW9Ib3N0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxJb0hvc3Qubm90aWZ5KG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTdGFja0FjdGl2aXR5KG1zZykpIHtcbiAgICAgIGlmICghdGhpcy5hY3Rpdml0eVByaW50ZXIpIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVByaW50ZXIgPSB0aGlzLm1ha2VBY3Rpdml0eVByaW50ZXIoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuYWN0aXZpdHlQcmludGVyLm5vdGlmeShtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNNZXNzYWdlUmVsZXZhbnRGb3JMZXZlbChtc2csIHRoaXMubG9nTGV2ZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29ya2VkQ291bnRlciA+IDApIHtcbiAgICAgIHRoaXMuY29ya2VkTG9nZ2luZ0J1ZmZlci5wdXNoKG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5mb3JtYXRNZXNzYWdlKG1zZyk7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zZWxlY3RTdHJlYW0obXNnKTtcbiAgICBzdHJlYW0/LndyaXRlKG91dHB1dCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHN0YWNrIGFjdGl2aXR5IG1lc3NhZ2VzIHNvIHRoZXkgY2FuIGJlIHNlbmQgdG8gdGhlIHByaW50ZXIuXG4gICAqL1xuICBwcml2YXRlIGlzU3RhY2tBY3Rpdml0eShtc2c6IElvTWVzc2FnZTx1bmtub3duPikge1xuICAgIHJldHVybiBbXG4gICAgICAnQ0RLX1RPT0xLSVRfSTU1MDEnLFxuICAgICAgJ0NES19UT09MS0lUX0k1NTAyJyxcbiAgICAgICdDREtfVE9PTEtJVF9JNTUwMycsXG4gICAgXS5pbmNsdWRlcyhtc2cuY29kZSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHNwZWNpYWwgbWVzc2FnZXMgZW5jb2RlIGluZm9ybWF0aW9uIGFib3V0IHdoZXRoZXIgb3Igbm90XG4gICAqIHRoZXkgcmVxdWlyZSBhcHByb3ZhbFxuICAgKi9cbiAgcHJpdmF0ZSBza2lwQXBwcm92YWxTdGVwKG1zZzogSW9SZXF1ZXN0PGFueSwgYW55Pik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGFwcHJvdmFsVG9vbGtpdENvZGVzID0gWydDREtfVE9PTEtJVF9JNTA2MCddO1xuICAgIGlmICghYXBwcm92YWxUb29sa2l0Q29kZXMuaW5jbHVkZXMobXNnLmNvZGUpKSB7XG4gICAgICBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmVxdWlyZURlcGxveUFwcHJvdmFsKSB7XG4gICAgICAvLyBOZXZlciByZXF1aXJlIGFwcHJvdmFsXG4gICAgICBjYXNlIFJlcXVpcmVBcHByb3ZhbC5ORVZFUjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAvLyBBbHdheXMgcmVxdWlyZSBhcHByb3ZhbFxuICAgICAgY2FzZSBSZXF1aXJlQXBwcm92YWwuQU5ZQ0hBTkdFOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBSZXF1aXJlIGFwcHJvdmFsIGlmIGNoYW5nZXMgaW5jbHVkZSBicm9hZGVuaW5nIHBlcm1pc3Npb25zXG4gICAgICBjYXNlIFJlcXVpcmVBcHByb3ZhbC5CUk9BREVOSU5HOlxuICAgICAgICByZXR1cm4gWydub25lJywgJ25vbi1icm9hZGVuaW5nJ10uaW5jbHVkZXMobXNnLmRhdGE/LnBlcm1pc3Npb25DaGFuZ2VUeXBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgb3V0cHV0IHN0cmVhbSwgYmFzZWQgb24gbWVzc2FnZSBhbmQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgc2VsZWN0U3RyZWFtKG1zZzogSW9NZXNzYWdlPGFueT4pOiBOb2RlSlMuV3JpdGVTdHJlYW0gfCB1bmRlZmluZWQge1xuICAgIGlmIChpc05vdGljZXNNZXNzYWdlKG1zZykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRTdHJlYW1PYmplY3QodGhpcy5ub3RpY2VzRGVzdGluYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNlbGVjdFN0cmVhbUZyb21MZXZlbChtc2cubGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG91dHB1dCBzdHJlYW0sIGJhc2VkIG9uIG1lc3NhZ2UgbGV2ZWwgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwcml2YXRlIHNlbGVjdFN0cmVhbUZyb21MZXZlbChsZXZlbDogSW9NZXNzYWdlTGV2ZWwpOiBOb2RlSlMuV3JpdGVTdHJlYW0ge1xuICAgIC8vIFRoZSBzdHJlYW0gc2VsZWN0aW9uIHBvbGljeSBmb3IgdGhlIENMSSBpcyB0aGUgZm9sbG93aW5nOlxuICAgIC8vXG4gICAgLy8gICAoMSkgTWVzc2FnZXMgb2YgbGV2ZWwgYHJlc3VsdGAgYWx3YXlzIGdvIHRvIGBzdGRvdXRgXG4gICAgLy8gICAoMikgTWVzc2FnZXMgb2YgbGV2ZWwgYGVycm9yYCBhbHdheXMgZ28gdG8gYHN0ZGVycmAuXG4gICAgLy8gICAoM2EpIEFsbCByZW1haW5pbmcgbWVzc2FnZXMgZ28gdG8gYHN0ZGVycmAuXG4gICAgLy8gICAoM2IpIElmIHdlIGFyZSBpbiBDSSBtb2RlLCBhbGwgcmVtYWluaW5nIG1lc3NhZ2VzIGdvIHRvIGBzdGRvdXRgLlxuICAgIC8vXG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRlcnI7XG4gICAgICBjYXNlICdyZXN1bHQnOlxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5pc0NJID8gcHJvY2Vzcy5zdGRvdXQgOiBwcm9jZXNzLnN0ZGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGhvc3Qgb2YgYSBtZXNzYWdlIHRoYXQgcmVxdWlyZXMgYSByZXNwb25zZS5cbiAgICpcbiAgICogSWYgdGhlIGhvc3QgZG9lcyBub3QgcmV0dXJuIGEgcmVzcG9uc2UgdGhlIHN1Z2dlc3RlZFxuICAgKiBkZWZhdWx0IHJlc3BvbnNlIGZyb20gdGhlIGlucHV0IG1lc3NhZ2Ugd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlcXVlc3RSZXNwb25zZTxEYXRhVHlwZSwgUmVzcG9uc2VUeXBlPihtc2c6IElvUmVxdWVzdDxEYXRhVHlwZSwgUmVzcG9uc2VUeXBlPik6IFByb21pc2U8UmVzcG9uc2VUeXBlPiB7XG4gICAgLy8gRmlyc3QgY2FsbCBvdXQgdG8gYSByZWdpc3RlcmVkIGluc3RhbmNlIGlmIHdlIGhhdmUgb25lXG4gICAgaWYgKHRoaXMuX2ludGVybmFsSW9Ib3N0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxJb0hvc3QucmVxdWVzdFJlc3BvbnNlKG1zZyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgY2Fubm90IGJlIHByb21wdGVkIGZvciBieSB0aGUgQ2xpSW9Ib3N0LCB3ZSBqdXN0IGFjY2VwdCB0aGUgZGVmYXVsdFxuICAgIGlmICghaXNQcm9tcHRhYmxlUmVxdWVzdChtc2cpKSB7XG4gICAgICBhd2FpdCB0aGlzLm5vdGlmeShtc2cpO1xuICAgICAgcmV0dXJuIG1zZy5kZWZhdWx0UmVzcG9uc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndpdGhDb3JrZWRMb2dnaW5nKGFzeW5jICgpOiBQcm9taXNlPHN0cmluZyB8IG51bWJlciB8IHRydWU+ID0+IHtcbiAgICAgIC8vIHByZXBhcmUgcHJvbXB0IGRhdGFcbiAgICAgIC8vIEB0b2RvIHRoaXMgZm9ybWF0IGlzIG5vdCBkZWZpbmVkIGFueXdoZXJlLCBwcm9iYWJseSBzaG91bGQgYmVcbiAgICAgIGNvbnN0IGRhdGE6IHtcbiAgICAgICAgbW90aXZhdGlvbj86IHN0cmluZztcbiAgICAgICAgY29uY3VycmVuY3k/OiBudW1iZXI7XG4gICAgICB9ID0gbXNnLmRhdGEgPz8ge307XG5cbiAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSBkYXRhLm1vdGl2YXRpb24gPz8gJ1VzZXIgaW5wdXQgaXMgbmVlZGVkJztcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gZGF0YS5jb25jdXJyZW5jeSA/PyAwO1xuXG4gICAgICAvLyBvbmx5IHRhbGsgdG8gdXNlciBpZiBTVERJTiBpcyBhIHRlcm1pbmFsIChvdGhlcndpc2UsIGZhaWwpXG4gICAgICBpZiAoIXRoaXMuaXNUVFkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgJHttb3RpdmF0aW9ufSwgYnV0IHRlcm1pbmFsIChUVFkpIGlzIG5vdCBhdHRhY2hlZCBzbyB3ZSBhcmUgdW5hYmxlIHRvIGdldCBhIGNvbmZpcm1hdGlvbiBmcm9tIHRoZSB1c2VyYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgdGFsayB0byB1c2VyIGlmIGNvbmN1cnJlbmN5IGlzIDEgKG90aGVyd2lzZSwgZmFpbClcbiAgICAgIGlmIChjb25jdXJyZW5jeSA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgJHttb3RpdmF0aW9ufSwgYnV0IGNvbmN1cnJlbmN5IGlzIGdyZWF0ZXIgdGhhbiAxIHNvIHdlIGFyZSB1bmFibGUgdG8gZ2V0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHVzZXJgKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3BlY2lhbCBhcHByb3ZhbCBwcm9tcHRcbiAgICAgIC8vIERldGVybWluZSBpZiB0aGUgbWVzc2FnZSBuZWVkcyBhcHByb3ZhbC4gSWYgaXQgZG9lcywgY29udGludWUgKGl0IGlzIGEgYmFzaWMgY29uZmlybWF0aW9uIHByb21wdClcbiAgICAgIC8vIElmIGl0IGRvZXMgbm90LCByZXR1cm4gc3VjY2VzcyAodHJ1ZSkuIFdlIG9ubHkgY2hlY2sgbWVzc2FnZXMgd2l0aCBjb2RlcyB0aGF0IHdlIGFyZSBhd2FyZVxuICAgICAgLy8gYXJlIHJlcXVpcmVzIGFwcHJvdmFsIGNvZGVzLlxuICAgICAgaWYgKHRoaXMuc2tpcEFwcHJvdmFsU3RlcChtc2cpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBCYXNpYyBjb25maXJtYXRpb24gcHJvbXB0XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgcmVxdWVzdHMgd2l0aCBhIGJvb2xlYW4gcmVzcG9uc2UgYXMgY29uZmlybWF0aW9uIHByb21wdHNcbiAgICAgIGlmIChpc0NvbmZpcm1hdGlvblByb21wdChtc2cpKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IHByb21wdGx5LmNvbmZpcm0oYCR7Y2hhbGsuY3lhbihtc2cubWVzc2FnZSl9ICh5L24pYCk7XG4gICAgICAgIGlmICghY29uZmlybWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgIH1cblxuICAgICAgLy8gQXNraW5nIGZvciBhIHNwZWNpZmljIHZhbHVlXG4gICAgICBjb25zdCBwcm9tcHQgPSBleHRyYWN0UHJvbXB0SW5mbyhtc2cpO1xuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcHJvbXB0bHkucHJvbXB0KGAke2NoYWxrLmN5YW4obXNnLm1lc3NhZ2UpfSAoJHtwcm9tcHQuZGVmYXVsdH0pYCwge1xuICAgICAgICBkZWZhdWx0OiBwcm9tcHQuZGVmYXVsdCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21wdC5jb252ZXJ0QW5zd2VyKGFuc3dlcik7XG4gICAgfSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGNhc3QgdGhpcyBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgdG8gbmFycm93IHRoZSBnZW5lcmljIHR5cGVcbiAgICAvLyBpc1Byb21wdGFibGVSZXF1ZXN0IGVuc3VyZXMgdGhhdCB0aGUgcmVzcG9uc2UgdHlwZSBpcyBvbmUgd2UgY2FuIHByb21wdCBmb3JcbiAgICAvLyB0aGUgcmVtYWluaW5nIGNvZGUgZW5zdXJlIHdlIGFyZSBpbmRlZWQgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHR5cGVcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgUmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgYSBtZXNzYWdlIGZvciBjb25zb2xlIG91dHB1dCB3aXRoIG9wdGlvbmFsIGNvbG9yIHN1cHBvcnRcbiAgICovXG4gIHByaXZhdGUgZm9ybWF0TWVzc2FnZShtc2c6IElvTWVzc2FnZTx1bmtub3duPik6IHN0cmluZyB7XG4gICAgLy8gYXBwbHkgcHJvdmlkZWQgc3R5bGUgb3IgYSBkZWZhdWx0IHN0eWxlIGlmIHdlJ3JlIGluIFRUWSBtb2RlXG4gICAgbGV0IG1lc3NhZ2VfdGV4dCA9IHRoaXMuaXNUVFlcbiAgICAgID8gc3R5bGVNYXBbbXNnLmxldmVsXShtc2cubWVzc2FnZSlcbiAgICAgIDogbXNnLm1lc3NhZ2U7XG5cbiAgICAvLyBwcmVwZW5kIHRpbWVzdGFtcCBpZiBJb01lc3NhZ2VMZXZlbCBpcyBERUJVRyBvciBUUkFDRS4gUG9zdHBlbmQgYSBuZXdsaW5lLlxuICAgIHJldHVybiAoKG1zZy5sZXZlbCA9PT0gJ2RlYnVnJyB8fCBtc2cubGV2ZWwgPT09ICd0cmFjZScpXG4gICAgICA/IGBbJHt0aGlzLmZvcm1hdFRpbWUobXNnLnRpbWUpfV0gJHttZXNzYWdlX3RleHR9YFxuICAgICAgOiBtZXNzYWdlX3RleHQpICsgJ1xcbic7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0cyBkYXRlIHRvIEhIOk1NOlNTXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdFRpbWUoZDogRGF0ZSk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFkID0gKG46IG51bWJlcik6IHN0cmluZyA9PiBuLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICByZXR1cm4gYCR7cGFkKGQuZ2V0SG91cnMoKSl9OiR7cGFkKGQuZ2V0TWludXRlcygpKX06JHtwYWQoZC5nZXRTZWNvbmRzKCkpfWA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIHRoZSBBY3Rpdml0eVByaW50ZXJcbiAgICovXG4gIHByaXZhdGUgbWFrZUFjdGl2aXR5UHJpbnRlcigpIHtcbiAgICBjb25zdCBwcm9wczogQWN0aXZpdHlQcmludGVyUHJvcHMgPSB7XG4gICAgICBzdHJlYW06IHRoaXMuc2VsZWN0U3RyZWFtRnJvbUxldmVsKCdpbmZvJyksXG4gICAgfTtcblxuICAgIHN3aXRjaCAodGhpcy5zdGFja1Byb2dyZXNzKSB7XG4gICAgICBjYXNlIFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5FVkVOVFM6XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeUFjdGl2aXR5UHJpbnRlcihwcm9wcyk7XG4gICAgICBjYXNlIFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CQVI6XG4gICAgICAgIHJldHVybiBuZXcgQ3VycmVudEFjdGl2aXR5UHJpbnRlcihwcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBJb0hvc3QgaW1wbGVtZW50YXRpb24gY29uc2lkZXJzIGEgcmVxdWVzdCBwcm9tcHRhYmxlLCBpZjpcbiAqIC0gaXQncyBhIHllcy9ubyBjb25maXJtYXRpb25cbiAqIC0gYXNraW5nIGZvciBhIHN0cmluZyBvciBudW1iZXIgdmFsdWVcbiAqL1xuZnVuY3Rpb24gaXNQcm9tcHRhYmxlUmVxdWVzdChtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiBtc2cgaXMgSW9SZXF1ZXN0PGFueSwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbj4ge1xuICByZXR1cm4gaXNDb25maXJtYXRpb25Qcm9tcHQobXNnKVxuICAgIHx8IHR5cGVvZiBtc2cuZGVmYXVsdFJlc3BvbnNlID09PSAnc3RyaW5nJ1xuICAgIHx8IHR5cGVvZiBtc2cuZGVmYXVsdFJlc3BvbnNlID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcmVxdWVzdCBpcyBhIGNvbmZpcm1hdGlvbiBwcm9tcHRcbiAqIFdlIHRyZWF0IGFsbCByZXF1ZXN0cyB3aXRoIGEgYm9vbGVhbiByZXNwb25zZSBhcyBjb25maXJtYXRpb24gcHJvbXB0c1xuICovXG5mdW5jdGlvbiBpc0NvbmZpcm1hdGlvblByb21wdChtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiBtc2cgaXMgSW9SZXF1ZXN0PGFueSwgYm9vbGVhbj4ge1xuICByZXR1cm4gdHlwZW9mIG1zZy5kZWZhdWx0UmVzcG9uc2UgPT09ICdib29sZWFuJztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZXh0cmFjdCBpbmZvcm1hdGlvbiBmb3IgcHJvbXB0bHkgZnJvbSB0aGUgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvbXB0SW5mbyhtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiB7XG4gIGRlZmF1bHQ6IHN0cmluZztcbiAgY29udmVydEFuc3dlcjogKGlucHV0OiBzdHJpbmcpID0+IHN0cmluZyB8IG51bWJlcjtcbn0ge1xuICBjb25zdCBpc051bWJlciA9ICh0eXBlb2YgbXNnLmRlZmF1bHRSZXNwb25zZSA9PT0gJ251bWJlcicpO1xuICByZXR1cm4ge1xuICAgIGRlZmF1bHQ6IHV0aWwuZm9ybWF0KG1zZy5kZWZhdWx0UmVzcG9uc2UpLFxuICAgIGNvbnZlcnRBbnN3ZXI6IGlzTnVtYmVyID8gKHYpID0+IE51bWJlcih2KSA6ICh2KSA9PiBTdHJpbmcodiksXG4gIH07XG59XG5cbmNvbnN0IHN0eWxlTWFwOiBSZWNvcmQ8SW9NZXNzYWdlTGV2ZWwsIChzdHI6IHN0cmluZykgPT4gc3RyaW5nPiA9IHtcbiAgZXJyb3I6IGNoYWxrLnJlZCxcbiAgd2FybjogY2hhbGsueWVsbG93LFxuICByZXN1bHQ6IGNoYWxrLndoaXRlLFxuICBpbmZvOiBjaGFsay53aGl0ZSxcbiAgZGVidWc6IGNoYWxrLmdyYXksXG4gIHRyYWNlOiBjaGFsay5ncmF5LFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcHJvY2VzcyBpcyBydW5uaW5nIGluIGEgQ0kgZW52aXJvbm1lbnRcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcHJvY2VzcyBpcyBydW5uaW5nIGluIGEgQ0kgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ0koKTogYm9vbGVhbiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5DSSAhPT0gdW5kZWZpbmVkICYmIHByb2Nlc3MuZW52LkNJICE9PSAnZmFsc2UnICYmIHByb2Nlc3MuZW52LkNJICE9PSAnMCc7XG59XG5cbmZ1bmN0aW9uIHRhcmdldFN0cmVhbU9iamVjdCh4OiBUYXJnZXRTdHJlYW0pOiBOb2RlSlMuV3JpdGVTdHJlYW0gfCB1bmRlZmluZWQge1xuICBzd2l0Y2ggKHgpIHtcbiAgICBjYXNlICdzdGRlcnInOlxuICAgICAgcmV0dXJuIHByb2Nlc3Muc3RkZXJyO1xuICAgIGNhc2UgJ3N0ZG91dCc6XG4gICAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQ7XG4gICAgY2FzZSAnZHJvcCc6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTm90aWNlc01lc3NhZ2UobXNnOiBJb01lc3NhZ2U8dW5rbm93bj4pIHtcbiAgcmV0dXJuIElPLkNES19UT09MS0lUX0kwMTAwLmlzKG1zZykgfHwgSU8uQ0RLX1RPT0xLSVRfVzAxMDEuaXMobXNnKSB8fCBJTy5DREtfVE9PTEtJVF9FMDEwMS5pcyhtc2cpIHx8IElPLkNES19UT09MS0lUX0kwMTAxLmlzKG1zZyk7XG59XG4iXX0=