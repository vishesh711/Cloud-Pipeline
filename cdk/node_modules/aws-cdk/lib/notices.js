"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedDataSource = exports.WebsiteNoticeDataSource = exports.FilteredNotice = exports.Notices = exports.NoticesFilter = void 0;
const https = require("node:https");
const path = require("path");
const fs = require("fs-extra");
const semver = require("semver");
const awscli_compatible_1 = require("./api/aws-auth/awscli-compatible");
const version_1 = require("./cli/version");
const error_1 = require("./toolkit/error");
const tree_1 = require("./tree");
const util_1 = require("./util");
const private_1 = require("../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
const CACHE_FILE_PATH = path.join((0, util_1.cdkCacheDir)(), 'notices.json');
class NoticesFilter {
    constructor(ioMessages) {
        this.ioMessages = ioMessages;
    }
    filter(options) {
        const components = [
            ...this.constructTreeComponents(options.outDir),
            ...this.otherComponents(options),
        ];
        return this.findForNamedComponents(options.data, components);
    }
    /**
     * From a set of input options, return the notices components we are searching for
     */
    otherComponents(options) {
        return [
            // CLI
            {
                name: 'cli',
                version: options.cliVersion,
            },
            // Node version
            {
                name: 'node',
                version: process.version.replace(/^v/, ''), // remove the 'v' prefix.
                dynamicName: 'node',
            },
            // Bootstrap environments
            ...options.bootstrappedEnvironments.flatMap(env => {
                const semverBootstrapVersion = semver.coerce(env.bootstrapStackVersion);
                if (!semverBootstrapVersion) {
                    // we don't throw because notices should never crash the cli.
                    this.ioMessages.warning(`While filtering notices, could not coerce bootstrap version '${env.bootstrapStackVersion}' into semver`);
                    return [];
                }
                return [{
                        name: 'bootstrap',
                        version: `${semverBootstrapVersion}`,
                        dynamicName: 'ENVIRONMENTS',
                        dynamicValue: env.environment.name,
                    }];
            }),
        ];
    }
    /**
     * Based on a set of component names, find all notices that match one of the given components
     */
    findForNamedComponents(data, actualComponents) {
        return data.flatMap(notice => {
            const ors = this.resolveAliases(normalizeComponents(notice.components));
            // Find the first set of the disjunctions of which all components match against the actual components.
            // Return the actual components we found so that we can inject their dynamic values. A single filter
            // component can match more than one actual component
            for (const ands of ors) {
                const matched = ands.map(affected => actualComponents.filter(actual => this.componentNameMatches(affected, actual) && semver.satisfies(actual.version, affected.version, { includePrerelease: true })));
                // For every clause in the filter we matched one or more components
                if (matched.every(xs => xs.length > 0)) {
                    const ret = new FilteredNotice(notice);
                    this.addDynamicValues(matched.flatMap(x => x), ret);
                    return [ret];
                }
            }
            return [];
        });
    }
    /**
     * Whether the given "affected component" name applies to the given actual component name.
     *
     * The name matches if the name is exactly the same, or the name in the notice
     * is a prefix of the node name when the query ends in '.'.
     */
    componentNameMatches(pattern, actual) {
        return pattern.name.endsWith('.') ? actual.name.startsWith(pattern.name) : pattern.name === actual.name;
    }
    /**
     * Adds dynamic values from the given ActualComponents
     *
     * If there are multiple components with the same dynamic name, they are joined
     * by a comma.
     */
    addDynamicValues(comps, notice) {
        var _a, _b;
        const dynamicValues = {};
        for (const comp of comps) {
            if (comp.dynamicName) {
                dynamicValues[comp.dynamicName] = (_a = dynamicValues[comp.dynamicName]) !== null && _a !== void 0 ? _a : [];
                dynamicValues[comp.dynamicName].push((_b = comp.dynamicValue) !== null && _b !== void 0 ? _b : comp.version);
            }
        }
        for (const [key, values] of Object.entries(dynamicValues)) {
            notice.addDynamicValue(key, values.join(','));
        }
    }
    /**
     * Treat 'framework' as an alias for either `aws-cdk-lib.` or `@aws-cdk/core.`.
     *
     * Because it's EITHER `aws-cdk-lib` or `@aws-cdk/core`, we need to add multiple
     * arrays at the top level.
     */
    resolveAliases(ors) {
        return ors.flatMap(ands => {
            const hasFramework = ands.find(c => c.name === 'framework');
            if (!hasFramework) {
                return [ands];
            }
            return [
                ands.map(c => c.name === 'framework' ? { ...c, name: '@aws-cdk/core.' } : c),
                ands.map(c => c.name === 'framework' ? { ...c, name: 'aws-cdk-lib.' } : c),
            ];
        });
    }
    /**
     * Load the construct tree from the given directory and return its components
     */
    constructTreeComponents(manifestDir) {
        const tree = (0, tree_1.loadTreeFromDir)(manifestDir);
        if (!tree) {
            return [];
        }
        const ret = [];
        recurse(tree);
        return ret;
        function recurse(x) {
            var _a, _b, _c, _d, _e;
            if (((_a = x.constructInfo) === null || _a === void 0 ? void 0 : _a.fqn) && ((_b = x.constructInfo) === null || _b === void 0 ? void 0 : _b.version)) {
                ret.push({
                    name: (_c = x.constructInfo) === null || _c === void 0 ? void 0 : _c.fqn,
                    version: (_d = x.constructInfo) === null || _d === void 0 ? void 0 : _d.version,
                });
            }
            for (const child of Object.values((_e = x.children) !== null && _e !== void 0 ? _e : {})) {
                recurse(child);
            }
        }
    }
}
exports.NoticesFilter = NoticesFilter;
/**
 * Provides access to notices the CLI can display.
 */
class Notices {
    /**
     * Create an instance. Note that this replaces the singleton.
     */
    static create(props) {
        this._instance = new Notices(props);
        return this._instance;
    }
    /**
     * Get the singleton instance. May return `undefined` if `create` has not been called.
     */
    static get() {
        return this._instance;
    }
    constructor(props) {
        var _a, _b, _c, _d;
        this.data = new Set();
        // sets don't deduplicate interfaces, so we use a map.
        this.bootstrappedEnvironments = new Map();
        this.context = props.context;
        this.acknowledgedIssueNumbers = new Set((_a = this.context.get('acknowledged-issue-numbers')) !== null && _a !== void 0 ? _a : []);
        this.includeAcknowlegded = (_b = props.includeAcknowledged) !== null && _b !== void 0 ? _b : false;
        this.output = (_c = props.output) !== null && _c !== void 0 ? _c : 'cdk.out';
        this.httpOptions = (_d = props.httpOptions) !== null && _d !== void 0 ? _d : {};
        this.ioMessages = new private_1.IoDefaultMessages((0, private_1.asIoHelper)(props.ioHost, 'notices' /* forcing a CliAction to a ToolkitAction */));
    }
    /**
     * Add a bootstrap information to filter on. Can have multiple values
     * in case of multi-environment deployments.
     */
    addBootstrappedEnvironment(bootstrapped) {
        const key = [
            bootstrapped.bootstrapStackVersion,
            bootstrapped.environment.account,
            bootstrapped.environment.region,
            bootstrapped.environment.name,
        ].join(':');
        this.bootstrappedEnvironments.set(key, bootstrapped);
    }
    /**
     * Refresh the list of notices this instance is aware of.
     * To make sure this never crashes the CLI process, all failures are caught and
     * silently logged.
     *
     * If context is configured to not display notices, this will no-op.
     */
    async refresh(options = {}) {
        var _a, _b;
        try {
            const underlyingDataSource = (_a = options.dataSource) !== null && _a !== void 0 ? _a : new WebsiteNoticeDataSource(this.ioMessages, this.httpOptions);
            const dataSource = new CachedDataSource(this.ioMessages, CACHE_FILE_PATH, underlyingDataSource, (_b = options.force) !== null && _b !== void 0 ? _b : false);
            const notices = await dataSource.fetch();
            this.data = new Set(this.includeAcknowlegded ? notices : notices.filter(n => !this.acknowledgedIssueNumbers.has(n.issueNumber)));
        }
        catch (e) {
            this.ioMessages.debug(`Could not refresh notices: ${e}`);
        }
    }
    /**
     * Display the relevant notices (unless context dictates we shouldn't).
     */
    display(options = {}) {
        var _a;
        const filteredNotices = new NoticesFilter(this.ioMessages).filter({
            data: Array.from(this.data),
            cliVersion: (0, version_1.versionNumber)(),
            outDir: this.output,
            bootstrappedEnvironments: Array.from(this.bootstrappedEnvironments.values()),
        });
        if (filteredNotices.length > 0) {
            void this.ioMessages.notify(private_1.IO.CDK_TOOLKIT_I0100.msg([
                '',
                'NOTICES         (What\'s this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)',
                '',
            ].join('\n')));
            for (const filtered of filteredNotices) {
                const formatted = filtered.format() + '\n';
                switch (filtered.notice.severity) {
                    case 'warning':
                        void this.ioMessages.notify(private_1.IO.CDK_TOOLKIT_W0101.msg(formatted));
                        break;
                    case 'error':
                        void this.ioMessages.notify(private_1.IO.CDK_TOOLKIT_E0101.msg(formatted));
                        break;
                    default:
                        void this.ioMessages.notify(private_1.IO.CDK_TOOLKIT_I0101.msg(formatted));
                        break;
                }
            }
            void this.ioMessages.notify(private_1.IO.CDK_TOOLKIT_I0100.msg(`If you don’t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${filteredNotices[0].notice.issueNumber}".`));
        }
        if ((_a = options.showTotal) !== null && _a !== void 0 ? _a : false) {
            void this.ioMessages.notify(private_1.IO.CDK_TOOLKIT_I0100.msg(`\nThere are ${filteredNotices.length} unacknowledged notice(s).`));
        }
    }
}
exports.Notices = Notices;
/**
 * Normalizes the given components structure into DNF form
 */
function normalizeComponents(xs) {
    return xs.map(x => Array.isArray(x) ? x : [x]);
}
function renderConjunction(xs) {
    return xs.map(c => `${c.name}: ${c.version}`).join(' AND ');
}
/**
 * Notice after passing the filter. A filter can augment a notice with
 * dynamic values as it has access to the dynamic matching data.
 */
class FilteredNotice {
    constructor(notice) {
        this.notice = notice;
        this.dynamicValues = {};
    }
    addDynamicValue(key, value) {
        this.dynamicValues[`{resolve:${key}}`] = value;
    }
    format() {
        const componentsValue = normalizeComponents(this.notice.components).map(renderConjunction).join(', ');
        return this.resolveDynamicValues([
            `${this.notice.issueNumber}\t${this.notice.title}`,
            this.formatOverview(),
            `\tAffected versions: ${componentsValue}`,
            `\tMore information at: https://github.com/aws/aws-cdk/issues/${this.notice.issueNumber}`,
        ].join('\n\n') + '\n');
    }
    formatOverview() {
        const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
        const heading = 'Overview: ';
        const separator = `\n\t${' '.repeat(heading.length)}`;
        const content = wrap(this.notice.overview)
            .split('\n')
            .join(separator);
        return '\t' + heading + content;
    }
    resolveDynamicValues(input) {
        const pattern = new RegExp(Object.keys(this.dynamicValues).join('|'), 'g');
        return input.replace(pattern, (matched) => { var _a; return (_a = this.dynamicValues[matched]) !== null && _a !== void 0 ? _a : matched; });
    }
}
exports.FilteredNotice = FilteredNotice;
class WebsiteNoticeDataSource {
    constructor(ioMessages, options = {}) {
        this.ioMessages = ioMessages;
        this.options = options;
    }
    fetch() {
        const timeout = 3000;
        return new Promise((resolve, reject) => {
            let req;
            let timer = setTimeout(() => {
                if (req) {
                    req.destroy(new error_1.ToolkitError('Request timed out'));
                }
            }, timeout);
            timer.unref();
            const options = {
                agent: awscli_compatible_1.AwsCliCompatible.proxyAgent(this.options),
            };
            try {
                req = https.get('https://cli.cdk.dev-tools.aws.dev/notices.json', options, res => {
                    if (res.statusCode === 200) {
                        res.setEncoding('utf8');
                        let rawData = '';
                        res.on('data', (chunk) => {
                            rawData += chunk;
                        });
                        res.on('end', () => {
                            try {
                                const data = JSON.parse(rawData).notices;
                                if (!data) {
                                    throw new error_1.ToolkitError("'notices' key is missing");
                                }
                                this.ioMessages.debug('Notices refreshed');
                                resolve(data !== null && data !== void 0 ? data : []);
                            }
                            catch (e) {
                                reject(new error_1.ToolkitError(`Failed to parse notices: ${(0, util_1.formatErrorMessage)(e)}`));
                            }
                        });
                        res.on('error', e => {
                            reject(new error_1.ToolkitError(`Failed to fetch notices: ${(0, util_1.formatErrorMessage)(e)}`));
                        });
                    }
                    else {
                        reject(new error_1.ToolkitError(`Failed to fetch notices. Status code: ${res.statusCode}`));
                    }
                });
                req.on('error', reject);
            }
            catch (e) {
                reject(new error_1.ToolkitError(`HTTPS 'get' call threw an error: ${(0, util_1.formatErrorMessage)(e)}`));
            }
        });
    }
}
exports.WebsiteNoticeDataSource = WebsiteNoticeDataSource;
const TIME_TO_LIVE_SUCCESS = 60 * 60 * 1000; // 1 hour
const TIME_TO_LIVE_ERROR = 1 * 60 * 1000; // 1 minute
class CachedDataSource {
    constructor(ioMessages, fileName, dataSource, skipCache) {
        this.ioMessages = ioMessages;
        this.fileName = fileName;
        this.dataSource = dataSource;
        this.skipCache = skipCache;
    }
    async fetch() {
        var _a;
        const cachedData = await this.load();
        const data = cachedData.notices;
        const expiration = (_a = cachedData.expiration) !== null && _a !== void 0 ? _a : 0;
        if (Date.now() > expiration || this.skipCache) {
            const freshData = await this.fetchInner();
            await this.save(freshData);
            return freshData.notices;
        }
        else {
            this.ioMessages.debug(`Reading cached notices from ${this.fileName}`);
            return data;
        }
    }
    async fetchInner() {
        try {
            return {
                expiration: Date.now() + TIME_TO_LIVE_SUCCESS,
                notices: await this.dataSource.fetch(),
            };
        }
        catch (e) {
            this.ioMessages.debug(`Could not refresh notices: ${e}`);
            return {
                expiration: Date.now() + TIME_TO_LIVE_ERROR,
                notices: [],
            };
        }
    }
    async load() {
        const defaultValue = {
            expiration: 0,
            notices: [],
        };
        try {
            return fs.existsSync(this.fileName)
                ? await fs.readJSON(this.fileName)
                : defaultValue;
        }
        catch (e) {
            this.ioMessages.debug(`Failed to load notices from cache: ${e}`);
            return defaultValue;
        }
    }
    async save(cached) {
        try {
            await fs.writeJSON(this.fileName, cached);
        }
        catch (e) {
            this.ioMessages.debug(`Failed to store notices in the cache: ${e}`);
        }
    }
}
exports.CachedDataSource = CachedDataSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBRWpDLHdFQUFvRTtBQUVwRSwyQ0FBOEM7QUFFOUMsMkNBQStDO0FBRS9DLGlDQUF5QztBQUN6QyxpQ0FBeUQ7QUFDekQsbUZBQTBHO0FBRTFHLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBQSxrQkFBVyxHQUFFLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFrRWpFLE1BQWEsYUFBYTtJQUN4QixZQUE2QixVQUE2QjtRQUE3QixlQUFVLEdBQVYsVUFBVSxDQUFtQjtJQUMxRCxDQUFDO0lBRU0sTUFBTSxDQUFDLE9BQW1DO1FBQy9DLE1BQU0sVUFBVSxHQUFHO1lBQ2pCLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDL0MsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQztTQUNqQyxDQUFDO1FBRUYsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxlQUFlLENBQUMsT0FBbUM7UUFDekQsT0FBTztZQUNMLE1BQU07WUFDTjtnQkFDRSxJQUFJLEVBQUUsS0FBSztnQkFDWCxPQUFPLEVBQUUsT0FBTyxDQUFDLFVBQVU7YUFDNUI7WUFFRCxlQUFlO1lBQ2Y7Z0JBQ0UsSUFBSSxFQUFFLE1BQU07Z0JBQ1osT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSx5QkFBeUI7Z0JBQ3JFLFdBQVcsRUFBRSxNQUFNO2FBQ3BCO1lBRUQseUJBQXlCO1lBQ3pCLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDaEQsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO2dCQUN4RSxJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztvQkFDNUIsNkRBQTZEO29CQUM3RCxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxnRUFBZ0UsR0FBRyxDQUFDLHFCQUFxQixlQUFlLENBQUMsQ0FBQztvQkFDbEksT0FBTyxFQUFFLENBQUM7Z0JBQ1osQ0FBQztnQkFFRCxPQUFPLENBQUM7d0JBQ04sSUFBSSxFQUFFLFdBQVc7d0JBQ2pCLE9BQU8sRUFBRSxHQUFHLHNCQUFzQixFQUFFO3dCQUNwQyxXQUFXLEVBQUUsY0FBYzt3QkFDM0IsWUFBWSxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSTtxQkFDbkMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDO1NBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNLLHNCQUFzQixDQUFDLElBQWMsRUFBRSxnQkFBbUM7UUFDaEYsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzNCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFFeEUsc0dBQXNHO1lBQ3RHLG9HQUFvRztZQUNwRyxxREFBcUQ7WUFDckQsS0FBSyxNQUFNLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDdkIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUNwRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRW5JLG1FQUFtRTtnQkFDbkUsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO29CQUN2QyxNQUFNLEdBQUcsR0FBRyxJQUFJLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDdkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDcEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNmLENBQUM7WUFDSCxDQUFDO1lBRUQsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLG9CQUFvQixDQUFDLE9BQWtCLEVBQUUsTUFBdUI7UUFDdEUsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUM7SUFDMUcsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssZ0JBQWdCLENBQUMsS0FBd0IsRUFBRSxNQUFzQjs7UUFDdkUsTUFBTSxhQUFhLEdBQTZCLEVBQUUsQ0FBQztRQUNuRCxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDO1lBQ3pCLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUNyQixhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLE1BQUEsYUFBYSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsbUNBQUksRUFBRSxDQUFDO2dCQUN4RSxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFBLElBQUksQ0FBQyxZQUFZLG1DQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMxRSxDQUFDO1FBQ0gsQ0FBQztRQUNELEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUM7WUFDMUQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2hELENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxjQUFjLENBQUMsR0FBa0I7UUFDdkMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFdBQVcsQ0FBQyxDQUFDO1lBQzVELElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztnQkFDbEIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hCLENBQUM7WUFFRCxPQUFPO2dCQUNMLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM1RSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDM0UsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ssdUJBQXVCLENBQUMsV0FBbUI7UUFDakQsTUFBTSxJQUFJLEdBQUcsSUFBQSxzQkFBZSxFQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLE9BQU8sRUFBRSxDQUFDO1FBQ1osQ0FBQztRQUVELE1BQU0sR0FBRyxHQUFzQixFQUFFLENBQUM7UUFDbEMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2QsT0FBTyxHQUFHLENBQUM7UUFFWCxTQUFTLE9BQU8sQ0FBQyxDQUFvQjs7WUFDbkMsSUFBSSxDQUFBLE1BQUEsQ0FBQyxDQUFDLGFBQWEsMENBQUUsR0FBRyxNQUFJLE1BQUEsQ0FBQyxDQUFDLGFBQWEsMENBQUUsT0FBTyxDQUFBLEVBQUUsQ0FBQztnQkFDckQsR0FBRyxDQUFDLElBQUksQ0FBQztvQkFDUCxJQUFJLEVBQUUsTUFBQSxDQUFDLENBQUMsYUFBYSwwQ0FBRSxHQUFHO29CQUMxQixPQUFPLEVBQUUsTUFBQSxDQUFDLENBQUMsYUFBYSwwQ0FBRSxPQUFPO2lCQUNsQyxDQUFDLENBQUM7WUFDTCxDQUFDO1lBRUQsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQUEsQ0FBQyxDQUFDLFFBQVEsbUNBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDcEQsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2pCLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBdkpELHNDQXVKQztBQTZDRDs7R0FFRztBQUNILE1BQWEsT0FBTztJQUNsQjs7T0FFRztJQUNJLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBbUI7UUFDdEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLEdBQUc7UUFDZixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztJQWdCRCxZQUFvQixLQUFtQjs7UUFML0IsU0FBSSxHQUFnQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBRXRDLHNEQUFzRDtRQUNyQyw2QkFBd0IsR0FBeUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUcxRixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7UUFDN0IsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksR0FBRyxDQUFDLE1BQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsbUNBQUksRUFBRSxDQUFDLENBQUM7UUFDOUYsSUFBSSxDQUFDLG1CQUFtQixHQUFHLE1BQUEsS0FBSyxDQUFDLG1CQUFtQixtQ0FBSSxLQUFLLENBQUM7UUFDOUQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFBLEtBQUssQ0FBQyxNQUFNLG1DQUFJLFNBQVMsQ0FBQztRQUN4QyxJQUFJLENBQUMsV0FBVyxHQUFHLE1BQUEsS0FBSyxDQUFDLFdBQVcsbUNBQUksRUFBRSxDQUFDO1FBQzNDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSwyQkFBaUIsQ0FBQyxJQUFBLG9CQUFVLEVBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxTQUFnQixDQUFDLDRDQUE0QyxDQUFDLENBQUMsQ0FBQztJQUNuSSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksMEJBQTBCLENBQUMsWUFBcUM7UUFDckUsTUFBTSxHQUFHLEdBQUc7WUFDVixZQUFZLENBQUMscUJBQXFCO1lBQ2xDLFlBQVksQ0FBQyxXQUFXLENBQUMsT0FBTztZQUNoQyxZQUFZLENBQUMsV0FBVyxDQUFDLE1BQU07WUFDL0IsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJO1NBQzlCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBaUMsRUFBRTs7UUFDdEQsSUFBSSxDQUFDO1lBQ0gsTUFBTSxvQkFBb0IsR0FBRyxNQUFBLE9BQU8sQ0FBQyxVQUFVLG1DQUFJLElBQUksdUJBQXVCLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDbEgsTUFBTSxVQUFVLEdBQUcsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSxNQUFBLE9BQU8sQ0FBQyxLQUFLLG1DQUFJLEtBQUssQ0FBQyxDQUFDO1lBQ3hILE1BQU0sT0FBTyxHQUFHLE1BQU0sVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3pDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuSSxDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMzRCxDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTyxDQUFDLFVBQStCLEVBQUU7O1FBQzlDLE1BQU0sZUFBZSxHQUFHLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDaEUsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUMzQixVQUFVLEVBQUUsSUFBQSx1QkFBYSxHQUFFO1lBQzNCLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQix3QkFBd0IsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUM3RSxDQUFDLENBQUM7UUFFSCxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDL0IsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDO2dCQUNuRCxFQUFFO2dCQUNGLGlGQUFpRjtnQkFDakYsRUFBRTthQUNILENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNmLEtBQUssTUFBTSxRQUFRLElBQUksZUFBZSxFQUFFLENBQUM7Z0JBQ3ZDLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUM7Z0JBQzNDLFFBQVEsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDakMsS0FBSyxTQUFTO3dCQUNaLEtBQUssSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO3dCQUNqRSxNQUFNO29CQUNSLEtBQUssT0FBTzt3QkFDVixLQUFLLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzt3QkFDakUsTUFBTTtvQkFDUjt3QkFDRSxLQUFLLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzt3QkFDakUsTUFBTTtnQkFDVixDQUFDO1lBQ0gsQ0FBQztZQUNELEtBQUssSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FDbEQsd0dBQXdHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxJQUFJLENBQ2xKLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxJQUFJLE1BQUEsT0FBTyxDQUFDLFNBQVMsbUNBQUksS0FBSyxFQUFFLENBQUM7WUFDL0IsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUNsRCxlQUFlLGVBQWUsQ0FBQyxNQUFNLDRCQUE0QixDQUNsRSxDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBakhELDBCQWlIQztBQStCRDs7R0FFRztBQUNILFNBQVMsbUJBQW1CLENBQUMsRUFBa0M7SUFDN0QsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUVELFNBQVMsaUJBQWlCLENBQUMsRUFBZTtJQUN4QyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFhLGNBQWM7SUFHekIsWUFBbUMsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFGaEMsa0JBQWEsR0FBOEIsRUFBRSxDQUFDO0lBRy9ELENBQUM7SUFFTSxlQUFlLENBQUMsR0FBVyxFQUFFLEtBQWE7UUFDL0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ2pELENBQUM7SUFFTSxNQUFNO1FBQ1gsTUFBTSxlQUFlLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEcsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUM7WUFDL0IsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRTtZQUNsRCxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3JCLHdCQUF3QixlQUFlLEVBQUU7WUFDekMsZ0VBQWdFLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFO1NBQzFGLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFTyxjQUFjO1FBQ3BCLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGtDQUFrQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRWxGLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQztRQUM3QixNQUFNLFNBQVMsR0FBRyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDdEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO2FBQ3ZDLEtBQUssQ0FBQyxJQUFJLENBQUM7YUFDWCxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbkIsT0FBTyxJQUFJLEdBQUcsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUNsQyxDQUFDO0lBRU8sb0JBQW9CLENBQUMsS0FBYTtRQUN4QyxNQUFNLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDM0UsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLFdBQUMsT0FBQSxNQUFBLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLG1DQUFJLE9BQU8sQ0FBQSxFQUFBLENBQUMsQ0FBQztJQUNyRixDQUFDO0NBQ0Y7QUFwQ0Qsd0NBb0NDO0FBTUQsTUFBYSx1QkFBdUI7SUFHbEMsWUFBNkIsVUFBNkIsRUFBRSxVQUEwQixFQUFFO1FBQTNELGVBQVUsR0FBVixVQUFVLENBQW1CO1FBQ3hELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxLQUFLO1FBQ0gsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDckMsSUFBSSxHQUE4QixDQUFDO1lBRW5DLElBQUksS0FBSyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQzFCLElBQUksR0FBRyxFQUFFLENBQUM7b0JBQ1IsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLG9CQUFZLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxDQUFDO1lBQ0gsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBRVosS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRWQsTUFBTSxPQUFPLEdBQW1CO2dCQUM5QixLQUFLLEVBQUUsb0NBQWdCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7YUFDakQsQ0FBQztZQUVGLElBQUksQ0FBQztnQkFDSCxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxnREFBZ0QsRUFDOUQsT0FBTyxFQUNQLEdBQUcsQ0FBQyxFQUFFO29CQUNKLElBQUksR0FBRyxDQUFDLFVBQVUsS0FBSyxHQUFHLEVBQUUsQ0FBQzt3QkFDM0IsR0FBRyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDeEIsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO3dCQUNqQixHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFOzRCQUN2QixPQUFPLElBQUksS0FBSyxDQUFDO3dCQUNuQixDQUFDLENBQUMsQ0FBQzt3QkFDSCxHQUFHLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUU7NEJBQ2pCLElBQUksQ0FBQztnQ0FDSCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQW1CLENBQUM7Z0NBQ3JELElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQ0FDVixNQUFNLElBQUksb0JBQVksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO2dDQUNyRCxDQUFDO2dDQUNELElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7Z0NBQzNDLE9BQU8sQ0FBQyxJQUFJLGFBQUosSUFBSSxjQUFKLElBQUksR0FBSSxFQUFFLENBQUMsQ0FBQzs0QkFDdEIsQ0FBQzs0QkFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO2dDQUNoQixNQUFNLENBQUMsSUFBSSxvQkFBWSxDQUFDLDRCQUE0QixJQUFBLHlCQUFrQixFQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUNoRixDQUFDO3dCQUNILENBQUMsQ0FBQyxDQUFDO3dCQUNILEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFOzRCQUNsQixNQUFNLENBQUMsSUFBSSxvQkFBWSxDQUFDLDRCQUE0QixJQUFBLHlCQUFrQixFQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO3dCQUNoRixDQUFDLENBQUMsQ0FBQztvQkFDTCxDQUFDO3lCQUFNLENBQUM7d0JBQ04sTUFBTSxDQUFDLElBQUksb0JBQVksQ0FBQyx5Q0FBeUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDdEYsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztnQkFDTCxHQUFHLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUMxQixDQUFDO1lBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztnQkFDaEIsTUFBTSxDQUFDLElBQUksb0JBQVksQ0FBQyxvQ0FBb0MsSUFBQSx5QkFBa0IsRUFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN4RixDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUEzREQsMERBMkRDO0FBT0QsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLFNBQVM7QUFDdEQsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLFdBQVc7QUFFckQsTUFBYSxnQkFBZ0I7SUFDM0IsWUFDbUIsVUFBNkIsRUFDN0IsUUFBZ0IsRUFDaEIsVUFBNEIsRUFDNUIsU0FBbUI7UUFIbkIsZUFBVSxHQUFWLFVBQVUsQ0FBbUI7UUFDN0IsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUNoQixlQUFVLEdBQVYsVUFBVSxDQUFrQjtRQUM1QixjQUFTLEdBQVQsU0FBUyxDQUFVO0lBQ3RDLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBSzs7UUFDVCxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQyxNQUFNLElBQUksR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDO1FBQ2hDLE1BQU0sVUFBVSxHQUFHLE1BQUEsVUFBVSxDQUFDLFVBQVUsbUNBQUksQ0FBQyxDQUFDO1FBRTlDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFVBQVUsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDOUMsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDMUMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzNCLE9BQU8sU0FBUyxDQUFDLE9BQU8sQ0FBQztRQUMzQixDQUFDO2FBQU0sQ0FBQztZQUNOLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLCtCQUErQixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUN0RSxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLFVBQVU7UUFDdEIsSUFBSSxDQUFDO1lBQ0gsT0FBTztnQkFDTCxVQUFVLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLG9CQUFvQjtnQkFDN0MsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUU7YUFDdkMsQ0FBQztRQUNKLENBQUM7UUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ1gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsOEJBQThCLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDekQsT0FBTztnQkFDTCxVQUFVLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLGtCQUFrQjtnQkFDM0MsT0FBTyxFQUFFLEVBQUU7YUFDWixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsSUFBSTtRQUNoQixNQUFNLFlBQVksR0FBRztZQUNuQixVQUFVLEVBQUUsQ0FBQztZQUNiLE9BQU8sRUFBRSxFQUFFO1NBQ1osQ0FBQztRQUVGLElBQUksQ0FBQztZQUNILE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUNqQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQWtCO2dCQUNuRCxDQUFDLENBQUMsWUFBWSxDQUFDO1FBQ25CLENBQUM7UUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ1gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsc0NBQXNDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakUsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQztJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQXFCO1FBQ3RDLElBQUksQ0FBQztZQUNILE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ1gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMseUNBQXlDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEUsQ0FBQztJQUNILENBQUM7Q0FDRjtBQTdERCw0Q0E2REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENsaWVudFJlcXVlc3QgfSBmcm9tICdodHRwJztcbmltcG9ydCB0eXBlIHsgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICdodHRwcyc7XG5pbXBvcnQgKiBhcyBodHRwcyBmcm9tICdub2RlOmh0dHBzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgdHlwZSB7IEVudmlyb25tZW50IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHR5cGUgeyBTZGtIdHRwT3B0aW9ucyB9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7IEF3c0NsaUNvbXBhdGlibGUgfSBmcm9tICcuL2FwaS9hd3MtYXV0aC9hd3NjbGktY29tcGF0aWJsZSc7XG5pbXBvcnQgdHlwZSB7IENvbnRleHQgfSBmcm9tICcuL2FwaS9jb250ZXh0JztcbmltcG9ydCB7IHZlcnNpb25OdW1iZXIgfSBmcm9tICcuL2NsaS92ZXJzaW9uJztcbmltcG9ydCB0eXBlIHsgSUlvSG9zdCB9IGZyb20gJy4vdG9vbGtpdC9jbGktaW8taG9zdCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBDb25zdHJ1Y3RUcmVlTm9kZSB9IGZyb20gJy4vdHJlZSc7XG5pbXBvcnQgeyBsb2FkVHJlZUZyb21EaXIgfSBmcm9tICcuL3RyZWUnO1xuaW1wb3J0IHsgY2RrQ2FjaGVEaXIsIGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBJTywgYXNJb0hlbHBlciwgSW9EZWZhdWx0TWVzc2FnZXMgfSBmcm9tICcuLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5cbmNvbnN0IENBQ0hFX0ZJTEVfUEFUSCA9IHBhdGguam9pbihjZGtDYWNoZURpcigpLCAnbm90aWNlcy5qc29uJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlc1Byb3BzIHtcbiAgLyoqXG4gICAqIENESyBjb250ZXh0XG4gICAqL1xuICByZWFkb25seSBjb250ZXh0OiBDb250ZXh0O1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIG5vdGljZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhY2tub3dsZWRnZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBpbmNsdWRlQWNrbm93bGVkZ2VkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2xvYmFsIENMSSBvcHRpb24gZm9yIG91dHB1dCBkaXJlY3RvcnkgZm9yIHN5bnRoZXNpemVkIGNsb3VkIGFzc2VtYmx5XG4gICAqXG4gICAqIEBkZWZhdWx0ICdjZGsub3V0J1xuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciB0aGUgSFRUUCByZXF1ZXN0XG4gICAqL1xuICByZWFkb25seSBodHRwT3B0aW9ucz86IFNka0h0dHBPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBXaGVyZSBtZXNzYWdlcyBhcmUgZ29pbmcgdG8gYmUgc2VudFxuICAgKi9cbiAgcmVhZG9ubHkgaW9Ib3N0OiBJSW9Ib3N0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNQcmludE9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFwcGVuZCB0aGUgdG90YWwgbnVtYmVyIG9mIHVuYWNrbm93bGVkZ2VkIG5vdGljZXMgdG8gdGhlIGRpc3BsYXkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBzaG93VG90YWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNSZWZyZXNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGZvcmNlIGEgY2FjaGUgcmVmcmVzaCByZWdhcmRsZXNzIG9mIGV4cGlyYXRpb24gdGltZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGZvcmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGF0YSBzb3VyY2UgZm9yIGZldGNoIG5vdGljZXMgZnJvbS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZVxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YVNvdXJjZT86IE5vdGljZURhdGFTb3VyY2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlc0ZpbHRlckZpbHRlck9wdGlvbnMge1xuICByZWFkb25seSBkYXRhOiBOb3RpY2VbXTtcbiAgcmVhZG9ubHkgY2xpVmVyc2lvbjogc3RyaW5nO1xuICByZWFkb25seSBvdXREaXI6IHN0cmluZztcbiAgcmVhZG9ubHkgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBCb290c3RyYXBwZWRFbnZpcm9ubWVudFtdO1xufVxuXG5leHBvcnQgY2xhc3MgTm90aWNlc0ZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgaW9NZXNzYWdlczogSW9EZWZhdWx0TWVzc2FnZXMpIHtcbiAgfVxuXG4gIHB1YmxpYyBmaWx0ZXIob3B0aW9uczogTm90aWNlc0ZpbHRlckZpbHRlck9wdGlvbnMpOiBGaWx0ZXJlZE5vdGljZVtdIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gW1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3RUcmVlQ29tcG9uZW50cyhvcHRpb25zLm91dERpciksXG4gICAgICAuLi50aGlzLm90aGVyQ29tcG9uZW50cyhvcHRpb25zKSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluZEZvck5hbWVkQ29tcG9uZW50cyhvcHRpb25zLmRhdGEsIGNvbXBvbmVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gYSBzZXQgb2YgaW5wdXQgb3B0aW9ucywgcmV0dXJuIHRoZSBub3RpY2VzIGNvbXBvbmVudHMgd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAgICovXG4gIHByaXZhdGUgb3RoZXJDb21wb25lbnRzKG9wdGlvbnM6IE5vdGljZXNGaWx0ZXJGaWx0ZXJPcHRpb25zKTogQWN0dWFsQ29tcG9uZW50W10ge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBDTElcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaScsXG4gICAgICAgIHZlcnNpb246IG9wdGlvbnMuY2xpVmVyc2lvbixcbiAgICAgIH0sXG5cbiAgICAgIC8vIE5vZGUgdmVyc2lvblxuICAgICAge1xuICAgICAgICBuYW1lOiAnbm9kZScsXG4gICAgICAgIHZlcnNpb246IHByb2Nlc3MudmVyc2lvbi5yZXBsYWNlKC9edi8sICcnKSwgLy8gcmVtb3ZlIHRoZSAndicgcHJlZml4LlxuICAgICAgICBkeW5hbWljTmFtZTogJ25vZGUnLFxuICAgICAgfSxcblxuICAgICAgLy8gQm9vdHN0cmFwIGVudmlyb25tZW50c1xuICAgICAgLi4ub3B0aW9ucy5ib290c3RyYXBwZWRFbnZpcm9ubWVudHMuZmxhdE1hcChlbnYgPT4ge1xuICAgICAgICBjb25zdCBzZW12ZXJCb290c3RyYXBWZXJzaW9uID0gc2VtdmVyLmNvZXJjZShlbnYuYm9vdHN0cmFwU3RhY2tWZXJzaW9uKTtcbiAgICAgICAgaWYgKCFzZW12ZXJCb290c3RyYXBWZXJzaW9uKSB7XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgdGhyb3cgYmVjYXVzZSBub3RpY2VzIHNob3VsZCBuZXZlciBjcmFzaCB0aGUgY2xpLlxuICAgICAgICAgIHRoaXMuaW9NZXNzYWdlcy53YXJuaW5nKGBXaGlsZSBmaWx0ZXJpbmcgbm90aWNlcywgY291bGQgbm90IGNvZXJjZSBib290c3RyYXAgdmVyc2lvbiAnJHtlbnYuYm9vdHN0cmFwU3RhY2tWZXJzaW9ufScgaW50byBzZW12ZXJgKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICBuYW1lOiAnYm9vdHN0cmFwJyxcbiAgICAgICAgICB2ZXJzaW9uOiBgJHtzZW12ZXJCb290c3RyYXBWZXJzaW9ufWAsXG4gICAgICAgICAgZHluYW1pY05hbWU6ICdFTlZJUk9OTUVOVFMnLFxuICAgICAgICAgIGR5bmFtaWNWYWx1ZTogZW52LmVudmlyb25tZW50Lm5hbWUsXG4gICAgICAgIH1dO1xuICAgICAgfSksXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiBhIHNldCBvZiBjb21wb25lbnQgbmFtZXMsIGZpbmQgYWxsIG5vdGljZXMgdGhhdCBtYXRjaCBvbmUgb2YgdGhlIGdpdmVuIGNvbXBvbmVudHNcbiAgICovXG4gIHByaXZhdGUgZmluZEZvck5hbWVkQ29tcG9uZW50cyhkYXRhOiBOb3RpY2VbXSwgYWN0dWFsQ29tcG9uZW50czogQWN0dWFsQ29tcG9uZW50W10pOiBGaWx0ZXJlZE5vdGljZVtdIHtcbiAgICByZXR1cm4gZGF0YS5mbGF0TWFwKG5vdGljZSA9PiB7XG4gICAgICBjb25zdCBvcnMgPSB0aGlzLnJlc29sdmVBbGlhc2VzKG5vcm1hbGl6ZUNvbXBvbmVudHMobm90aWNlLmNvbXBvbmVudHMpKTtcblxuICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgc2V0IG9mIHRoZSBkaXNqdW5jdGlvbnMgb2Ygd2hpY2ggYWxsIGNvbXBvbmVudHMgbWF0Y2ggYWdhaW5zdCB0aGUgYWN0dWFsIGNvbXBvbmVudHMuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBjb21wb25lbnRzIHdlIGZvdW5kIHNvIHRoYXQgd2UgY2FuIGluamVjdCB0aGVpciBkeW5hbWljIHZhbHVlcy4gQSBzaW5nbGUgZmlsdGVyXG4gICAgICAvLyBjb21wb25lbnQgY2FuIG1hdGNoIG1vcmUgdGhhbiBvbmUgYWN0dWFsIGNvbXBvbmVudFxuICAgICAgZm9yIChjb25zdCBhbmRzIG9mIG9ycykge1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYW5kcy5tYXAoYWZmZWN0ZWQgPT4gYWN0dWFsQ29tcG9uZW50cy5maWx0ZXIoYWN0dWFsID0+XG4gICAgICAgICAgdGhpcy5jb21wb25lbnROYW1lTWF0Y2hlcyhhZmZlY3RlZCwgYWN0dWFsKSAmJiBzZW12ZXIuc2F0aXNmaWVzKGFjdHVhbC52ZXJzaW9uLCBhZmZlY3RlZC52ZXJzaW9uLCB7IGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlIH0pKSk7XG5cbiAgICAgICAgLy8gRm9yIGV2ZXJ5IGNsYXVzZSBpbiB0aGUgZmlsdGVyIHdlIG1hdGNoZWQgb25lIG9yIG1vcmUgY29tcG9uZW50c1xuICAgICAgICBpZiAobWF0Y2hlZC5ldmVyeSh4cyA9PiB4cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgIGNvbnN0IHJldCA9IG5ldyBGaWx0ZXJlZE5vdGljZShub3RpY2UpO1xuICAgICAgICAgIHRoaXMuYWRkRHluYW1pY1ZhbHVlcyhtYXRjaGVkLmZsYXRNYXAoeCA9PiB4KSwgcmV0KTtcbiAgICAgICAgICByZXR1cm4gW3JldF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdpdmVuIFwiYWZmZWN0ZWQgY29tcG9uZW50XCIgbmFtZSBhcHBsaWVzIHRvIHRoZSBnaXZlbiBhY3R1YWwgY29tcG9uZW50IG5hbWUuXG4gICAqXG4gICAqIFRoZSBuYW1lIG1hdGNoZXMgaWYgdGhlIG5hbWUgaXMgZXhhY3RseSB0aGUgc2FtZSwgb3IgdGhlIG5hbWUgaW4gdGhlIG5vdGljZVxuICAgKiBpcyBhIHByZWZpeCBvZiB0aGUgbm9kZSBuYW1lIHdoZW4gdGhlIHF1ZXJ5IGVuZHMgaW4gJy4nLlxuICAgKi9cbiAgcHJpdmF0ZSBjb21wb25lbnROYW1lTWF0Y2hlcyhwYXR0ZXJuOiBDb21wb25lbnQsIGFjdHVhbDogQWN0dWFsQ29tcG9uZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBhdHRlcm4ubmFtZS5lbmRzV2l0aCgnLicpID8gYWN0dWFsLm5hbWUuc3RhcnRzV2l0aChwYXR0ZXJuLm5hbWUpIDogcGF0dGVybi5uYW1lID09PSBhY3R1YWwubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGR5bmFtaWMgdmFsdWVzIGZyb20gdGhlIGdpdmVuIEFjdHVhbENvbXBvbmVudHNcbiAgICpcbiAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBkeW5hbWljIG5hbWUsIHRoZXkgYXJlIGpvaW5lZFxuICAgKiBieSBhIGNvbW1hLlxuICAgKi9cbiAgcHJpdmF0ZSBhZGREeW5hbWljVmFsdWVzKGNvbXBzOiBBY3R1YWxDb21wb25lbnRbXSwgbm90aWNlOiBGaWx0ZXJlZE5vdGljZSkge1xuICAgIGNvbnN0IGR5bmFtaWNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wcykge1xuICAgICAgaWYgKGNvbXAuZHluYW1pY05hbWUpIHtcbiAgICAgICAgZHluYW1pY1ZhbHVlc1tjb21wLmR5bmFtaWNOYW1lXSA9IGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0gPz8gW107XG4gICAgICAgIGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0ucHVzaChjb21wLmR5bmFtaWNWYWx1ZSA/PyBjb21wLnZlcnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMoZHluYW1pY1ZhbHVlcykpIHtcbiAgICAgIG5vdGljZS5hZGREeW5hbWljVmFsdWUoa2V5LCB2YWx1ZXMuam9pbignLCcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJlYXQgJ2ZyYW1ld29yaycgYXMgYW4gYWxpYXMgZm9yIGVpdGhlciBgYXdzLWNkay1saWIuYCBvciBgQGF3cy1jZGsvY29yZS5gLlxuICAgKlxuICAgKiBCZWNhdXNlIGl0J3MgRUlUSEVSIGBhd3MtY2RrLWxpYmAgb3IgYEBhd3MtY2RrL2NvcmVgLCB3ZSBuZWVkIHRvIGFkZCBtdWx0aXBsZVxuICAgKiBhcnJheXMgYXQgdGhlIHRvcCBsZXZlbC5cbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZUFsaWFzZXMob3JzOiBDb21wb25lbnRbXVtdKTogQ29tcG9uZW50W11bXSB7XG4gICAgcmV0dXJuIG9ycy5mbGF0TWFwKGFuZHMgPT4ge1xuICAgICAgY29uc3QgaGFzRnJhbWV3b3JrID0gYW5kcy5maW5kKGMgPT4gYy5uYW1lID09PSAnZnJhbWV3b3JrJyk7XG4gICAgICBpZiAoIWhhc0ZyYW1ld29yaykge1xuICAgICAgICByZXR1cm4gW2FuZHNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBhbmRzLm1hcChjID0+IGMubmFtZSA9PT0gJ2ZyYW1ld29yaycgPyB7IC4uLmMsIG5hbWU6ICdAYXdzLWNkay9jb3JlLicgfSA6IGMpLFxuICAgICAgICBhbmRzLm1hcChjID0+IGMubmFtZSA9PT0gJ2ZyYW1ld29yaycgPyB7IC4uLmMsIG5hbWU6ICdhd3MtY2RrLWxpYi4nIH0gOiBjKSxcbiAgICAgIF07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgY29uc3RydWN0IHRyZWUgZnJvbSB0aGUgZ2l2ZW4gZGlyZWN0b3J5IGFuZCByZXR1cm4gaXRzIGNvbXBvbmVudHNcbiAgICovXG4gIHByaXZhdGUgY29uc3RydWN0VHJlZUNvbXBvbmVudHMobWFuaWZlc3REaXI6IHN0cmluZyk6IEFjdHVhbENvbXBvbmVudFtdIHtcbiAgICBjb25zdCB0cmVlID0gbG9hZFRyZWVGcm9tRGlyKG1hbmlmZXN0RGlyKTtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXQ6IEFjdHVhbENvbXBvbmVudFtdID0gW107XG4gICAgcmVjdXJzZSh0cmVlKTtcbiAgICByZXR1cm4gcmV0O1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZSh4OiBDb25zdHJ1Y3RUcmVlTm9kZSkge1xuICAgICAgaWYgKHguY29uc3RydWN0SW5mbz8uZnFuICYmIHguY29uc3RydWN0SW5mbz8udmVyc2lvbikge1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgbmFtZTogeC5jb25zdHJ1Y3RJbmZvPy5mcW4sXG4gICAgICAgICAgdmVyc2lvbjogeC5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBPYmplY3QudmFsdWVzKHguY2hpbGRyZW4gPz8ge30pKSB7XG4gICAgICAgIHJlY3Vyc2UoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgQWN0dWFsQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBWZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcblxuICAvKipcbiAgICogSWYgbWF0Y2hlZCwgdW5kZXIgd2hhdCBuYW1lIHNob3VsZCBpdCBiZSBhZGRlZCB0byB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzXG4gICAqXG4gICAqIFRoZXNlIHdpbGwgYmUgdXNlZCB0byBzdWJzdGl0dXRlIHBsYWNlaG9sZGVycyBpbiB0aGUgbWVzc2FnZSBzdHJpbmcsIHdoZXJlXG4gICAqIHBsYWNlaG9sZGVycyBsb29rIGxpa2UgYHtyZXNvbHZlOlhZWn1gLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIGR5bmFtaWMgbmFtZSwgdGhleSBhcmVcbiAgICogam9pbmVkIGJ5ICcsJy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEb24ndCBhZGQgdG8gdGhlIHNldCBvZiBkeW5hbWljIHZhbHVlcy5cbiAgICovXG4gIHJlYWRvbmx5IGR5bmFtaWNOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiBtYXRjaGVkLCB3aGF0IHdlIHNob3VsZCBwdXQgaW4gdGhlIHNldCBvZiBkeW5hbWljIHZhbHVlcyBpbnNzdGVhZCBvZiB0aGUgdmVyc2lvbi5cbiAgICpcbiAgICogT25seSB1c2VkIGlmIGBkeW5hbWljTmFtZWAgaXMgc2V0OyBieSBkZWZhdWx0IHdlIHdpbGwgYWRkIHRoZSBhY3R1YWwgdmVyc2lvblxuICAgKiBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFRoZSB2ZXJzaW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY1ZhbHVlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGEgYm9vdHN0cmFwcGVkIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJvb3RzdHJhcHBlZEVudmlyb25tZW50IHtcbiAgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2tWZXJzaW9uOiBudW1iZXI7XG4gIHJlYWRvbmx5IGVudmlyb25tZW50OiBFbnZpcm9ubWVudDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gbm90aWNlcyB0aGUgQ0xJIGNhbiBkaXNwbGF5LlxuICovXG5leHBvcnQgY2xhc3MgTm90aWNlcyB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGlzIHJlcGxhY2VzIHRoZSBzaW5nbGV0b24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZShwcm9wczogTm90aWNlc1Byb3BzKTogTm90aWNlcyB7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgTm90aWNlcyhwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2luZ2xldG9uIGluc3RhbmNlLiBNYXkgcmV0dXJuIGB1bmRlZmluZWRgIGlmIGBjcmVhdGVgIGhhcyBub3QgYmVlbiBjYWxsZWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCgpOiBOb3RpY2VzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfaW5zdGFuY2U6IE5vdGljZXMgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiBDb250ZXh0O1xuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dDogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IGFja25vd2xlZGdlZElzc3VlTnVtYmVyczogU2V0PE51bWJlcj47XG4gIHByaXZhdGUgcmVhZG9ubHkgaW5jbHVkZUFja25vd2xlZ2RlZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBodHRwT3B0aW9uczogU2RrSHR0cE9wdGlvbnM7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW9NZXNzYWdlczogSW9EZWZhdWx0TWVzc2FnZXM7XG5cbiAgcHJpdmF0ZSBkYXRhOiBTZXQ8Tm90aWNlPiA9IG5ldyBTZXQoKTtcblxuICAvLyBzZXRzIGRvbid0IGRlZHVwbGljYXRlIGludGVyZmFjZXMsIHNvIHdlIHVzZSBhIG1hcC5cbiAgcHJpdmF0ZSByZWFkb25seSBib290c3RyYXBwZWRFbnZpcm9ubWVudHM6IE1hcDxzdHJpbmcsIEJvb3RzdHJhcHBlZEVudmlyb25tZW50PiA9IG5ldyBNYXAoKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHByb3BzOiBOb3RpY2VzUHJvcHMpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBwcm9wcy5jb250ZXh0O1xuICAgIHRoaXMuYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzID0gbmV3IFNldCh0aGlzLmNvbnRleHQuZ2V0KCdhY2tub3dsZWRnZWQtaXNzdWUtbnVtYmVycycpID8/IFtdKTtcbiAgICB0aGlzLmluY2x1ZGVBY2tub3dsZWdkZWQgPSBwcm9wcy5pbmNsdWRlQWNrbm93bGVkZ2VkID8/IGZhbHNlO1xuICAgIHRoaXMub3V0cHV0ID0gcHJvcHMub3V0cHV0ID8/ICdjZGsub3V0JztcbiAgICB0aGlzLmh0dHBPcHRpb25zID0gcHJvcHMuaHR0cE9wdGlvbnMgPz8ge307XG4gICAgdGhpcy5pb01lc3NhZ2VzID0gbmV3IElvRGVmYXVsdE1lc3NhZ2VzKGFzSW9IZWxwZXIocHJvcHMuaW9Ib3N0LCAnbm90aWNlcycgYXMgYW55IC8qIGZvcmNpbmcgYSBDbGlBY3Rpb24gdG8gYSBUb29sa2l0QWN0aW9uICovKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgYm9vdHN0cmFwIGluZm9ybWF0aW9uIHRvIGZpbHRlciBvbi4gQ2FuIGhhdmUgbXVsdGlwbGUgdmFsdWVzXG4gICAqIGluIGNhc2Ugb2YgbXVsdGktZW52aXJvbm1lbnQgZGVwbG95bWVudHMuXG4gICAqL1xuICBwdWJsaWMgYWRkQm9vdHN0cmFwcGVkRW52aXJvbm1lbnQoYm9vdHN0cmFwcGVkOiBCb290c3RyYXBwZWRFbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IGtleSA9IFtcbiAgICAgIGJvb3RzdHJhcHBlZC5ib290c3RyYXBTdGFja1ZlcnNpb24sXG4gICAgICBib290c3RyYXBwZWQuZW52aXJvbm1lbnQuYWNjb3VudCxcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBib290c3RyYXBwZWQuZW52aXJvbm1lbnQubmFtZSxcbiAgICBdLmpvaW4oJzonKTtcbiAgICB0aGlzLmJvb3RzdHJhcHBlZEVudmlyb25tZW50cy5zZXQoa2V5LCBib290c3RyYXBwZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGxpc3Qgb2Ygbm90aWNlcyB0aGlzIGluc3RhbmNlIGlzIGF3YXJlIG9mLlxuICAgKiBUbyBtYWtlIHN1cmUgdGhpcyBuZXZlciBjcmFzaGVzIHRoZSBDTEkgcHJvY2VzcywgYWxsIGZhaWx1cmVzIGFyZSBjYXVnaHQgYW5kXG4gICAqIHNpbGVudGx5IGxvZ2dlZC5cbiAgICpcbiAgICogSWYgY29udGV4dCBpcyBjb25maWd1cmVkIHRvIG5vdCBkaXNwbGF5IG5vdGljZXMsIHRoaXMgd2lsbCBuby1vcC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZWZyZXNoKG9wdGlvbnM6IE5vdGljZXNSZWZyZXNoT3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVuZGVybHlpbmdEYXRhU291cmNlID0gb3B0aW9ucy5kYXRhU291cmNlID8/IG5ldyBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZSh0aGlzLmlvTWVzc2FnZXMsIHRoaXMuaHR0cE9wdGlvbnMpO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBDYWNoZWREYXRhU291cmNlKHRoaXMuaW9NZXNzYWdlcywgQ0FDSEVfRklMRV9QQVRILCB1bmRlcmx5aW5nRGF0YVNvdXJjZSwgb3B0aW9ucy5mb3JjZSA/PyBmYWxzZSk7XG4gICAgICBjb25zdCBub3RpY2VzID0gYXdhaXQgZGF0YVNvdXJjZS5mZXRjaCgpO1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFNldCh0aGlzLmluY2x1ZGVBY2tub3dsZWdkZWQgPyBub3RpY2VzIDogbm90aWNlcy5maWx0ZXIobiA9PiAhdGhpcy5hY2tub3dsZWRnZWRJc3N1ZU51bWJlcnMuaGFzKG4uaXNzdWVOdW1iZXIpKSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aGlzLmlvTWVzc2FnZXMuZGVidWcoYENvdWxkIG5vdCByZWZyZXNoIG5vdGljZXM6ICR7ZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSB0aGUgcmVsZXZhbnQgbm90aWNlcyAodW5sZXNzIGNvbnRleHQgZGljdGF0ZXMgd2Ugc2hvdWxkbid0KS5cbiAgICovXG4gIHB1YmxpYyBkaXNwbGF5KG9wdGlvbnM6IE5vdGljZXNQcmludE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGZpbHRlcmVkTm90aWNlcyA9IG5ldyBOb3RpY2VzRmlsdGVyKHRoaXMuaW9NZXNzYWdlcykuZmlsdGVyKHtcbiAgICAgIGRhdGE6IEFycmF5LmZyb20odGhpcy5kYXRhKSxcbiAgICAgIGNsaVZlcnNpb246IHZlcnNpb25OdW1iZXIoKSxcbiAgICAgIG91dERpcjogdGhpcy5vdXRwdXQsXG4gICAgICBib290c3RyYXBwZWRFbnZpcm9ubWVudHM6IEFycmF5LmZyb20odGhpcy5ib290c3RyYXBwZWRFbnZpcm9ubWVudHMudmFsdWVzKCkpLFxuICAgIH0pO1xuXG4gICAgaWYgKGZpbHRlcmVkTm90aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICB2b2lkIHRoaXMuaW9NZXNzYWdlcy5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTAxMDAubXNnKFtcbiAgICAgICAgJycsXG4gICAgICAgICdOT1RJQ0VTICAgICAgICAgKFdoYXRcXCdzIHRoaXM/IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay93aWtpL0NMSS1Ob3RpY2VzKScsXG4gICAgICAgICcnLFxuICAgICAgXS5qb2luKCdcXG4nKSkpO1xuICAgICAgZm9yIChjb25zdCBmaWx0ZXJlZCBvZiBmaWx0ZXJlZE5vdGljZXMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZmlsdGVyZWQuZm9ybWF0KCkgKyAnXFxuJztcbiAgICAgICAgc3dpdGNoIChmaWx0ZXJlZC5ub3RpY2Uuc2V2ZXJpdHkpIHtcbiAgICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICAgIHZvaWQgdGhpcy5pb01lc3NhZ2VzLm5vdGlmeShJTy5DREtfVE9PTEtJVF9XMDEwMS5tc2coZm9ybWF0dGVkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICB2b2lkIHRoaXMuaW9NZXNzYWdlcy5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTAxMDEubXNnKGZvcm1hdHRlZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZvaWQgdGhpcy5pb01lc3NhZ2VzLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JMDEwMS5tc2coZm9ybWF0dGVkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm9pZCB0aGlzLmlvTWVzc2FnZXMubm90aWZ5KElPLkNES19UT09MS0lUX0kwMTAwLm1zZyhcbiAgICAgICAgYElmIHlvdSBkb27igJl0IHdhbnQgdG8gc2VlIGEgbm90aWNlIGFueW1vcmUsIHVzZSBcImNkayBhY2tub3dsZWRnZSA8aWQ+XCIuIEZvciBleGFtcGxlLCBcImNkayBhY2tub3dsZWRnZSAke2ZpbHRlcmVkTm90aWNlc1swXS5ub3RpY2UuaXNzdWVOdW1iZXJ9XCIuYCxcbiAgICAgICkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNob3dUb3RhbCA/PyBmYWxzZSkge1xuICAgICAgdm9pZCB0aGlzLmlvTWVzc2FnZXMubm90aWZ5KElPLkNES19UT09MS0lUX0kwMTAwLm1zZyhcbiAgICAgICAgYFxcblRoZXJlIGFyZSAke2ZpbHRlcmVkTm90aWNlcy5sZW5ndGh9IHVuYWNrbm93bGVkZ2VkIG5vdGljZShzKS5gLFxuICAgICAgKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50IHtcbiAgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmFuZ2Ugb2YgYWZmZWN0ZWQgdmVyc2lvbnNcbiAgICovXG4gIHZlcnNpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2Uge1xuICB0aXRsZTogc3RyaW5nO1xuICBpc3N1ZU51bWJlcjogbnVtYmVyO1xuICBvdmVydmlldzogc3RyaW5nO1xuICAvKipcbiAgICogQSBzZXQgb2YgYWZmZWN0ZWQgY29tcG9uZW50c1xuICAgKlxuICAgKiBUaGUgY2Fub25pY2FsIGZvcm0gb2YgYSBsaXN0IG9mIGNvbXBvbmVudHMgaXMgaW4gRGlzanVuY3RpdmUgTm9ybWFsIEZvcm1cbiAgICogKGkuZS4sIGFuIE9SIG9mIEFORHMpLiBUaGlzIGlzIHRoZSBmb3JtIHdoZW4gdGhlIGxpc3Qgb2YgY29tcG9uZW50cyBpcyBhXG4gICAqIGRvdWJseSBuZXN0ZWQgYXJyYXk6IHRoZSBub3RpY2UgbWF0Y2hlcyBpZiBhbGwgY29tcG9uZW50cyBvZiBhdCBsZWFzdCBvbmVcbiAgICogb2YgdGhlIHRvcC1sZXZlbCBhcnJheSBtYXRjaGVzLlxuICAgKlxuICAgKiBJZiB0aGUgYGNvbXBvbmVudHNgIGlzIGEgc2luZ2xlLWxldmVsIGFycmF5LCBpdCBpcyBldmFsdWF0ZWQgYXMgYW4gT1I7IGl0XG4gICAqIG1hdGNoZXMgaWYgYW55IG9mIHRoZSBjb21wb25lbnRzIG1hdGNoZXMuXG4gICAqL1xuICBjb21wb25lbnRzOiBBcnJheTxDb21wb25lbnQgfCBDb21wb25lbnRbXT47XG4gIHNjaGVtYVZlcnNpb246IHN0cmluZztcbiAgc2V2ZXJpdHk/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gY29tcG9uZW50cyBzdHJ1Y3R1cmUgaW50byBETkYgZm9ybVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnRzKHhzOiBBcnJheTxDb21wb25lbnQgfCBDb21wb25lbnRbXT4pOiBDb21wb25lbnRbXVtdIHtcbiAgcmV0dXJuIHhzLm1hcCh4ID0+IEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29uanVuY3Rpb24oeHM6IENvbXBvbmVudFtdKTogc3RyaW5nIHtcbiAgcmV0dXJuIHhzLm1hcChjID0+IGAke2MubmFtZX06ICR7Yy52ZXJzaW9ufWApLmpvaW4oJyBBTkQgJyk7XG59XG5cbi8qKlxuICogTm90aWNlIGFmdGVyIHBhc3NpbmcgdGhlIGZpbHRlci4gQSBmaWx0ZXIgY2FuIGF1Z21lbnQgYSBub3RpY2Ugd2l0aFxuICogZHluYW1pYyB2YWx1ZXMgYXMgaXQgaGFzIGFjY2VzcyB0byB0aGUgZHluYW1pYyBtYXRjaGluZyBkYXRhLlxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVyZWROb3RpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGR5bmFtaWNWYWx1ZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IG5vdGljZTogTm90aWNlKSB7XG4gIH1cblxuICBwdWJsaWMgYWRkRHluYW1pY1ZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5keW5hbWljVmFsdWVzW2B7cmVzb2x2ZToke2tleX19YF0gPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb21wb25lbnRzVmFsdWUgPSBub3JtYWxpemVDb21wb25lbnRzKHRoaXMubm90aWNlLmNvbXBvbmVudHMpLm1hcChyZW5kZXJDb25qdW5jdGlvbikuam9pbignLCAnKTtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlRHluYW1pY1ZhbHVlcyhbXG4gICAgICBgJHt0aGlzLm5vdGljZS5pc3N1ZU51bWJlcn1cXHQke3RoaXMubm90aWNlLnRpdGxlfWAsXG4gICAgICB0aGlzLmZvcm1hdE92ZXJ2aWV3KCksXG4gICAgICBgXFx0QWZmZWN0ZWQgdmVyc2lvbnM6ICR7Y29tcG9uZW50c1ZhbHVlfWAsXG4gICAgICBgXFx0TW9yZSBpbmZvcm1hdGlvbiBhdDogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy8ke3RoaXMubm90aWNlLmlzc3VlTnVtYmVyfWAsXG4gICAgXS5qb2luKCdcXG5cXG4nKSArICdcXG4nKTtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0T3ZlcnZpZXcoKSB7XG4gICAgY29uc3Qgd3JhcCA9IChzOiBzdHJpbmcpID0+IHMucmVwbGFjZSgvKD8hW15cXG5dezEsNjB9JCkoW15cXG5dezEsNjB9KVxccy9nLCAnJDFcXG4nKTtcblxuICAgIGNvbnN0IGhlYWRpbmcgPSAnT3ZlcnZpZXc6ICc7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gYFxcblxcdCR7JyAnLnJlcGVhdChoZWFkaW5nLmxlbmd0aCl9YDtcbiAgICBjb25zdCBjb250ZW50ID0gd3JhcCh0aGlzLm5vdGljZS5vdmVydmlldylcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5qb2luKHNlcGFyYXRvcik7XG5cbiAgICByZXR1cm4gJ1xcdCcgKyBoZWFkaW5nICsgY29udGVudDtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZUR5bmFtaWNWYWx1ZXMoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoT2JqZWN0LmtleXModGhpcy5keW5hbWljVmFsdWVzKS5qb2luKCd8JyksICdnJyk7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UocGF0dGVybiwgKG1hdGNoZWQpID0+IHRoaXMuZHluYW1pY1ZhbHVlc1ttYXRjaGVkXSA/PyBtYXRjaGVkKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZURhdGFTb3VyY2Uge1xuICBmZXRjaCgpOiBQcm9taXNlPE5vdGljZVtdPjtcbn1cblxuZXhwb3J0IGNsYXNzIFdlYnNpdGVOb3RpY2VEYXRhU291cmNlIGltcGxlbWVudHMgTm90aWNlRGF0YVNvdXJjZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogU2RrSHR0cE9wdGlvbnM7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBpb01lc3NhZ2VzOiBJb0RlZmF1bHRNZXNzYWdlcywgb3B0aW9uczogU2RrSHR0cE9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBmZXRjaCgpOiBQcm9taXNlPE5vdGljZVtdPiB7XG4gICAgY29uc3QgdGltZW91dCA9IDMwMDA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZXE6IENsaWVudFJlcXVlc3QgfCB1bmRlZmluZWQ7XG5cbiAgICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgcmVxLmRlc3Ryb3kobmV3IFRvb2xraXRFcnJvcignUmVxdWVzdCB0aW1lZCBvdXQnKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICB0aW1lci51bnJlZigpO1xuXG4gICAgICBjb25zdCBvcHRpb25zOiBSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgYWdlbnQ6IEF3c0NsaUNvbXBhdGlibGUucHJveHlBZ2VudCh0aGlzLm9wdGlvbnMpLFxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxID0gaHR0cHMuZ2V0KCdodHRwczovL2NsaS5jZGsuZGV2LXRvb2xzLmF3cy5kZXYvbm90aWNlcy5qc29uJyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIHJlcyA9PiB7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICByZXMuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgbGV0IHJhd0RhdGEgPSAnJztcbiAgICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgcmF3RGF0YSArPSBjaHVuaztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlcy5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyYXdEYXRhKS5ub3RpY2VzIGFzIE5vdGljZVtdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXCInbm90aWNlcycga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLmlvTWVzc2FnZXMuZGVidWcoJ05vdGljZXMgcmVmcmVzaGVkJyk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEgPz8gW10pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb29sa2l0RXJyb3IoYEZhaWxlZCB0byBwYXJzZSBub3RpY2VzOiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzLm9uKCdlcnJvcicsIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlczogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlcy4gU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICByZWplY3QobmV3IFRvb2xraXRFcnJvcihgSFRUUFMgJ2dldCcgY2FsbCB0aHJldyBhbiBlcnJvcjogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmludGVyZmFjZSBDYWNoZWROb3RpY2VzIHtcbiAgZXhwaXJhdGlvbjogbnVtYmVyO1xuICBub3RpY2VzOiBOb3RpY2VbXTtcbn1cblxuY29uc3QgVElNRV9UT19MSVZFX1NVQ0NFU1MgPSA2MCAqIDYwICogMTAwMDsgLy8gMSBob3VyXG5jb25zdCBUSU1FX1RPX0xJVkVfRVJST1IgPSAxICogNjAgKiAxMDAwOyAvLyAxIG1pbnV0ZVxuXG5leHBvcnQgY2xhc3MgQ2FjaGVkRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlvTWVzc2FnZXM6IElvRGVmYXVsdE1lc3NhZ2VzLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZmlsZU5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRhdGFTb3VyY2U6IE5vdGljZURhdGFTb3VyY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBza2lwQ2FjaGU/OiBib29sZWFuKSB7XG4gIH1cblxuICBhc3luYyBmZXRjaCgpOiBQcm9taXNlPE5vdGljZVtdPiB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGF3YWl0IHRoaXMubG9hZCgpO1xuICAgIGNvbnN0IGRhdGEgPSBjYWNoZWREYXRhLm5vdGljZXM7XG4gICAgY29uc3QgZXhwaXJhdGlvbiA9IGNhY2hlZERhdGEuZXhwaXJhdGlvbiA/PyAwO1xuXG4gICAgaWYgKERhdGUubm93KCkgPiBleHBpcmF0aW9uIHx8IHRoaXMuc2tpcENhY2hlKSB7XG4gICAgICBjb25zdCBmcmVzaERhdGEgPSBhd2FpdCB0aGlzLmZldGNoSW5uZXIoKTtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZShmcmVzaERhdGEpO1xuICAgICAgcmV0dXJuIGZyZXNoRGF0YS5ub3RpY2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlvTWVzc2FnZXMuZGVidWcoYFJlYWRpbmcgY2FjaGVkIG5vdGljZXMgZnJvbSAke3RoaXMuZmlsZU5hbWV9YCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoSW5uZXIoKTogUHJvbWlzZTxDYWNoZWROb3RpY2VzPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cGlyYXRpb246IERhdGUubm93KCkgKyBUSU1FX1RPX0xJVkVfU1VDQ0VTUyxcbiAgICAgICAgbm90aWNlczogYXdhaXQgdGhpcy5kYXRhU291cmNlLmZldGNoKCksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuaW9NZXNzYWdlcy5kZWJ1ZyhgQ291bGQgbm90IHJlZnJlc2ggbm90aWNlczogJHtlfWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwaXJhdGlvbjogRGF0ZS5ub3coKSArIFRJTUVfVE9fTElWRV9FUlJPUixcbiAgICAgICAgbm90aWNlczogW10sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZCgpOiBQcm9taXNlPENhY2hlZE5vdGljZXM+IHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB7XG4gICAgICBleHBpcmF0aW9uOiAwLFxuICAgICAgbm90aWNlczogW10sXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnMuZXhpc3RzU3luYyh0aGlzLmZpbGVOYW1lKVxuICAgICAgICA/IGF3YWl0IGZzLnJlYWRKU09OKHRoaXMuZmlsZU5hbWUpIGFzIENhY2hlZE5vdGljZXNcbiAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5pb01lc3NhZ2VzLmRlYnVnKGBGYWlsZWQgdG8gbG9hZCBub3RpY2VzIGZyb20gY2FjaGU6ICR7ZX1gKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlKGNhY2hlZDogQ2FjaGVkTm90aWNlcyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmcy53cml0ZUpTT04odGhpcy5maWxlTmFtZSwgY2FjaGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmlvTWVzc2FnZXMuZGVidWcoYEZhaWxlZCB0byBzdG9yZSBub3RpY2VzIGluIHRoZSBjYWNoZTogJHtlfWApO1xuICAgIH1cbiAgfVxufVxuIl19